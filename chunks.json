[
  {
    "content": "function App() {\n  const [count, setCount] = useState(0)\n\n  return (\n    <>\n      <div>\n        <a href=\"https://vite.dev\" target=\"_blank\">\n          <img src={viteLogo} className=\"logo\" alt=\"Vite logo\" />\n        </a>\n        <a href=\"https://react.dev\" target=\"_blank\">\n          <img src={reactLogo} className=\"logo react\" alt=\"React logo\" />\n        </a>\n      </div>\n      <h1>Vite + React</h1>\n      <div className=\"card\">\n        <button onClick={() => setCount((count) => count + 1)}>\n          count is {count}\n        </button>\n        <p>\n          Edit <code>src/App.tsx</code> and save to test HMR\n        </p>\n      </div>\n      <p className=\"read-the-docs\">\n        Click on the Vite and React logos to learn more\n      </p>\n    </>\n  )\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSync-UI\\src\\App.tsx",
    "function_name": "App",
    "start_line": 6,
    "end_line": 33,
    "language": "typescript",
    "chunk_type": "function"
  },
  {
    "content": "const [count, setCount] = useState(0)",
    "file_path": "sample_repo\\StrideSync\\StrideSync-UI\\src\\App.tsx",
    "function_name": "anonymous",
    "start_line": 7,
    "end_line": 7,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "(count) => count + 1",
    "file_path": "sample_repo\\StrideSync\\StrideSync-UI\\src\\App.tsx",
    "function_name": "anonymous",
    "start_line": 21,
    "end_line": 21,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const app = express();",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\local-wrapper\\server.ts",
    "function_name": "anonymous",
    "start_line": 8,
    "end_line": 8,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "const PORT = process.env.PORT || 3000;",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\local-wrapper\\server.ts",
    "function_name": "anonymous",
    "start_line": 9,
    "end_line": 9,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "async (req: Request, res: Response) => {\r\n    try {\r\n        // Create a Lambda-like event object\r\n        const event = {\r\n            path: req.path,\r\n            httpMethod: req.method,\r\n            headers: req.headers,\r\n            queryStringParameters: req.query,\r\n            body: req.body ? JSON.stringify(req.body) : null,\r\n        };\r\n\r\n        // Create a Lambda-like context object\r\n        const context = {\r\n            requestId: `local-${Date.now()}`,\r\n            functionName: 'stride-sync-api-local',\r\n            awsRequestId: `local-${Date.now()}`,\r\n        };\r\n\r\n        // Call the Lambda handler\r\n        const result = await handler(event, context);\r\n\r\n        // Send the response\r\n        res.status(result.statusCode);\r\n        \r\n        if (result.headers) {\r\n            Object.entries(result.headers).forEach(([key, value]) => {\r\n                res.setHeader(key, value as string);\r\n            });\r\n        }\r\n        \r\n        res.send(result.body ? JSON.parse(result.body) : {});\r\n    } catch (error) {\r\n        console.error('Server error:', error);\r\n        res.status(500).json({ message: 'Internal Server Error' });\r\n    }\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\local-wrapper\\server.ts",
    "function_name": "anonymous",
    "start_line": 14,
    "end_line": 49,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const event = {\r\n            path: req.path,\r\n            httpMethod: req.method,\r\n            headers: req.headers,\r\n            queryStringParameters: req.query,\r\n            body: req.body ? JSON.stringify(req.body) : null,\r\n        };",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\local-wrapper\\server.ts",
    "function_name": "anonymous",
    "start_line": 17,
    "end_line": 23,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "const context = {\r\n            requestId: `local-${Date.now()}`,\r\n            functionName: 'stride-sync-api-local',\r\n            awsRequestId: `local-${Date.now()}`,\r\n        };",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\local-wrapper\\server.ts",
    "function_name": "anonymous",
    "start_line": 26,
    "end_line": 30,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "const result = await handler(event, context);",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\local-wrapper\\server.ts",
    "function_name": "anonymous",
    "start_line": 33,
    "end_line": 33,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "([key, value]) => {\r\n                res.setHeader(key, value as string);\r\n            }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\local-wrapper\\server.ts",
    "function_name": "anonymous",
    "start_line": 39,
    "end_line": 41,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => {\r\n    console.log(`\ud83d\ude80 Local development server running on http://localhost:${PORT}`);\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\local-wrapper\\server.ts",
    "function_name": "anonymous",
    "start_line": 51,
    "end_line": 53,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const handler = async (event: any, context: any) => {\r\n    const MODULE = \"MainHandler\";\r\n    try {\r\n        // extract route\r\n        const route = event.path;\r\n\r\n        logInfo('Incoming request', { route, requestId: context.requestId }, MODULE);\r\n\r\n        // route handling logic\r\n        const handlerFunction = getRouteHandler(route);\r\n        if (handlerFunction) {\r\n            return await handlerFunction({ event, context });\r\n        } else {\r\n            logWarn('Route not found', { route }, MODULE);\r\n            return {\r\n                statusCode: 404,\r\n                headers: { \"Content-Type\": \"application/json\" },\r\n                body: JSON.stringify({ message: \"Route Not Found\" }),\r\n            };\r\n        }\r\n    } catch (error) {\r\n        logError(\"Error in handler\", {error: error as Error}, MODULE);\r\n        return {\r\n            statusCode: 500,\r\n            headers: { \"Content-Type\": \"application/json\" },\r\n            body: JSON.stringify({ message: \"Internal Server Error\" }),\r\n        };\r\n    }\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\index.ts",
    "function_name": "anonymous",
    "start_line": 7,
    "end_line": 35,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "async (event: any, context: any) => {\r\n    const MODULE = \"MainHandler\";\r\n    try {\r\n        // extract route\r\n        const route = event.path;\r\n\r\n        logInfo('Incoming request', { route, requestId: context.requestId }, MODULE);\r\n\r\n        // route handling logic\r\n        const handlerFunction = getRouteHandler(route);\r\n        if (handlerFunction) {\r\n            return await handlerFunction({ event, context });\r\n        } else {\r\n            logWarn('Route not found', { route }, MODULE);\r\n            return {\r\n                statusCode: 404,\r\n                headers: { \"Content-Type\": \"application/json\" },\r\n                body: JSON.stringify({ message: \"Route Not Found\" }),\r\n            };\r\n        }\r\n    } catch (error) {\r\n        logError(\"Error in handler\", {error: error as Error}, MODULE);\r\n        return {\r\n            statusCode: 500,\r\n            headers: { \"Content-Type\": \"application/json\" },\r\n            body: JSON.stringify({ message: \"Internal Server Error\" }),\r\n        };\r\n    }\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\index.ts",
    "function_name": "anonymous",
    "start_line": 7,
    "end_line": 35,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const MODULE = \"MainHandler\";",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\index.ts",
    "function_name": "anonymous",
    "start_line": 8,
    "end_line": 8,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "const route = event.path;",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\index.ts",
    "function_name": "anonymous",
    "start_line": 11,
    "end_line": 11,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "const handlerFunction = getRouteHandler(route);",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\index.ts",
    "function_name": "anonymous",
    "start_line": 16,
    "end_line": 16,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "const getRouteHandler = (route: string): ((params: RouteInterface) => Promise<any>) | null => {\r\n    switch (route) {\r\n        case \"/meets\":\r\n            return meetsHandler;\r\n        case \"/meet-info\":\r\n            return meetInfoHandler;\r\n        default:\r\n            return null;\r\n    }\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\index.ts",
    "function_name": "anonymous",
    "start_line": 37,
    "end_line": 46,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "(route: string): ((params: RouteInterface) => Promise<any>) | null => {\r\n    switch (route) {\r\n        case \"/meets\":\r\n            return meetsHandler;\r\n        case \"/meet-info\":\r\n            return meetInfoHandler;\r\n        default:\r\n            return null;\r\n    }\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\index.ts",
    "function_name": "anonymous",
    "start_line": 37,
    "end_line": 46,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const meetInfoHandler = async ({ event, context }: RouteInterface) => {\r\n    try {\r\n        //validate that request is a GET\r\n        const methodError = validateMethod([\"GET\"], event.httpMethod)\r\n        if (methodError) return methodError;\r\n\r\n        //validate query parameters\r\n        const queryParams = event.queryStringParameters || {};\r\n\r\n        const queryParamError = validateQueryParams([\"meetId\"], queryParams);\r\n        if (queryParamError) return queryParamError;\r\n\r\n        const meetId = safeExractQueryParam(\"meetId\", queryParams);\r\n        if (!meetId) {\r\n            throw new Error(\"meetId should be present after validation\");\r\n        }\r\n\r\n        const meetsUseCase = meetsUseCaseFactory();\r\n        const meet = await meetsUseCase.getMeetById(meetId);\r\n\r\n        return lambdaReturnSuccessfullResponse({ meet });\r\n    } catch (error) {\r\n        console.error(\"Error in meetsHandler:\", error);\r\n        return {\r\n            statusCode: 500,\r\n            headers: { \"Content-Type\": \"application/json\" },\r\n            body: JSON.stringify({ message: \"There was an internal servier error while proceesing the meets request\" }),\r\n        }\r\n    }\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\handlers\\MeetInfoHandler.ts",
    "function_name": "anonymous",
    "start_line": 7,
    "end_line": 36,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "async ({ event, context }: RouteInterface) => {\r\n    try {\r\n        //validate that request is a GET\r\n        const methodError = validateMethod([\"GET\"], event.httpMethod)\r\n        if (methodError) return methodError;\r\n\r\n        //validate query parameters\r\n        const queryParams = event.queryStringParameters || {};\r\n\r\n        const queryParamError = validateQueryParams([\"meetId\"], queryParams);\r\n        if (queryParamError) return queryParamError;\r\n\r\n        const meetId = safeExractQueryParam(\"meetId\", queryParams);\r\n        if (!meetId) {\r\n            throw new Error(\"meetId should be present after validation\");\r\n        }\r\n\r\n        const meetsUseCase = meetsUseCaseFactory();\r\n        const meet = await meetsUseCase.getMeetById(meetId);\r\n\r\n        return lambdaReturnSuccessfullResponse({ meet });\r\n    } catch (error) {\r\n        console.error(\"Error in meetsHandler:\", error);\r\n        return {\r\n            statusCode: 500,\r\n            headers: { \"Content-Type\": \"application/json\" },\r\n            body: JSON.stringify({ message: \"There was an internal servier error while proceesing the meets request\" }),\r\n        }\r\n    }\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\handlers\\MeetInfoHandler.ts",
    "function_name": "anonymous",
    "start_line": 7,
    "end_line": 36,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const methodError = validateMethod([\"GET\"], event.httpMethod)",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\handlers\\MeetInfoHandler.ts",
    "function_name": "anonymous",
    "start_line": 10,
    "end_line": 10,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "const queryParams = event.queryStringParameters || {};",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\handlers\\MeetInfoHandler.ts",
    "function_name": "anonymous",
    "start_line": 14,
    "end_line": 14,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "const queryParamError = validateQueryParams([\"meetId\"], queryParams);",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\handlers\\MeetInfoHandler.ts",
    "function_name": "anonymous",
    "start_line": 16,
    "end_line": 16,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "const meetId = safeExractQueryParam(\"meetId\", queryParams);",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\handlers\\MeetInfoHandler.ts",
    "function_name": "anonymous",
    "start_line": 19,
    "end_line": 19,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "const meetsUseCase = meetsUseCaseFactory();",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\handlers\\MeetInfoHandler.ts",
    "function_name": "anonymous",
    "start_line": 24,
    "end_line": 24,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "const meet = await meetsUseCase.getMeetById(meetId);",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\handlers\\MeetInfoHandler.ts",
    "function_name": "anonymous",
    "start_line": 25,
    "end_line": 25,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "const meetsHandler = async ({ event, context }: RouteInterface) => {\r\n    try {\r\n        //validate that request is a GET\r\n        const methodError = validateMethod([\"GET\"], event.httpMethod)\r\n        if (methodError) return methodError;\r\n\r\n        // get query parameters if any\r\n        const queryParams = event.queryStringParameters || {};\r\n        const takeRaw = queryParams.take ? parseInt(queryParams.take) : undefined;\r\n        const takeActual = (takeRaw && takeRaw > 0) ? Math.min(takeRaw, 40) : 20; // default to 20, max 40\r\n        const skip = queryParams.skip ? parseInt(queryParams.skip) : undefined;\r\n\r\n        const meetsUseCase = meetsUseCaseFactory();\r\n        const meets = await meetsUseCase.getMeets(takeActual, skip);\r\n\r\n        return lambdaReturnSuccessfullResponse({ meets });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error in meetsHandler:\", error);\r\n        return {\r\n            statusCode: 500,\r\n            headers: { \"Content-Type\": \"application/json\" },\r\n            body: JSON.stringify({ message: \"There was an internal servier error while proceesing the meets request\" }),\r\n        }\r\n    }\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\handlers\\MeetsHandler.ts",
    "function_name": "anonymous",
    "start_line": 7,
    "end_line": 32,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "async ({ event, context }: RouteInterface) => {\r\n    try {\r\n        //validate that request is a GET\r\n        const methodError = validateMethod([\"GET\"], event.httpMethod)\r\n        if (methodError) return methodError;\r\n\r\n        // get query parameters if any\r\n        const queryParams = event.queryStringParameters || {};\r\n        const takeRaw = queryParams.take ? parseInt(queryParams.take) : undefined;\r\n        const takeActual = (takeRaw && takeRaw > 0) ? Math.min(takeRaw, 40) : 20; // default to 20, max 40\r\n        const skip = queryParams.skip ? parseInt(queryParams.skip) : undefined;\r\n\r\n        const meetsUseCase = meetsUseCaseFactory();\r\n        const meets = await meetsUseCase.getMeets(takeActual, skip);\r\n\r\n        return lambdaReturnSuccessfullResponse({ meets });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error in meetsHandler:\", error);\r\n        return {\r\n            statusCode: 500,\r\n            headers: { \"Content-Type\": \"application/json\" },\r\n            body: JSON.stringify({ message: \"There was an internal servier error while proceesing the meets request\" }),\r\n        }\r\n    }\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\handlers\\MeetsHandler.ts",
    "function_name": "anonymous",
    "start_line": 7,
    "end_line": 32,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const methodError = validateMethod([\"GET\"], event.httpMethod)",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\handlers\\MeetsHandler.ts",
    "function_name": "anonymous",
    "start_line": 10,
    "end_line": 10,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "const queryParams = event.queryStringParameters || {};",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\handlers\\MeetsHandler.ts",
    "function_name": "anonymous",
    "start_line": 14,
    "end_line": 14,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "const takeRaw = queryParams.take ? parseInt(queryParams.take) : undefined;",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\handlers\\MeetsHandler.ts",
    "function_name": "anonymous",
    "start_line": 15,
    "end_line": 15,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "const takeActual = (takeRaw && takeRaw > 0) ? Math.min(takeRaw, 40) : 20;",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\handlers\\MeetsHandler.ts",
    "function_name": "anonymous",
    "start_line": 16,
    "end_line": 16,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "const skip = queryParams.skip ? parseInt(queryParams.skip) : undefined;",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\handlers\\MeetsHandler.ts",
    "function_name": "anonymous",
    "start_line": 17,
    "end_line": 17,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "const meetsUseCase = meetsUseCaseFactory();",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\handlers\\MeetsHandler.ts",
    "function_name": "anonymous",
    "start_line": 19,
    "end_line": 19,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "const meets = await meetsUseCase.getMeets(takeActual, skip);",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\handlers\\MeetsHandler.ts",
    "function_name": "anonymous",
    "start_line": 20,
    "end_line": 20,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "() => ({\r\n    logInfo: vi.fn(),\r\n    logError: vi.fn(),\r\n    logWarn: vi.fn(),\r\n    logDebug: vi.fn()\r\n})",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 6,
    "end_line": 11,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => ({\r\n    MongoDBRepository: vi.fn(function(this: any) {\r\n        return {\r\n            fetch: vi.fn()\r\n        };\r\n    })\r\n})",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 14,
    "end_line": 20,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const mockCacheService = {\r\n    buildCacheKey: vi.fn((type: string, params: Record<string, any>) => `${type}:${JSON.stringify(params)}`),\r\n    get: vi.fn(),\r\n    set: vi.fn(),\r\n    delete: vi.fn(),\r\n    clear: vi.fn(),\r\n    prune: vi.fn(),\r\n    stats: vi.fn()\r\n};",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 23,
    "end_line": 31,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "(type: string, params: Record<string, any>) => `${type}:${JSON.stringify(params)}`",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 24,
    "end_line": 24,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => ({\r\n    cacheServiceFactory: vi.fn(() => mockCacheService)\r\n})",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 33,
    "end_line": 35,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => mockCacheService",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.test.ts",
    "function_name": "mockCacheService",
    "start_line": 34,
    "end_line": 34,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => {\r\n    let repository: MeetsRepository;\r\n    let mockMongoRepo: any;\r\n\r\n    beforeEach(() => {\r\n        vi.clearAllMocks();\r\n        process.env.MONGODB_CONNECTION_STRING = 'mongodb://test:27017/testdb';\r\n        \r\n        repository = new MeetsRepository();\r\n        mockMongoRepo = (repository as any).mongoRepo;\r\n    });\r\n\r\n    afterEach(() => {\r\n        delete process.env.MONGODB_CONNECTION_STRING;\r\n    });\r\n\r\n    describe('constructor', () => {\r\n        it('creates instance with MongoDBRepository and CacheService', () => {\r\n            expect(repository).toBeDefined();\r\n            expect((repository as any).mongoRepo).toBeDefined();\r\n            expect((repository as any).cache).toBeDefined();\r\n        });\r\n\r\n        it('sets correct collection name', () => {\r\n            expect((repository as any).COLLECTION).toBe('meets');\r\n        });\r\n\r\n        it('sets correct cache TTL values', () => {\r\n            expect((repository as any).MEETS_CACHE_TTL_SECONDS).toBe(300);\r\n            expect((repository as any).MEET_BY_ID_CACHE_TTL_SECONDS).toBe(300);\r\n        });\r\n    });\r\n\r\n    describe('getMeets', () => {\r\n        const mockMeets = [\r\n            { _id: new ObjectId(), meet_name: 'Meet 1', city: 'City 1' },\r\n            { _id: new ObjectId(), meet_name: 'Meet 2', city: 'City 2' }\r\n        ];\r\n\r\n        it('returns cached data when available', async () => {\r\n            mockCacheService.get.mockReturnValueOnce(mockMeets);\r\n\r\n            const result = await repository.getMeets(10, 0);\r\n\r\n            expect(mockCacheService.get).toHaveBeenCalledTimes(1);\r\n            expect(mockCacheService.buildCacheKey).toHaveBeenCalledWith('meets', { take: 10, skip: 0 });\r\n            expect(mockMongoRepo.fetch).not.toHaveBeenCalled();\r\n            expect(result).toEqual(mockMeets);\r\n        });\r\n\r\n        it('fetches from MongoDB when cache miss', async () => {\r\n            mockCacheService.get.mockReturnValueOnce(null);\r\n            mockMongoRepo.fetch.mockResolvedValueOnce(mockMeets);\r\n\r\n            const result = await repository.getMeets(10, 0);\r\n\r\n            expect(mockCacheService.get).toHaveBeenCalledTimes(1);\r\n            expect(mockMongoRepo.fetch).toHaveBeenCalledWith('meets', {}, { limit: 10, skip: 0 });\r\n            expect(result).toEqual(mockMeets);\r\n        });\r\n\r\n        it('stores in cache when disabledCache is false', async () => {\r\n            mockCacheService.get.mockReturnValueOnce(null);\r\n            mockMongoRepo.fetch.mockResolvedValueOnce(mockMeets);\r\n\r\n            await repository.getMeets(10, 0, false);\r\n\r\n            expect(mockCacheService.set).toHaveBeenCalledWith(\r\n                expect.any(String),\r\n                mockMeets,\r\n                300\r\n            );\r\n        });\r\n\r\n        it('does not store in cache when disabledCache is true', async () => {\r\n            mockCacheService.get.mockReturnValueOnce(null);\r\n            mockMongoRepo.fetch.mockResolvedValueOnce(mockMeets);\r\n\r\n            await repository.getMeets(10, 0, true);\r\n\r\n            expect(mockCacheService.set).not.toHaveBeenCalled();\r\n        });\r\n\r\n        it('defaults skip to undefined when not provided', async () => {\r\n            mockCacheService.get.mockReturnValueOnce(null);\r\n            mockMongoRepo.fetch.mockResolvedValueOnce(mockMeets);\r\n\r\n            await repository.getMeets(20);\r\n\r\n            expect(mockCacheService.buildCacheKey).toHaveBeenCalledWith('meets', { take: 20, skip: 0 });\r\n            expect(mockMongoRepo.fetch).toHaveBeenCalledWith('meets', {}, { limit: 20, skip: undefined });\r\n        });\r\n\r\n        it('passes skip parameter correctly when provided', async () => {\r\n            mockCacheService.get.mockReturnValueOnce(null);\r\n            mockMongoRepo.fetch.mockResolvedValueOnce(mockMeets);\r\n\r\n            await repository.getMeets(20, 40);\r\n\r\n            expect(mockCacheService.buildCacheKey).toHaveBeenCalledWith('meets', { take: 20, skip: 40 });\r\n            expect(mockMongoRepo.fetch).toHaveBeenCalledWith('meets', {}, { limit: 20, skip: 40 });\r\n        });\r\n\r\n        it('returns empty array when no meets found', async () => {\r\n            mockCacheService.get.mockReturnValueOnce(null);\r\n            mockMongoRepo.fetch.mockResolvedValueOnce([]);\r\n\r\n            const result = await repository.getMeets(10);\r\n\r\n            expect(result).toEqual([]);\r\n            expect(mockCacheService.set).toHaveBeenCalledWith(\r\n                expect.any(String),\r\n                [],\r\n                300\r\n            );\r\n        });\r\n    });\r\n\r\n    describe('getMeetById', () => {\r\n        const mockMeetId = new ObjectId().toString();\r\n        const mockMeet = {\r\n            _id: new ObjectId(mockMeetId),\r\n            meet_name: 'Test Meet',\r\n            city: 'Test City'\r\n        };\r\n\r\n        it('returns cached data when available', async () => {\r\n            mockCacheService.get.mockReturnValueOnce(mockMeet);\r\n\r\n            const result = await repository.getMeetById(mockMeetId);\r\n\r\n            expect(mockCacheService.get).toHaveBeenCalledTimes(1);\r\n            expect(mockCacheService.buildCacheKey).toHaveBeenCalledWith('meet', { id: mockMeetId });\r\n            expect(mockMongoRepo.fetch).not.toHaveBeenCalled();\r\n            expect(result).toEqual(mockMeet);\r\n        });\r\n\r\n        it('fetches from MongoDB when cache miss', async () => {\r\n            mockCacheService.get.mockReturnValueOnce(null);\r\n            mockMongoRepo.fetch.mockResolvedValueOnce([mockMeet]);\r\n\r\n            const result = await repository.getMeetById(mockMeetId);\r\n\r\n            expect(mockCacheService.get).toHaveBeenCalledTimes(1);\r\n            expect(mockMongoRepo.fetch).toHaveBeenCalledWith(\r\n                'meets',\r\n                { _id: new ObjectId(mockMeetId) },\r\n                { limit: 1 }\r\n            );\r\n            expect(result).toEqual(mockMeet);\r\n        });\r\n\r\n        it('returns null when meet not found', async () => {\r\n            mockCacheService.get.mockReturnValueOnce(null);\r\n            mockMongoRepo.fetch.mockResolvedValueOnce([]);\r\n\r\n            const result = await repository.getMeetById(mockMeetId);\r\n\r\n            expect(result).toBeNull();\r\n            expect(mockCacheService.set).not.toHaveBeenCalled();\r\n        });\r\n\r\n        it('stores in cache when disabledCache is false and meet found', async () => {\r\n            mockCacheService.get.mockReturnValueOnce(null);\r\n            mockMongoRepo.fetch.mockResolvedValueOnce([mockMeet]);\r\n\r\n            await repository.getMeetById(mockMeetId, false);\r\n\r\n            expect(mockCacheService.set).toHaveBeenCalledWith(\r\n                expect.any(String),\r\n                mockMeet,\r\n                300\r\n            );\r\n        });\r\n\r\n        it('does not store in cache when disabledCache is true', async () => {\r\n            mockCacheService.get.mockReturnValueOnce(null);\r\n            mockMongoRepo.fetch.mockResolvedValueOnce([mockMeet]);\r\n\r\n            await repository.getMeetById(mockMeetId, true);\r\n\r\n            expect(mockCacheService.set).not.toHaveBeenCalled();\r\n        });\r\n\r\n        it('converts string ID to ObjectId', async () => {\r\n            mockCacheService.get.mockReturnValueOnce(null);\r\n            mockMongoRepo.fetch.mockResolvedValueOnce([mockMeet]);\r\n\r\n            await repository.getMeetById(mockMeetId);\r\n\r\n            const fetchCall = mockMongoRepo.fetch.mock.calls[0];\r\n            expect(fetchCall[1]._id).toBeInstanceOf(ObjectId);\r\n            expect(fetchCall[1]._id.toString()).toBe(mockMeetId);\r\n        });\r\n\r\n        it('returns first element from result array', async () => {\r\n            const additionalMeets = [\r\n                mockMeet,\r\n                { _id: new ObjectId(), meet_name: 'Should not return', city: 'Other' }\r\n            ];\r\n            mockCacheService.get.mockReturnValueOnce(null);\r\n            mockMongoRepo.fetch.mockResolvedValueOnce(additionalMeets);\r\n\r\n            const result = await repository.getMeetById(mockMeetId);\r\n\r\n            expect(result).toEqual(mockMeet);\r\n            expect(result).not.toEqual(additionalMeets[1]);\r\n        });\r\n\r\n        it('builds correct cache key with meet ID', async () => {\r\n            mockCacheService.get.mockReturnValueOnce(null);\r\n            mockMongoRepo.fetch.mockResolvedValueOnce([mockMeet]);\r\n\r\n            await repository.getMeetById(mockMeetId);\r\n\r\n            expect(mockCacheService.buildCacheKey).toHaveBeenCalledWith('meet', { id: mockMeetId });\r\n        });\r\n    });\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 37,
    "end_line": 255,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "let repository: MeetsRepository;",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 38,
    "end_line": 38,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "let mockMongoRepo: any;",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 39,
    "end_line": 39,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "() => {\r\n        vi.clearAllMocks();\r\n        process.env.MONGODB_CONNECTION_STRING = 'mongodb://test:27017/testdb';\r\n        \r\n        repository = new MeetsRepository();\r\n        mockMongoRepo = (repository as any).mongoRepo;\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 41,
    "end_line": 47,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => {\r\n        delete process.env.MONGODB_CONNECTION_STRING;\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 49,
    "end_line": 51,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => {\r\n        it('creates instance with MongoDBRepository and CacheService', () => {\r\n            expect(repository).toBeDefined();\r\n            expect((repository as any).mongoRepo).toBeDefined();\r\n            expect((repository as any).cache).toBeDefined();\r\n        });\r\n\r\n        it('sets correct collection name', () => {\r\n            expect((repository as any).COLLECTION).toBe('meets');\r\n        });\r\n\r\n        it('sets correct cache TTL values', () => {\r\n            expect((repository as any).MEETS_CACHE_TTL_SECONDS).toBe(300);\r\n            expect((repository as any).MEET_BY_ID_CACHE_TTL_SECONDS).toBe(300);\r\n        });\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 53,
    "end_line": 68,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => {\r\n            expect(repository).toBeDefined();\r\n            expect((repository as any).mongoRepo).toBeDefined();\r\n            expect((repository as any).cache).toBeDefined();\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 54,
    "end_line": 58,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => {\r\n            expect((repository as any).COLLECTION).toBe('meets');\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 60,
    "end_line": 62,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => {\r\n            expect((repository as any).MEETS_CACHE_TTL_SECONDS).toBe(300);\r\n            expect((repository as any).MEET_BY_ID_CACHE_TTL_SECONDS).toBe(300);\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 64,
    "end_line": 67,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => {\r\n        const mockMeets = [\r\n            { _id: new ObjectId(), meet_name: 'Meet 1', city: 'City 1' },\r\n            { _id: new ObjectId(), meet_name: 'Meet 2', city: 'City 2' }\r\n        ];\r\n\r\n        it('returns cached data when available', async () => {\r\n            mockCacheService.get.mockReturnValueOnce(mockMeets);\r\n\r\n            const result = await repository.getMeets(10, 0);\r\n\r\n            expect(mockCacheService.get).toHaveBeenCalledTimes(1);\r\n            expect(mockCacheService.buildCacheKey).toHaveBeenCalledWith('meets', { take: 10, skip: 0 });\r\n            expect(mockMongoRepo.fetch).not.toHaveBeenCalled();\r\n            expect(result).toEqual(mockMeets);\r\n        });\r\n\r\n        it('fetches from MongoDB when cache miss', async () => {\r\n            mockCacheService.get.mockReturnValueOnce(null);\r\n            mockMongoRepo.fetch.mockResolvedValueOnce(mockMeets);\r\n\r\n            const result = await repository.getMeets(10, 0);\r\n\r\n            expect(mockCacheService.get).toHaveBeenCalledTimes(1);\r\n            expect(mockMongoRepo.fetch).toHaveBeenCalledWith('meets', {}, { limit: 10, skip: 0 });\r\n            expect(result).toEqual(mockMeets);\r\n        });\r\n\r\n        it('stores in cache when disabledCache is false', async () => {\r\n            mockCacheService.get.mockReturnValueOnce(null);\r\n            mockMongoRepo.fetch.mockResolvedValueOnce(mockMeets);\r\n\r\n            await repository.getMeets(10, 0, false);\r\n\r\n            expect(mockCacheService.set).toHaveBeenCalledWith(\r\n                expect.any(String),\r\n                mockMeets,\r\n                300\r\n            );\r\n        });\r\n\r\n        it('does not store in cache when disabledCache is true', async () => {\r\n            mockCacheService.get.mockReturnValueOnce(null);\r\n            mockMongoRepo.fetch.mockResolvedValueOnce(mockMeets);\r\n\r\n            await repository.getMeets(10, 0, true);\r\n\r\n            expect(mockCacheService.set).not.toHaveBeenCalled();\r\n        });\r\n\r\n        it('defaults skip to undefined when not provided', async () => {\r\n            mockCacheService.get.mockReturnValueOnce(null);\r\n            mockMongoRepo.fetch.mockResolvedValueOnce(mockMeets);\r\n\r\n            await repository.getMeets(20);\r\n\r\n            expect(mockCacheService.buildCacheKey).toHaveBeenCalledWith('meets', { take: 20, skip: 0 });\r\n            expect(mockMongoRepo.fetch).toHaveBeenCalledWith('meets', {}, { limit: 20, skip: undefined });\r\n        });\r\n\r\n        it('passes skip parameter correctly when provided', async () => {\r\n            mockCacheService.get.mockReturnValueOnce(null);\r\n            mockMongoRepo.fetch.mockResolvedValueOnce(mockMeets);\r\n\r\n            await repository.getMeets(20, 40);\r\n\r\n            expect(mockCacheService.buildCacheKey).toHaveBeenCalledWith('meets', { take: 20, skip: 40 });\r\n            expect(mockMongoRepo.fetch).toHaveBeenCalledWith('meets', {}, { limit: 20, skip: 40 });\r\n        });\r\n\r\n        it('returns empty array when no meets found', async () => {\r\n            mockCacheService.get.mockReturnValueOnce(null);\r\n            mockMongoRepo.fetch.mockResolvedValueOnce([]);\r\n\r\n            const result = await repository.getMeets(10);\r\n\r\n            expect(result).toEqual([]);\r\n            expect(mockCacheService.set).toHaveBeenCalledWith(\r\n                expect.any(String),\r\n                [],\r\n                300\r\n            );\r\n        });\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 70,
    "end_line": 153,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const mockMeets = [\r\n            { _id: new ObjectId(), meet_name: 'Meet 1', city: 'City 1' },\r\n            { _id: new ObjectId(), meet_name: 'Meet 2', city: 'City 2' }\r\n        ];",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 71,
    "end_line": 74,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "async () => {\r\n            mockCacheService.get.mockReturnValueOnce(mockMeets);\r\n\r\n            const result = await repository.getMeets(10, 0);\r\n\r\n            expect(mockCacheService.get).toHaveBeenCalledTimes(1);\r\n            expect(mockCacheService.buildCacheKey).toHaveBeenCalledWith('meets', { take: 10, skip: 0 });\r\n            expect(mockMongoRepo.fetch).not.toHaveBeenCalled();\r\n            expect(result).toEqual(mockMeets);\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 76,
    "end_line": 85,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const result = await repository.getMeets(10, 0);",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 79,
    "end_line": 79,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "async () => {\r\n            mockCacheService.get.mockReturnValueOnce(null);\r\n            mockMongoRepo.fetch.mockResolvedValueOnce(mockMeets);\r\n\r\n            const result = await repository.getMeets(10, 0);\r\n\r\n            expect(mockCacheService.get).toHaveBeenCalledTimes(1);\r\n            expect(mockMongoRepo.fetch).toHaveBeenCalledWith('meets', {}, { limit: 10, skip: 0 });\r\n            expect(result).toEqual(mockMeets);\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 87,
    "end_line": 96,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const result = await repository.getMeets(10, 0);",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 91,
    "end_line": 91,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "async () => {\r\n            mockCacheService.get.mockReturnValueOnce(null);\r\n            mockMongoRepo.fetch.mockResolvedValueOnce(mockMeets);\r\n\r\n            await repository.getMeets(10, 0, false);\r\n\r\n            expect(mockCacheService.set).toHaveBeenCalledWith(\r\n                expect.any(String),\r\n                mockMeets,\r\n                300\r\n            );\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 98,
    "end_line": 109,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "async () => {\r\n            mockCacheService.get.mockReturnValueOnce(null);\r\n            mockMongoRepo.fetch.mockResolvedValueOnce(mockMeets);\r\n\r\n            await repository.getMeets(10, 0, true);\r\n\r\n            expect(mockCacheService.set).not.toHaveBeenCalled();\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 111,
    "end_line": 118,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "async () => {\r\n            mockCacheService.get.mockReturnValueOnce(null);\r\n            mockMongoRepo.fetch.mockResolvedValueOnce(mockMeets);\r\n\r\n            await repository.getMeets(20);\r\n\r\n            expect(mockCacheService.buildCacheKey).toHaveBeenCalledWith('meets', { take: 20, skip: 0 });\r\n            expect(mockMongoRepo.fetch).toHaveBeenCalledWith('meets', {}, { limit: 20, skip: undefined });\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 120,
    "end_line": 128,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "async () => {\r\n            mockCacheService.get.mockReturnValueOnce(null);\r\n            mockMongoRepo.fetch.mockResolvedValueOnce(mockMeets);\r\n\r\n            await repository.getMeets(20, 40);\r\n\r\n            expect(mockCacheService.buildCacheKey).toHaveBeenCalledWith('meets', { take: 20, skip: 40 });\r\n            expect(mockMongoRepo.fetch).toHaveBeenCalledWith('meets', {}, { limit: 20, skip: 40 });\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 130,
    "end_line": 138,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "async () => {\r\n            mockCacheService.get.mockReturnValueOnce(null);\r\n            mockMongoRepo.fetch.mockResolvedValueOnce([]);\r\n\r\n            const result = await repository.getMeets(10);\r\n\r\n            expect(result).toEqual([]);\r\n            expect(mockCacheService.set).toHaveBeenCalledWith(\r\n                expect.any(String),\r\n                [],\r\n                300\r\n            );\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 140,
    "end_line": 152,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const result = await repository.getMeets(10);",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 144,
    "end_line": 144,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "() => {\r\n        const mockMeetId = new ObjectId().toString();\r\n        const mockMeet = {\r\n            _id: new ObjectId(mockMeetId),\r\n            meet_name: 'Test Meet',\r\n            city: 'Test City'\r\n        };\r\n\r\n        it('returns cached data when available', async () => {\r\n            mockCacheService.get.mockReturnValueOnce(mockMeet);\r\n\r\n            const result = await repository.getMeetById(mockMeetId);\r\n\r\n            expect(mockCacheService.get).toHaveBeenCalledTimes(1);\r\n            expect(mockCacheService.buildCacheKey).toHaveBeenCalledWith('meet', { id: mockMeetId });\r\n            expect(mockMongoRepo.fetch).not.toHaveBeenCalled();\r\n            expect(result).toEqual(mockMeet);\r\n        });\r\n\r\n        it('fetches from MongoDB when cache miss', async () => {\r\n            mockCacheService.get.mockReturnValueOnce(null);\r\n            mockMongoRepo.fetch.mockResolvedValueOnce([mockMeet]);\r\n\r\n            const result = await repository.getMeetById(mockMeetId);\r\n\r\n            expect(mockCacheService.get).toHaveBeenCalledTimes(1);\r\n            expect(mockMongoRepo.fetch).toHaveBeenCalledWith(\r\n                'meets',\r\n                { _id: new ObjectId(mockMeetId) },\r\n                { limit: 1 }\r\n            );\r\n            expect(result).toEqual(mockMeet);\r\n        });\r\n\r\n        it('returns null when meet not found', async () => {\r\n            mockCacheService.get.mockReturnValueOnce(null);\r\n            mockMongoRepo.fetch.mockResolvedValueOnce([]);\r\n\r\n            const result = await repository.getMeetById(mockMeetId);\r\n\r\n            expect(result).toBeNull();\r\n            expect(mockCacheService.set).not.toHaveBeenCalled();\r\n        });\r\n\r\n        it('stores in cache when disabledCache is false and meet found', async () => {\r\n            mockCacheService.get.mockReturnValueOnce(null);\r\n            mockMongoRepo.fetch.mockResolvedValueOnce([mockMeet]);\r\n\r\n            await repository.getMeetById(mockMeetId, false);\r\n\r\n            expect(mockCacheService.set).toHaveBeenCalledWith(\r\n                expect.any(String),\r\n                mockMeet,\r\n                300\r\n            );\r\n        });\r\n\r\n        it('does not store in cache when disabledCache is true', async () => {\r\n            mockCacheService.get.mockReturnValueOnce(null);\r\n            mockMongoRepo.fetch.mockResolvedValueOnce([mockMeet]);\r\n\r\n            await repository.getMeetById(mockMeetId, true);\r\n\r\n            expect(mockCacheService.set).not.toHaveBeenCalled();\r\n        });\r\n\r\n        it('converts string ID to ObjectId', async () => {\r\n            mockCacheService.get.mockReturnValueOnce(null);\r\n            mockMongoRepo.fetch.mockResolvedValueOnce([mockMeet]);\r\n\r\n            await repository.getMeetById(mockMeetId);\r\n\r\n            const fetchCall = mockMongoRepo.fetch.mock.calls[0];\r\n            expect(fetchCall[1]._id).toBeInstanceOf(ObjectId);\r\n            expect(fetchCall[1]._id.toString()).toBe(mockMeetId);\r\n        });\r\n\r\n        it('returns first element from result array', async () => {\r\n            const additionalMeets = [\r\n                mockMeet,\r\n                { _id: new ObjectId(), meet_name: 'Should not return', city: 'Other' }\r\n            ];\r\n            mockCacheService.get.mockReturnValueOnce(null);\r\n            mockMongoRepo.fetch.mockResolvedValueOnce(additionalMeets);\r\n\r\n            const result = await repository.getMeetById(mockMeetId);\r\n\r\n            expect(result).toEqual(mockMeet);\r\n            expect(result).not.toEqual(additionalMeets[1]);\r\n        });\r\n\r\n        it('builds correct cache key with meet ID', async () => {\r\n            mockCacheService.get.mockReturnValueOnce(null);\r\n            mockMongoRepo.fetch.mockResolvedValueOnce([mockMeet]);\r\n\r\n            await repository.getMeetById(mockMeetId);\r\n\r\n            expect(mockCacheService.buildCacheKey).toHaveBeenCalledWith('meet', { id: mockMeetId });\r\n        });\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 155,
    "end_line": 254,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const mockMeetId = new ObjectId().toString();",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 156,
    "end_line": 156,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "const mockMeet = {\r\n            _id: new ObjectId(mockMeetId),\r\n            meet_name: 'Test Meet',\r\n            city: 'Test City'\r\n        };",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 157,
    "end_line": 161,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "async () => {\r\n            mockCacheService.get.mockReturnValueOnce(mockMeet);\r\n\r\n            const result = await repository.getMeetById(mockMeetId);\r\n\r\n            expect(mockCacheService.get).toHaveBeenCalledTimes(1);\r\n            expect(mockCacheService.buildCacheKey).toHaveBeenCalledWith('meet', { id: mockMeetId });\r\n            expect(mockMongoRepo.fetch).not.toHaveBeenCalled();\r\n            expect(result).toEqual(mockMeet);\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 163,
    "end_line": 172,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const result = await repository.getMeetById(mockMeetId);",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 166,
    "end_line": 166,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "async () => {\r\n            mockCacheService.get.mockReturnValueOnce(null);\r\n            mockMongoRepo.fetch.mockResolvedValueOnce([mockMeet]);\r\n\r\n            const result = await repository.getMeetById(mockMeetId);\r\n\r\n            expect(mockCacheService.get).toHaveBeenCalledTimes(1);\r\n            expect(mockMongoRepo.fetch).toHaveBeenCalledWith(\r\n                'meets',\r\n                { _id: new ObjectId(mockMeetId) },\r\n                { limit: 1 }\r\n            );\r\n            expect(result).toEqual(mockMeet);\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 174,
    "end_line": 187,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const result = await repository.getMeetById(mockMeetId);",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 178,
    "end_line": 178,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "async () => {\r\n            mockCacheService.get.mockReturnValueOnce(null);\r\n            mockMongoRepo.fetch.mockResolvedValueOnce([]);\r\n\r\n            const result = await repository.getMeetById(mockMeetId);\r\n\r\n            expect(result).toBeNull();\r\n            expect(mockCacheService.set).not.toHaveBeenCalled();\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 189,
    "end_line": 197,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const result = await repository.getMeetById(mockMeetId);",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 193,
    "end_line": 193,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "async () => {\r\n            mockCacheService.get.mockReturnValueOnce(null);\r\n            mockMongoRepo.fetch.mockResolvedValueOnce([mockMeet]);\r\n\r\n            await repository.getMeetById(mockMeetId, false);\r\n\r\n            expect(mockCacheService.set).toHaveBeenCalledWith(\r\n                expect.any(String),\r\n                mockMeet,\r\n                300\r\n            );\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 199,
    "end_line": 210,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "async () => {\r\n            mockCacheService.get.mockReturnValueOnce(null);\r\n            mockMongoRepo.fetch.mockResolvedValueOnce([mockMeet]);\r\n\r\n            await repository.getMeetById(mockMeetId, true);\r\n\r\n            expect(mockCacheService.set).not.toHaveBeenCalled();\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 212,
    "end_line": 219,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "async () => {\r\n            mockCacheService.get.mockReturnValueOnce(null);\r\n            mockMongoRepo.fetch.mockResolvedValueOnce([mockMeet]);\r\n\r\n            await repository.getMeetById(mockMeetId);\r\n\r\n            const fetchCall = mockMongoRepo.fetch.mock.calls[0];\r\n            expect(fetchCall[1]._id).toBeInstanceOf(ObjectId);\r\n            expect(fetchCall[1]._id.toString()).toBe(mockMeetId);\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 221,
    "end_line": 230,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const fetchCall = mockMongoRepo.fetch.mock.calls[0];",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 227,
    "end_line": 227,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "async () => {\r\n            const additionalMeets = [\r\n                mockMeet,\r\n                { _id: new ObjectId(), meet_name: 'Should not return', city: 'Other' }\r\n            ];\r\n            mockCacheService.get.mockReturnValueOnce(null);\r\n            mockMongoRepo.fetch.mockResolvedValueOnce(additionalMeets);\r\n\r\n            const result = await repository.getMeetById(mockMeetId);\r\n\r\n            expect(result).toEqual(mockMeet);\r\n            expect(result).not.toEqual(additionalMeets[1]);\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 232,
    "end_line": 244,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const additionalMeets = [\r\n                mockMeet,\r\n                { _id: new ObjectId(), meet_name: 'Should not return', city: 'Other' }\r\n            ];",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 233,
    "end_line": 236,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "const result = await repository.getMeetById(mockMeetId);",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 240,
    "end_line": 240,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "async () => {\r\n            mockCacheService.get.mockReturnValueOnce(null);\r\n            mockMongoRepo.fetch.mockResolvedValueOnce([mockMeet]);\r\n\r\n            await repository.getMeetById(mockMeetId);\r\n\r\n            expect(mockCacheService.buildCacheKey).toHaveBeenCalledWith('meet', { id: mockMeetId });\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 246,
    "end_line": 253,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "class MeetsRepository {\r\n    private readonly MODULE = \"MeetsRepository\";\r\n    private mongoRepo: MongoDBRepository;\r\n    private cache: CacheService;\r\n    private readonly COLLECTION = \"meets\";\r\n    private readonly MEETS_CACHE_TTL_SECONDS = 300; // 5 minutes\r\n    private readonly MEET_BY_ID_CACHE_TTL_SECONDS = 300; // 5 minutes\r\n\r\n    constructor() {\r\n        this.mongoRepo = new MongoDBRepository(process.env.MONGODB_CONNECTION_STRING);\r\n        this.cache = cacheServiceFactory();\r\n    }\r\n    \r\n\r\n    async getMeets(take: number, skip?: number, disabledCache: boolean = false): Promise<MeetRepo[]> {\r\n        logInfo(\"Fetching meets\", { take, skip, disabledCache }, this.MODULE);\r\n        const cacheKey = this.cache.buildCacheKey(\"meets\", { take, skip: skip || 0 });\r\n        const cached = this.cache.get<MeetRepo[]>(cacheKey);\r\n        if (cached) return cached;\r\n\r\n        const data = await this.mongoRepo.fetch<MeetRepo>(\r\n            this.COLLECTION, \r\n            {}, \r\n            { limit: take, skip }\r\n        );\r\n        \r\n        if (!disabledCache) {\r\n            this.cache.set(cacheKey, data, this.MEETS_CACHE_TTL_SECONDS);\r\n        }\r\n        return data;\r\n    }\r\n\r\n    async getMeetById(meetId: string, disabledCache: boolean = false): Promise<MeetRepo | null> {\r\n        logInfo(\"Fetching meet by ID\", { meetId, disabledCache }, this.MODULE);\r\n        const cacheKey = this.cache.buildCacheKey(\"meet\", { id: meetId });\r\n        const cached = this.cache.get<MeetRepo>(cacheKey);\r\n        if (cached) return cached;\r\n\r\n        const data = await this.mongoRepo.fetch<MeetRepo>(\r\n            this.COLLECTION,\r\n            { _id: new ObjectId(meetId) },\r\n            { limit: 1 }\r\n        );\r\n\r\n        if (data.length === 0) return null;\r\n        \r\n        if (!disabledCache) {\r\n            this.cache.set(cacheKey, data[0], this.MEET_BY_ID_CACHE_TTL_SECONDS);\r\n        }\r\n        return data[0];\r\n    }\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.ts",
    "function_name": "MeetsRepository",
    "start_line": 8,
    "end_line": 59,
    "language": "typescript",
    "chunk_type": "class"
  },
  {
    "content": "constructor() {\r\n        this.mongoRepo = new MongoDBRepository(process.env.MONGODB_CONNECTION_STRING);\r\n        this.cache = cacheServiceFactory();\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.ts",
    "function_name": "anonymous",
    "start_line": 16,
    "end_line": 19,
    "language": "typescript",
    "chunk_type": "method"
  },
  {
    "content": "async getMeets(take: number, skip?: number, disabledCache: boolean = false): Promise<MeetRepo[]> {\r\n        logInfo(\"Fetching meets\", { take, skip, disabledCache }, this.MODULE);\r\n        const cacheKey = this.cache.buildCacheKey(\"meets\", { take, skip: skip || 0 });\r\n        const cached = this.cache.get<MeetRepo[]>(cacheKey);\r\n        if (cached) return cached;\r\n\r\n        const data = await this.mongoRepo.fetch<MeetRepo>(\r\n            this.COLLECTION, \r\n            {}, \r\n            { limit: take, skip }\r\n        );\r\n        \r\n        if (!disabledCache) {\r\n            this.cache.set(cacheKey, data, this.MEETS_CACHE_TTL_SECONDS);\r\n        }\r\n        return data;\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.ts",
    "function_name": "anonymous",
    "start_line": 22,
    "end_line": 38,
    "language": "typescript",
    "chunk_type": "method"
  },
  {
    "content": "const cacheKey = this.cache.buildCacheKey(\"meets\", { take, skip: skip || 0 });",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.ts",
    "function_name": "anonymous",
    "start_line": 24,
    "end_line": 24,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "const cached = this.cache.get<MeetRepo[]>(cacheKey);",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.ts",
    "function_name": "anonymous",
    "start_line": 25,
    "end_line": 25,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "const data = await this.mongoRepo.fetch<MeetRepo>(\r\n            this.COLLECTION, \r\n            {}, \r\n            { limit: take, skip }\r\n        );",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.ts",
    "function_name": "anonymous",
    "start_line": 28,
    "end_line": 32,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "async getMeetById(meetId: string, disabledCache: boolean = false): Promise<MeetRepo | null> {\r\n        logInfo(\"Fetching meet by ID\", { meetId, disabledCache }, this.MODULE);\r\n        const cacheKey = this.cache.buildCacheKey(\"meet\", { id: meetId });\r\n        const cached = this.cache.get<MeetRepo>(cacheKey);\r\n        if (cached) return cached;\r\n\r\n        const data = await this.mongoRepo.fetch<MeetRepo>(\r\n            this.COLLECTION,\r\n            { _id: new ObjectId(meetId) },\r\n            { limit: 1 }\r\n        );\r\n\r\n        if (data.length === 0) return null;\r\n        \r\n        if (!disabledCache) {\r\n            this.cache.set(cacheKey, data[0], this.MEET_BY_ID_CACHE_TTL_SECONDS);\r\n        }\r\n        return data[0];\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.ts",
    "function_name": "anonymous",
    "start_line": 40,
    "end_line": 58,
    "language": "typescript",
    "chunk_type": "method"
  },
  {
    "content": "const cacheKey = this.cache.buildCacheKey(\"meet\", { id: meetId });",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.ts",
    "function_name": "anonymous",
    "start_line": 42,
    "end_line": 42,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "const cached = this.cache.get<MeetRepo>(cacheKey);",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.ts",
    "function_name": "anonymous",
    "start_line": 43,
    "end_line": 43,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "const data = await this.mongoRepo.fetch<MeetRepo>(\r\n            this.COLLECTION,\r\n            { _id: new ObjectId(meetId) },\r\n            { limit: 1 }\r\n        );",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MeetsRepository.ts",
    "function_name": "anonymous",
    "start_line": 46,
    "end_line": 50,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "() => ({\r\n    MongoClient: vi.fn(function() {\r\n        return {\r\n            connect: vi.fn().mockResolvedValue(undefined),\r\n            close: vi.fn().mockResolvedValue(undefined),\r\n            db: vi.fn().mockReturnValue({\r\n                collection: vi.fn().mockReturnValue({\r\n                    find: vi.fn().mockReturnValue({\r\n                        skip: vi.fn().mockReturnThis(),\r\n                        limit: vi.fn().mockReturnThis(),\r\n                        toArray: vi.fn().mockResolvedValue([]),\r\n                    }),\r\n                }),\r\n            }),\r\n        };\r\n    }),\r\n})",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 4,
    "end_line": 20,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => ({\r\n    logInfo: vi.fn(),\r\n})",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 22,
    "end_line": 24,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => {\r\n    let repository: MongoDBRepository;\r\n    const mockConnectionString = 'mongodb://test:test@localhost:27017/test';\r\n\r\n    beforeEach(() => {\r\n        vi.clearAllMocks();\r\n    });\r\n\r\n    afterEach(() => {\r\n        vi.clearAllMocks();\r\n    });\r\n\r\n    describe('constructor', () => {\r\n        it('throws error when connection string is not provided', () => {\r\n            expect(() => new MongoDBRepository(undefined)).toThrow('MongoDB connection string is required');\r\n        });\r\n\r\n        it('successfully creates instance with valid connection string', () => {\r\n            const repo = new MongoDBRepository(mockConnectionString);\r\n            expect(repo).toBeInstanceOf(MongoDBRepository);\r\n        });\r\n\r\n        it('stores connection string internally', () => {\r\n            const repo = new MongoDBRepository(mockConnectionString);\r\n            expect(repo).toBeDefined();\r\n        });\r\n    });\r\n\r\n    describe('connect', () => {\r\n        beforeEach(() => {\r\n            repository = new MongoDBRepository(mockConnectionString);\r\n        });\r\n\r\n        it('establishes connection on first call', async () => {\r\n            await repository.connect();\r\n\r\n            const { MongoClient } = await import('mongodb');\r\n            expect(MongoClient).toHaveBeenCalledWith(mockConnectionString);\r\n        });\r\n\r\n        it('does not reconnect when already connected', async () => {\r\n            const { MongoClient } = await import('mongodb');\r\n            const callsBefore = (MongoClient as any).mock.calls.length;\r\n            \r\n            await repository.connect();\r\n            await repository.connect();\r\n\r\n            expect((MongoClient as any).mock.calls.length).toBe(callsBefore + 1);\r\n        });\r\n    });\r\n\r\n    describe('disconnect', () => {\r\n        beforeEach(async () => {\r\n            repository = new MongoDBRepository(mockConnectionString);\r\n        });\r\n\r\n        it('closes client when connected', async () => {\r\n            await repository.connect();\r\n            await repository.disconnect();\r\n            // Test passes if no error is thrown\r\n            expect(true).toBe(true);\r\n        });\r\n\r\n        it('handles disconnect when not connected gracefully', async () => {\r\n            await repository.disconnect();\r\n            // Test passes if no error is thrown\r\n            expect(true).toBe(true);\r\n        });\r\n\r\n        it('resets internal state after disconnect', async () => {\r\n            const { MongoClient } = await import('mongodb');\r\n            await repository.connect();\r\n            const callsAfterFirst = (MongoClient as any).mock.calls.length;\r\n            \r\n            await repository.disconnect();\r\n            await repository.connect();\r\n            \r\n            expect((MongoClient as any).mock.calls.length).toBe(callsAfterFirst + 1);\r\n        });\r\n    });\r\n\r\n    describe('fetch', () => {\r\n        beforeEach(async () => {\r\n            repository = new MongoDBRepository(mockConnectionString);\r\n        });\r\n\r\n        it('automatically connects if not already connected', async () => {\r\n            const { MongoClient } = await import('mongodb');\r\n            const callsBefore = (MongoClient as any).mock.calls.length;\r\n\r\n            await repository.fetch('testCollection');\r\n\r\n            expect((MongoClient as any).mock.calls.length).toBeGreaterThan(callsBefore);\r\n        });\r\n\r\n        it('fetches all documents with empty query', async () => {\r\n            await repository.connect();\r\n\r\n            const result = await repository.fetch('testCollection');\r\n\r\n            expect(Array.isArray(result)).toBe(true);\r\n        });\r\n\r\n        it('fetches documents with query filter', async () => {\r\n            await repository.connect();\r\n            const query = { status: 'active' };\r\n\r\n            const result = await repository.fetch('testCollection', query);\r\n\r\n            expect(Array.isArray(result)).toBe(true);\r\n        });\r\n\r\n        it('applies limit option when provided', async () => {\r\n            await repository.connect();\r\n\r\n            const result = await repository.fetch('testCollection', {}, { limit: 10 });\r\n\r\n            expect(Array.isArray(result)).toBe(true);\r\n        });\r\n\r\n        it('applies skip option when provided', async () => {\r\n            await repository.connect();\r\n\r\n            const result = await repository.fetch('testCollection', {}, { skip: 5 });\r\n\r\n            expect(Array.isArray(result)).toBe(true);\r\n        });\r\n\r\n        it('applies both skip and limit options', async () => {\r\n            await repository.connect();\r\n\r\n            const result = await repository.fetch('testCollection', {}, { skip: 10, limit: 20 });\r\n\r\n            expect(Array.isArray(result)).toBe(true);\r\n        });\r\n\r\n        it('does not apply skip when value is 0', async () => {\r\n            await repository.connect();\r\n\r\n            const result = await repository.fetch('testCollection', {}, { skip: 0, limit: 10 });\r\n\r\n            expect(Array.isArray(result)).toBe(true);\r\n        });\r\n\r\n        it('handles empty result set', async () => {\r\n            await repository.connect();\r\n\r\n            const result = await repository.fetch('emptyCollection');\r\n\r\n            expect(result).toEqual([]);\r\n        });\r\n\r\n        it('preserves document type information', async () => {\r\n            await repository.connect();\r\n            interface TestDoc {\r\n                _id: string;\r\n                name: string;\r\n                count: number;\r\n            }\r\n\r\n            const result = await repository.fetch<TestDoc>('testCollection');\r\n\r\n            expect(Array.isArray(result)).toBe(true);\r\n        });\r\n\r\n        it('throws error when database connection fails', async () => {\r\n            const badRepo = new MongoDBRepository('mongodb://invalid:27017');\r\n            // Since we're mocking, this will actually succeed, just testing the flow\r\n            await expect(badRepo.fetch('test')).resolves.toBeDefined();\r\n        });\r\n\r\n        it('throws error when db is null after connection attempt', async () => {\r\n            repository = new MongoDBRepository(mockConnectionString);\r\n            await repository.connect();\r\n            \r\n            // Force db to be null to simulate connection failure scenario\r\n            (repository as any).db = null;\r\n            \r\n            await expect(repository.fetch('testCollection')).rejects.toThrow(\r\n                'Database connection is not established'\r\n            );\r\n        });\r\n    });\r\n\r\n    describe('connection state management', () => {\r\n        it('maintains connection across multiple fetch operations', async () => {\r\n            repository = new MongoDBRepository(mockConnectionString);\r\n            const { MongoClient } = await import('mongodb');\r\n            const callsBefore = (MongoClient as any).mock.calls.length;\r\n\r\n            await repository.fetch('collection1');\r\n            await repository.fetch('collection2');\r\n            await repository.fetch('collection3');\r\n\r\n            // Should only create one new MongoClient instance\r\n            expect((MongoClient as any).mock.calls.length).toBe(callsBefore + 1);\r\n        });\r\n\r\n        it('requires new connection after disconnect', async () => {\r\n            repository = new MongoDBRepository(mockConnectionString);\r\n            const { MongoClient } = await import('mongodb');\r\n            const callsBefore = (MongoClient as any).mock.calls.length;\r\n\r\n            await repository.fetch('collection1');\r\n            await repository.fetch('collection2');\r\n            await repository.fetch('collection3');\r\n\r\n            expect((MongoClient as any).mock.calls.length).toBe(callsBefore + 1);\r\n        });\r\n\r\n        it('requires new connection after disconnect', async () => {\r\n            repository = new MongoDBRepository(mockConnectionString);\r\n            const { MongoClient } = await import('mongodb');\r\n\r\n            await repository.fetch('collection1');\r\n            const callsAfter1 = (MongoClient as any).mock.calls.length;\r\n            \r\n            await repository.disconnect();\r\n            await repository.fetch('collection2');\r\n\r\n            expect((MongoClient as any).mock.calls.length).toBe(callsAfter1 + 1);\r\n        });\r\n    });\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 26,
    "end_line": 249,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "let repository: MongoDBRepository;",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 27,
    "end_line": 27,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "const mockConnectionString = 'mongodb://test:test@localhost:27017/test';",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 28,
    "end_line": 28,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "() => {\r\n        vi.clearAllMocks();\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 30,
    "end_line": 32,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => {\r\n        vi.clearAllMocks();\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 34,
    "end_line": 36,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => {\r\n        it('throws error when connection string is not provided', () => {\r\n            expect(() => new MongoDBRepository(undefined)).toThrow('MongoDB connection string is required');\r\n        });\r\n\r\n        it('successfully creates instance with valid connection string', () => {\r\n            const repo = new MongoDBRepository(mockConnectionString);\r\n            expect(repo).toBeInstanceOf(MongoDBRepository);\r\n        });\r\n\r\n        it('stores connection string internally', () => {\r\n            const repo = new MongoDBRepository(mockConnectionString);\r\n            expect(repo).toBeDefined();\r\n        });\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 38,
    "end_line": 52,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => {\r\n            expect(() => new MongoDBRepository(undefined)).toThrow('MongoDB connection string is required');\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 39,
    "end_line": 41,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => new MongoDBRepository(undefined)",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 40,
    "end_line": 40,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => {\r\n            const repo = new MongoDBRepository(mockConnectionString);\r\n            expect(repo).toBeInstanceOf(MongoDBRepository);\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 43,
    "end_line": 46,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const repo = new MongoDBRepository(mockConnectionString);",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 44,
    "end_line": 44,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "() => {\r\n            const repo = new MongoDBRepository(mockConnectionString);\r\n            expect(repo).toBeDefined();\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 48,
    "end_line": 51,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const repo = new MongoDBRepository(mockConnectionString);",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 49,
    "end_line": 49,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "() => {\r\n        beforeEach(() => {\r\n            repository = new MongoDBRepository(mockConnectionString);\r\n        });\r\n\r\n        it('establishes connection on first call', async () => {\r\n            await repository.connect();\r\n\r\n            const { MongoClient } = await import('mongodb');\r\n            expect(MongoClient).toHaveBeenCalledWith(mockConnectionString);\r\n        });\r\n\r\n        it('does not reconnect when already connected', async () => {\r\n            const { MongoClient } = await import('mongodb');\r\n            const callsBefore = (MongoClient as any).mock.calls.length;\r\n            \r\n            await repository.connect();\r\n            await repository.connect();\r\n\r\n            expect((MongoClient as any).mock.calls.length).toBe(callsBefore + 1);\r\n        });\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 54,
    "end_line": 75,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => {\r\n            repository = new MongoDBRepository(mockConnectionString);\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 55,
    "end_line": 57,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "async () => {\r\n            await repository.connect();\r\n\r\n            const { MongoClient } = await import('mongodb');\r\n            expect(MongoClient).toHaveBeenCalledWith(mockConnectionString);\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 59,
    "end_line": 64,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const { MongoClient } = await import('mongodb');",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 62,
    "end_line": 62,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "async () => {\r\n            const { MongoClient } = await import('mongodb');\r\n            const callsBefore = (MongoClient as any).mock.calls.length;\r\n            \r\n            await repository.connect();\r\n            await repository.connect();\r\n\r\n            expect((MongoClient as any).mock.calls.length).toBe(callsBefore + 1);\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 66,
    "end_line": 74,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const { MongoClient } = await import('mongodb');",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 67,
    "end_line": 67,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "const callsBefore = (MongoClient as any).mock.calls.length;",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 68,
    "end_line": 68,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "() => {\r\n        beforeEach(async () => {\r\n            repository = new MongoDBRepository(mockConnectionString);\r\n        });\r\n\r\n        it('closes client when connected', async () => {\r\n            await repository.connect();\r\n            await repository.disconnect();\r\n            // Test passes if no error is thrown\r\n            expect(true).toBe(true);\r\n        });\r\n\r\n        it('handles disconnect when not connected gracefully', async () => {\r\n            await repository.disconnect();\r\n            // Test passes if no error is thrown\r\n            expect(true).toBe(true);\r\n        });\r\n\r\n        it('resets internal state after disconnect', async () => {\r\n            const { MongoClient } = await import('mongodb');\r\n            await repository.connect();\r\n            const callsAfterFirst = (MongoClient as any).mock.calls.length;\r\n            \r\n            await repository.disconnect();\r\n            await repository.connect();\r\n            \r\n            expect((MongoClient as any).mock.calls.length).toBe(callsAfterFirst + 1);\r\n        });\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 77,
    "end_line": 105,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "async () => {\r\n            repository = new MongoDBRepository(mockConnectionString);\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 78,
    "end_line": 80,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "async () => {\r\n            await repository.connect();\r\n            await repository.disconnect();\r\n            // Test passes if no error is thrown\r\n            expect(true).toBe(true);\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 82,
    "end_line": 87,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "async () => {\r\n            await repository.disconnect();\r\n            // Test passes if no error is thrown\r\n            expect(true).toBe(true);\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 89,
    "end_line": 93,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "async () => {\r\n            const { MongoClient } = await import('mongodb');\r\n            await repository.connect();\r\n            const callsAfterFirst = (MongoClient as any).mock.calls.length;\r\n            \r\n            await repository.disconnect();\r\n            await repository.connect();\r\n            \r\n            expect((MongoClient as any).mock.calls.length).toBe(callsAfterFirst + 1);\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 95,
    "end_line": 104,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const { MongoClient } = await import('mongodb');",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 96,
    "end_line": 96,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "const callsAfterFirst = (MongoClient as any).mock.calls.length;",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 98,
    "end_line": 98,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "() => {\r\n        beforeEach(async () => {\r\n            repository = new MongoDBRepository(mockConnectionString);\r\n        });\r\n\r\n        it('automatically connects if not already connected', async () => {\r\n            const { MongoClient } = await import('mongodb');\r\n            const callsBefore = (MongoClient as any).mock.calls.length;\r\n\r\n            await repository.fetch('testCollection');\r\n\r\n            expect((MongoClient as any).mock.calls.length).toBeGreaterThan(callsBefore);\r\n        });\r\n\r\n        it('fetches all documents with empty query', async () => {\r\n            await repository.connect();\r\n\r\n            const result = await repository.fetch('testCollection');\r\n\r\n            expect(Array.isArray(result)).toBe(true);\r\n        });\r\n\r\n        it('fetches documents with query filter', async () => {\r\n            await repository.connect();\r\n            const query = { status: 'active' };\r\n\r\n            const result = await repository.fetch('testCollection', query);\r\n\r\n            expect(Array.isArray(result)).toBe(true);\r\n        });\r\n\r\n        it('applies limit option when provided', async () => {\r\n            await repository.connect();\r\n\r\n            const result = await repository.fetch('testCollection', {}, { limit: 10 });\r\n\r\n            expect(Array.isArray(result)).toBe(true);\r\n        });\r\n\r\n        it('applies skip option when provided', async () => {\r\n            await repository.connect();\r\n\r\n            const result = await repository.fetch('testCollection', {}, { skip: 5 });\r\n\r\n            expect(Array.isArray(result)).toBe(true);\r\n        });\r\n\r\n        it('applies both skip and limit options', async () => {\r\n            await repository.connect();\r\n\r\n            const result = await repository.fetch('testCollection', {}, { skip: 10, limit: 20 });\r\n\r\n            expect(Array.isArray(result)).toBe(true);\r\n        });\r\n\r\n        it('does not apply skip when value is 0', async () => {\r\n            await repository.connect();\r\n\r\n            const result = await repository.fetch('testCollection', {}, { skip: 0, limit: 10 });\r\n\r\n            expect(Array.isArray(result)).toBe(true);\r\n        });\r\n\r\n        it('handles empty result set', async () => {\r\n            await repository.connect();\r\n\r\n            const result = await repository.fetch('emptyCollection');\r\n\r\n            expect(result).toEqual([]);\r\n        });\r\n\r\n        it('preserves document type information', async () => {\r\n            await repository.connect();\r\n            interface TestDoc {\r\n                _id: string;\r\n                name: string;\r\n                count: number;\r\n            }\r\n\r\n            const result = await repository.fetch<TestDoc>('testCollection');\r\n\r\n            expect(Array.isArray(result)).toBe(true);\r\n        });\r\n\r\n        it('throws error when database connection fails', async () => {\r\n            const badRepo = new MongoDBRepository('mongodb://invalid:27017');\r\n            // Since we're mocking, this will actually succeed, just testing the flow\r\n            await expect(badRepo.fetch('test')).resolves.toBeDefined();\r\n        });\r\n\r\n        it('throws error when db is null after connection attempt', async () => {\r\n            repository = new MongoDBRepository(mockConnectionString);\r\n            await repository.connect();\r\n            \r\n            // Force db to be null to simulate connection failure scenario\r\n            (repository as any).db = null;\r\n            \r\n            await expect(repository.fetch('testCollection')).rejects.toThrow(\r\n                'Database connection is not established'\r\n            );\r\n        });\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 107,
    "end_line": 208,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "async () => {\r\n            repository = new MongoDBRepository(mockConnectionString);\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 108,
    "end_line": 110,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "async () => {\r\n            const { MongoClient } = await import('mongodb');\r\n            const callsBefore = (MongoClient as any).mock.calls.length;\r\n\r\n            await repository.fetch('testCollection');\r\n\r\n            expect((MongoClient as any).mock.calls.length).toBeGreaterThan(callsBefore);\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 112,
    "end_line": 119,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const { MongoClient } = await import('mongodb');",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 113,
    "end_line": 113,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "const callsBefore = (MongoClient as any).mock.calls.length;",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 114,
    "end_line": 114,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "async () => {\r\n            await repository.connect();\r\n\r\n            const result = await repository.fetch('testCollection');\r\n\r\n            expect(Array.isArray(result)).toBe(true);\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 121,
    "end_line": 127,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const result = await repository.fetch('testCollection');",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 124,
    "end_line": 124,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "async () => {\r\n            await repository.connect();\r\n            const query = { status: 'active' };\r\n\r\n            const result = await repository.fetch('testCollection', query);\r\n\r\n            expect(Array.isArray(result)).toBe(true);\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 129,
    "end_line": 136,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const query = { status: 'active' };",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 131,
    "end_line": 131,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "const result = await repository.fetch('testCollection', query);",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 133,
    "end_line": 133,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "async () => {\r\n            await repository.connect();\r\n\r\n            const result = await repository.fetch('testCollection', {}, { limit: 10 });\r\n\r\n            expect(Array.isArray(result)).toBe(true);\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 138,
    "end_line": 144,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const result = await repository.fetch('testCollection', {}, { limit: 10 });",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 141,
    "end_line": 141,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "async () => {\r\n            await repository.connect();\r\n\r\n            const result = await repository.fetch('testCollection', {}, { skip: 5 });\r\n\r\n            expect(Array.isArray(result)).toBe(true);\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 146,
    "end_line": 152,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const result = await repository.fetch('testCollection', {}, { skip: 5 });",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 149,
    "end_line": 149,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "async () => {\r\n            await repository.connect();\r\n\r\n            const result = await repository.fetch('testCollection', {}, { skip: 10, limit: 20 });\r\n\r\n            expect(Array.isArray(result)).toBe(true);\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 154,
    "end_line": 160,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const result = await repository.fetch('testCollection', {}, { skip: 10, limit: 20 });",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 157,
    "end_line": 157,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "async () => {\r\n            await repository.connect();\r\n\r\n            const result = await repository.fetch('testCollection', {}, { skip: 0, limit: 10 });\r\n\r\n            expect(Array.isArray(result)).toBe(true);\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 162,
    "end_line": 168,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const result = await repository.fetch('testCollection', {}, { skip: 0, limit: 10 });",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 165,
    "end_line": 165,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "async () => {\r\n            await repository.connect();\r\n\r\n            const result = await repository.fetch('emptyCollection');\r\n\r\n            expect(result).toEqual([]);\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 170,
    "end_line": 176,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const result = await repository.fetch('emptyCollection');",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 173,
    "end_line": 173,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "async () => {\r\n            await repository.connect();\r\n            interface TestDoc {\r\n                _id: string;\r\n                name: string;\r\n                count: number;\r\n            }\r\n\r\n            const result = await repository.fetch<TestDoc>('testCollection');\r\n\r\n            expect(Array.isArray(result)).toBe(true);\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 178,
    "end_line": 189,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "interface TestDoc {\r\n                _id: string;\r\n                name: string;\r\n                count: number;\r\n            }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "TestDoc",
    "start_line": 180,
    "end_line": 184,
    "language": "typescript",
    "chunk_type": "interface"
  },
  {
    "content": "const result = await repository.fetch<TestDoc>('testCollection');",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 186,
    "end_line": 186,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "async () => {\r\n            const badRepo = new MongoDBRepository('mongodb://invalid:27017');\r\n            // Since we're mocking, this will actually succeed, just testing the flow\r\n            await expect(badRepo.fetch('test')).resolves.toBeDefined();\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 191,
    "end_line": 195,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const badRepo = new MongoDBRepository('mongodb://invalid:27017');",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 192,
    "end_line": 192,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "async () => {\r\n            repository = new MongoDBRepository(mockConnectionString);\r\n            await repository.connect();\r\n            \r\n            // Force db to be null to simulate connection failure scenario\r\n            (repository as any).db = null;\r\n            \r\n            await expect(repository.fetch('testCollection')).rejects.toThrow(\r\n                'Database connection is not established'\r\n            );\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 197,
    "end_line": 207,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => {\r\n        it('maintains connection across multiple fetch operations', async () => {\r\n            repository = new MongoDBRepository(mockConnectionString);\r\n            const { MongoClient } = await import('mongodb');\r\n            const callsBefore = (MongoClient as any).mock.calls.length;\r\n\r\n            await repository.fetch('collection1');\r\n            await repository.fetch('collection2');\r\n            await repository.fetch('collection3');\r\n\r\n            // Should only create one new MongoClient instance\r\n            expect((MongoClient as any).mock.calls.length).toBe(callsBefore + 1);\r\n        });\r\n\r\n        it('requires new connection after disconnect', async () => {\r\n            repository = new MongoDBRepository(mockConnectionString);\r\n            const { MongoClient } = await import('mongodb');\r\n            const callsBefore = (MongoClient as any).mock.calls.length;\r\n\r\n            await repository.fetch('collection1');\r\n            await repository.fetch('collection2');\r\n            await repository.fetch('collection3');\r\n\r\n            expect((MongoClient as any).mock.calls.length).toBe(callsBefore + 1);\r\n        });\r\n\r\n        it('requires new connection after disconnect', async () => {\r\n            repository = new MongoDBRepository(mockConnectionString);\r\n            const { MongoClient } = await import('mongodb');\r\n\r\n            await repository.fetch('collection1');\r\n            const callsAfter1 = (MongoClient as any).mock.calls.length;\r\n            \r\n            await repository.disconnect();\r\n            await repository.fetch('collection2');\r\n\r\n            expect((MongoClient as any).mock.calls.length).toBe(callsAfter1 + 1);\r\n        });\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 210,
    "end_line": 248,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "async () => {\r\n            repository = new MongoDBRepository(mockConnectionString);\r\n            const { MongoClient } = await import('mongodb');\r\n            const callsBefore = (MongoClient as any).mock.calls.length;\r\n\r\n            await repository.fetch('collection1');\r\n            await repository.fetch('collection2');\r\n            await repository.fetch('collection3');\r\n\r\n            // Should only create one new MongoClient instance\r\n            expect((MongoClient as any).mock.calls.length).toBe(callsBefore + 1);\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 211,
    "end_line": 222,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const { MongoClient } = await import('mongodb');",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 213,
    "end_line": 213,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "const callsBefore = (MongoClient as any).mock.calls.length;",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 214,
    "end_line": 214,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "async () => {\r\n            repository = new MongoDBRepository(mockConnectionString);\r\n            const { MongoClient } = await import('mongodb');\r\n            const callsBefore = (MongoClient as any).mock.calls.length;\r\n\r\n            await repository.fetch('collection1');\r\n            await repository.fetch('collection2');\r\n            await repository.fetch('collection3');\r\n\r\n            expect((MongoClient as any).mock.calls.length).toBe(callsBefore + 1);\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 224,
    "end_line": 234,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const { MongoClient } = await import('mongodb');",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 226,
    "end_line": 226,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "const callsBefore = (MongoClient as any).mock.calls.length;",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 227,
    "end_line": 227,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "async () => {\r\n            repository = new MongoDBRepository(mockConnectionString);\r\n            const { MongoClient } = await import('mongodb');\r\n\r\n            await repository.fetch('collection1');\r\n            const callsAfter1 = (MongoClient as any).mock.calls.length;\r\n            \r\n            await repository.disconnect();\r\n            await repository.fetch('collection2');\r\n\r\n            expect((MongoClient as any).mock.calls.length).toBe(callsAfter1 + 1);\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 236,
    "end_line": 247,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const { MongoClient } = await import('mongodb');",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 238,
    "end_line": 238,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "const callsAfter1 = (MongoClient as any).mock.calls.length;",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.test.ts",
    "function_name": "anonymous",
    "start_line": 241,
    "end_line": 241,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "class MongoDBRepository {\r\n    private readonly MODULE = \"MongoDBRepository\";\r\n    private client: MongoClient | null = null;\r\n    private db: Db | null = null;\r\n    private connectionString: string;\r\n\r\n    constructor(connectionString?: string) {\r\n        if (!connectionString) {\r\n            throw new Error(\"MongoDB connection string is required\");\r\n        }\r\n        this.connectionString = connectionString;\r\n    }\r\n\r\n    private isConnectionOpen(): boolean {\r\n        return this.client !== null && this.db !== null;\r\n    }\r\n\r\n    private async ensureConnection(): Promise<void> {\r\n        if (!this.isConnectionOpen()) {\r\n            logInfo(\"Establishing MongoDB connection\", {}, this.MODULE);\r\n            await this.connect();\r\n        }\r\n    }\r\n\r\n    async connect(): Promise<void> {\r\n        if (this.client) {\r\n            return;\r\n        }\r\n        this.client = new MongoClient(this.connectionString);\r\n        await this.client.connect();\r\n        this.db = this.client.db();\r\n    }\r\n\r\n    async disconnect(): Promise<void> {\r\n        if (this.client) {\r\n            await this.client.close();\r\n            this.client = null;\r\n            this.db = null;\r\n        }\r\n    }\r\n\r\n    async fetch<T extends Document>(\r\n        collection: string,\r\n        query: Filter<T> = {},\r\n        options?: { limit?: number; skip?: number }\r\n    ): Promise<T[]> {\r\n        await this.ensureConnection();\r\n        if (!this.db) {\r\n            throw new Error(\"Database connection is not established\");\r\n        }\r\n        logInfo(\"Fetching data from MongoDB\", { collection, query, options }, this.MODULE);\r\n        let cursor = this.db.collection<T>(collection).find(query);\r\n        \r\n        if (options?.skip) {\r\n            cursor = cursor.skip(options.skip);\r\n        }\r\n        if (options?.limit) {\r\n            cursor = cursor.limit(options.limit);\r\n        }\r\n        \r\n        return await cursor.toArray() as T[];\r\n    }\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.ts",
    "function_name": "MongoDBRepository",
    "start_line": 4,
    "end_line": 66,
    "language": "typescript",
    "chunk_type": "class"
  },
  {
    "content": "constructor(connectionString?: string) {\r\n        if (!connectionString) {\r\n            throw new Error(\"MongoDB connection string is required\");\r\n        }\r\n        this.connectionString = connectionString;\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.ts",
    "function_name": "anonymous",
    "start_line": 10,
    "end_line": 15,
    "language": "typescript",
    "chunk_type": "method"
  },
  {
    "content": "private isConnectionOpen(): boolean {\r\n        return this.client !== null && this.db !== null;\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.ts",
    "function_name": "anonymous",
    "start_line": 17,
    "end_line": 19,
    "language": "typescript",
    "chunk_type": "method"
  },
  {
    "content": "private async ensureConnection(): Promise<void> {\r\n        if (!this.isConnectionOpen()) {\r\n            logInfo(\"Establishing MongoDB connection\", {}, this.MODULE);\r\n            await this.connect();\r\n        }\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.ts",
    "function_name": "anonymous",
    "start_line": 21,
    "end_line": 26,
    "language": "typescript",
    "chunk_type": "method"
  },
  {
    "content": "async connect(): Promise<void> {\r\n        if (this.client) {\r\n            return;\r\n        }\r\n        this.client = new MongoClient(this.connectionString);\r\n        await this.client.connect();\r\n        this.db = this.client.db();\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.ts",
    "function_name": "anonymous",
    "start_line": 28,
    "end_line": 35,
    "language": "typescript",
    "chunk_type": "method"
  },
  {
    "content": "async disconnect(): Promise<void> {\r\n        if (this.client) {\r\n            await this.client.close();\r\n            this.client = null;\r\n            this.db = null;\r\n        }\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.ts",
    "function_name": "anonymous",
    "start_line": 37,
    "end_line": 43,
    "language": "typescript",
    "chunk_type": "method"
  },
  {
    "content": "async fetch<T extends Document>(\r\n        collection: string,\r\n        query: Filter<T> = {},\r\n        options?: { limit?: number; skip?: number }\r\n    ): Promise<T[]> {\r\n        await this.ensureConnection();\r\n        if (!this.db) {\r\n            throw new Error(\"Database connection is not established\");\r\n        }\r\n        logInfo(\"Fetching data from MongoDB\", { collection, query, options }, this.MODULE);\r\n        let cursor = this.db.collection<T>(collection).find(query);\r\n        \r\n        if (options?.skip) {\r\n            cursor = cursor.skip(options.skip);\r\n        }\r\n        if (options?.limit) {\r\n            cursor = cursor.limit(options.limit);\r\n        }\r\n        \r\n        return await cursor.toArray() as T[];\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.ts",
    "function_name": "anonymous",
    "start_line": 45,
    "end_line": 65,
    "language": "typescript",
    "chunk_type": "method"
  },
  {
    "content": "let cursor = this.db.collection<T>(collection).find(query);",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\repositories\\MongoDBRepository.ts",
    "function_name": "anonymous",
    "start_line": 55,
    "end_line": 55,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "() => {\r\n    let cache: ICacheService;\r\n\r\n    beforeEach(() => {\r\n        vi.useFakeTimers();\r\n        vi.setSystemTime(new Date('2026-01-01T00:00:00.000Z'));\r\n        cache = cacheServiceFactory({ maxEntries: 3, defaultTtlSeconds: 60 });\r\n        cache.clear();\r\n    });\r\n\r\n    afterEach(() => {\r\n        vi.useRealTimers();\r\n    });\r\n\r\n    describe('buildCacheKey', () => {\r\n        it('formats single param correctly', () => {\r\n            const key = cache.buildCacheKey('meets', { take: 20 });\r\n            expect(key).toBe('meets:take:20');\r\n        });\r\n\r\n        it('formats multiple params with pipe delimiter', () => {\r\n            const key = cache.buildCacheKey('meets', { take: 20, skip: 10 });\r\n            expect(key).toBe('meets:take:20|skip:10');\r\n        });\r\n\r\n        it('handles empty params object', () => {\r\n            const key = cache.buildCacheKey('meets', {});\r\n            expect(key).toBe('meets:');\r\n        });\r\n    });\r\n\r\n    describe('get', () => {\r\n        it('returns null for non-existent key', () => {\r\n            expect(cache.get('nonexistent')).toBeNull();\r\n        });\r\n\r\n        it('returns null and removes entry when expired', () => {\r\n            cache.set('key1', 'value1', 60);\r\n            vi.advanceTimersByTime(61 * 1000); // Advance past TTL\r\n            \r\n            expect(cache.get('key1')).toBeNull();\r\n            expect(cache.stats().size).toBe(0);\r\n        });\r\n\r\n        it('returns data for valid non-expired entry', () => {\r\n            cache.set('key1', { id: 1, name: 'test' });\r\n            expect(cache.get('key1')).toEqual({ id: 1, name: 'test' });\r\n        });\r\n\r\n        it('promotes accessed entry to most recent (LRU)', () => {\r\n            cache.set('key1', 'first');\r\n            cache.set('key2', 'second');\r\n            cache.get('key1'); // Access key1, moves it to end\r\n            cache.set('key3', 'third');\r\n            cache.set('key4', 'fourth'); // Should evict key2 (oldest after key1 moved)\r\n\r\n            expect(cache.get('key1')).toBe('first');\r\n            expect(cache.get('key2')).toBeNull();\r\n        });\r\n    });\r\n\r\n    describe('set', () => {\r\n        it('stores and retrieves typed data correctly', () => {\r\n            cache.set<number[]>('numbers', [1, 2, 3]);\r\n            expect(cache.get<number[]>('numbers')).toEqual([1, 2, 3]);\r\n        });\r\n\r\n        it('uses default TTL when not specified', () => {\r\n            cache.set('key1', 'value1'); // Uses 60s default from beforeEach\r\n            vi.advanceTimersByTime(59 * 1000);\r\n            expect(cache.get('key1')).toBe('value1');\r\n            \r\n            vi.advanceTimersByTime(2 * 1000);\r\n            expect(cache.get('key1')).toBeNull();\r\n        });\r\n\r\n        it('uses custom TTL when specified', () => {\r\n            cache.set('key1', 'value1', 10);\r\n            vi.advanceTimersByTime(9 * 1000);\r\n            expect(cache.get('key1')).toBe('value1');\r\n            \r\n            vi.advanceTimersByTime(2 * 1000);\r\n            expect(cache.get('key1')).toBeNull();\r\n        });\r\n\r\n        it('evicts oldest entry when at max capacity', () => {\r\n            cache.set('key1', 'first');\r\n            cache.set('key2', 'second');\r\n            cache.set('key3', 'third');\r\n            cache.set('key4', 'fourth'); // Should evict key1\r\n\r\n            expect(cache.get('key1')).toBeNull();\r\n            expect(cache.get('key4')).toBe('fourth');\r\n            expect(cache.stats().size).toBe(3);\r\n        });\r\n\r\n        it('evicts multiple entries when adding to empty cache at capacity', () => {\r\n            cache.set('key1', 'first');\r\n            cache.set('key2', 'second');\r\n            cache.set('key3', 'third');\r\n            cache.clear();\r\n            \r\n            // Now cache is empty but maxEntries is still 3\r\n            // This triggers the while loop with an initially empty cache\r\n            cache.set('new1', 'value');\r\n            expect(cache.get('new1')).toBe('value');\r\n        });\r\n\r\n        it('updates existing key without increasing size', () => {\r\n            cache.set('key1', 'original');\r\n            cache.set('key1', 'updated');\r\n\r\n            expect(cache.get('key1')).toBe('updated');\r\n            expect(cache.stats().size).toBe(1);\r\n        });\r\n    });\r\n\r\n    describe('delete', () => {\r\n        it('removes existing entry', () => {\r\n            cache.set('key1', 'value1');\r\n            cache.delete('key1');\r\n            expect(cache.get('key1')).toBeNull();\r\n        });\r\n\r\n        it('handles deletion of non-existent key gracefully', () => {\r\n            expect(() => cache.delete('nonexistent')).not.toThrow();\r\n        });\r\n    });\r\n\r\n    describe('clear', () => {\r\n        it('removes all entries', () => {\r\n            cache.set('key1', 'value1');\r\n            cache.set('key2', 'value2');\r\n            cache.clear();\r\n\r\n            expect(cache.stats().size).toBe(0);\r\n            expect(cache.get('key1')).toBeNull();\r\n        });\r\n    });\r\n\r\n    describe('prune', () => {\r\n        it('removes only expired entries and returns count', () => {\r\n            cache.set('expires-soon', 'value1', 30);\r\n            cache.set('expires-later', 'value2', 120);\r\n            \r\n            vi.advanceTimersByTime(31 * 1000);\r\n            const pruned = cache.prune();\r\n\r\n            expect(pruned).toBe(1);\r\n            expect(cache.get('expires-soon')).toBeNull();\r\n            expect(cache.get('expires-later')).toBe('value2');\r\n        });\r\n\r\n        it('returns zero when no entries expired', () => {\r\n            cache.set('key1', 'value1', 300);\r\n            expect(cache.prune()).toBe(0);\r\n        });\r\n    });\r\n\r\n    describe('stats', () => {\r\n        it('returns current size and configured max entries', () => {\r\n            cache.set('key1', 'value1');\r\n            cache.set('key2', 'value2');\r\n\r\n            const stats = cache.stats();\r\n            expect(stats.size).toBe(2);\r\n            expect(stats.maxEntries).toBe(3);\r\n        });\r\n    });\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.test.ts",
    "function_name": "anonymous",
    "start_line": 4,
    "end_line": 173,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "let cache: ICacheService;",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.test.ts",
    "function_name": "anonymous",
    "start_line": 5,
    "end_line": 5,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "() => {\r\n        vi.useFakeTimers();\r\n        vi.setSystemTime(new Date('2026-01-01T00:00:00.000Z'));\r\n        cache = cacheServiceFactory({ maxEntries: 3, defaultTtlSeconds: 60 });\r\n        cache.clear();\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.test.ts",
    "function_name": "anonymous",
    "start_line": 7,
    "end_line": 12,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => {\r\n        vi.useRealTimers();\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.test.ts",
    "function_name": "anonymous",
    "start_line": 14,
    "end_line": 16,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => {\r\n        it('formats single param correctly', () => {\r\n            const key = cache.buildCacheKey('meets', { take: 20 });\r\n            expect(key).toBe('meets:take:20');\r\n        });\r\n\r\n        it('formats multiple params with pipe delimiter', () => {\r\n            const key = cache.buildCacheKey('meets', { take: 20, skip: 10 });\r\n            expect(key).toBe('meets:take:20|skip:10');\r\n        });\r\n\r\n        it('handles empty params object', () => {\r\n            const key = cache.buildCacheKey('meets', {});\r\n            expect(key).toBe('meets:');\r\n        });\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.test.ts",
    "function_name": "anonymous",
    "start_line": 18,
    "end_line": 33,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => {\r\n            const key = cache.buildCacheKey('meets', { take: 20 });\r\n            expect(key).toBe('meets:take:20');\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.test.ts",
    "function_name": "anonymous",
    "start_line": 19,
    "end_line": 22,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const key = cache.buildCacheKey('meets', { take: 20 });",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.test.ts",
    "function_name": "anonymous",
    "start_line": 20,
    "end_line": 20,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "() => {\r\n            const key = cache.buildCacheKey('meets', { take: 20, skip: 10 });\r\n            expect(key).toBe('meets:take:20|skip:10');\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.test.ts",
    "function_name": "anonymous",
    "start_line": 24,
    "end_line": 27,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const key = cache.buildCacheKey('meets', { take: 20, skip: 10 });",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.test.ts",
    "function_name": "anonymous",
    "start_line": 25,
    "end_line": 25,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "() => {\r\n            const key = cache.buildCacheKey('meets', {});\r\n            expect(key).toBe('meets:');\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.test.ts",
    "function_name": "anonymous",
    "start_line": 29,
    "end_line": 32,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const key = cache.buildCacheKey('meets', {});",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.test.ts",
    "function_name": "anonymous",
    "start_line": 30,
    "end_line": 30,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "() => {\r\n        it('returns null for non-existent key', () => {\r\n            expect(cache.get('nonexistent')).toBeNull();\r\n        });\r\n\r\n        it('returns null and removes entry when expired', () => {\r\n            cache.set('key1', 'value1', 60);\r\n            vi.advanceTimersByTime(61 * 1000); // Advance past TTL\r\n            \r\n            expect(cache.get('key1')).toBeNull();\r\n            expect(cache.stats().size).toBe(0);\r\n        });\r\n\r\n        it('returns data for valid non-expired entry', () => {\r\n            cache.set('key1', { id: 1, name: 'test' });\r\n            expect(cache.get('key1')).toEqual({ id: 1, name: 'test' });\r\n        });\r\n\r\n        it('promotes accessed entry to most recent (LRU)', () => {\r\n            cache.set('key1', 'first');\r\n            cache.set('key2', 'second');\r\n            cache.get('key1'); // Access key1, moves it to end\r\n            cache.set('key3', 'third');\r\n            cache.set('key4', 'fourth'); // Should evict key2 (oldest after key1 moved)\r\n\r\n            expect(cache.get('key1')).toBe('first');\r\n            expect(cache.get('key2')).toBeNull();\r\n        });\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.test.ts",
    "function_name": "anonymous",
    "start_line": 35,
    "end_line": 63,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => {\r\n            expect(cache.get('nonexistent')).toBeNull();\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.test.ts",
    "function_name": "anonymous",
    "start_line": 36,
    "end_line": 38,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => {\r\n            cache.set('key1', 'value1', 60);\r\n            vi.advanceTimersByTime(61 * 1000); // Advance past TTL\r\n            \r\n            expect(cache.get('key1')).toBeNull();\r\n            expect(cache.stats().size).toBe(0);\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.test.ts",
    "function_name": "anonymous",
    "start_line": 40,
    "end_line": 46,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => {\r\n            cache.set('key1', { id: 1, name: 'test' });\r\n            expect(cache.get('key1')).toEqual({ id: 1, name: 'test' });\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.test.ts",
    "function_name": "anonymous",
    "start_line": 48,
    "end_line": 51,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => {\r\n            cache.set('key1', 'first');\r\n            cache.set('key2', 'second');\r\n            cache.get('key1'); // Access key1, moves it to end\r\n            cache.set('key3', 'third');\r\n            cache.set('key4', 'fourth'); // Should evict key2 (oldest after key1 moved)\r\n\r\n            expect(cache.get('key1')).toBe('first');\r\n            expect(cache.get('key2')).toBeNull();\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.test.ts",
    "function_name": "anonymous",
    "start_line": 53,
    "end_line": 62,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => {\r\n        it('stores and retrieves typed data correctly', () => {\r\n            cache.set<number[]>('numbers', [1, 2, 3]);\r\n            expect(cache.get<number[]>('numbers')).toEqual([1, 2, 3]);\r\n        });\r\n\r\n        it('uses default TTL when not specified', () => {\r\n            cache.set('key1', 'value1'); // Uses 60s default from beforeEach\r\n            vi.advanceTimersByTime(59 * 1000);\r\n            expect(cache.get('key1')).toBe('value1');\r\n            \r\n            vi.advanceTimersByTime(2 * 1000);\r\n            expect(cache.get('key1')).toBeNull();\r\n        });\r\n\r\n        it('uses custom TTL when specified', () => {\r\n            cache.set('key1', 'value1', 10);\r\n            vi.advanceTimersByTime(9 * 1000);\r\n            expect(cache.get('key1')).toBe('value1');\r\n            \r\n            vi.advanceTimersByTime(2 * 1000);\r\n            expect(cache.get('key1')).toBeNull();\r\n        });\r\n\r\n        it('evicts oldest entry when at max capacity', () => {\r\n            cache.set('key1', 'first');\r\n            cache.set('key2', 'second');\r\n            cache.set('key3', 'third');\r\n            cache.set('key4', 'fourth'); // Should evict key1\r\n\r\n            expect(cache.get('key1')).toBeNull();\r\n            expect(cache.get('key4')).toBe('fourth');\r\n            expect(cache.stats().size).toBe(3);\r\n        });\r\n\r\n        it('evicts multiple entries when adding to empty cache at capacity', () => {\r\n            cache.set('key1', 'first');\r\n            cache.set('key2', 'second');\r\n            cache.set('key3', 'third');\r\n            cache.clear();\r\n            \r\n            // Now cache is empty but maxEntries is still 3\r\n            // This triggers the while loop with an initially empty cache\r\n            cache.set('new1', 'value');\r\n            expect(cache.get('new1')).toBe('value');\r\n        });\r\n\r\n        it('updates existing key without increasing size', () => {\r\n            cache.set('key1', 'original');\r\n            cache.set('key1', 'updated');\r\n\r\n            expect(cache.get('key1')).toBe('updated');\r\n            expect(cache.stats().size).toBe(1);\r\n        });\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.test.ts",
    "function_name": "anonymous",
    "start_line": 65,
    "end_line": 119,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => {\r\n            cache.set<number[]>('numbers', [1, 2, 3]);\r\n            expect(cache.get<number[]>('numbers')).toEqual([1, 2, 3]);\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.test.ts",
    "function_name": "anonymous",
    "start_line": 66,
    "end_line": 69,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => {\r\n            cache.set('key1', 'value1'); // Uses 60s default from beforeEach\r\n            vi.advanceTimersByTime(59 * 1000);\r\n            expect(cache.get('key1')).toBe('value1');\r\n            \r\n            vi.advanceTimersByTime(2 * 1000);\r\n            expect(cache.get('key1')).toBeNull();\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.test.ts",
    "function_name": "anonymous",
    "start_line": 71,
    "end_line": 78,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => {\r\n            cache.set('key1', 'value1', 10);\r\n            vi.advanceTimersByTime(9 * 1000);\r\n            expect(cache.get('key1')).toBe('value1');\r\n            \r\n            vi.advanceTimersByTime(2 * 1000);\r\n            expect(cache.get('key1')).toBeNull();\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.test.ts",
    "function_name": "anonymous",
    "start_line": 80,
    "end_line": 87,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => {\r\n            cache.set('key1', 'first');\r\n            cache.set('key2', 'second');\r\n            cache.set('key3', 'third');\r\n            cache.set('key4', 'fourth'); // Should evict key1\r\n\r\n            expect(cache.get('key1')).toBeNull();\r\n            expect(cache.get('key4')).toBe('fourth');\r\n            expect(cache.stats().size).toBe(3);\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.test.ts",
    "function_name": "anonymous",
    "start_line": 89,
    "end_line": 98,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => {\r\n            cache.set('key1', 'first');\r\n            cache.set('key2', 'second');\r\n            cache.set('key3', 'third');\r\n            cache.clear();\r\n            \r\n            // Now cache is empty but maxEntries is still 3\r\n            // This triggers the while loop with an initially empty cache\r\n            cache.set('new1', 'value');\r\n            expect(cache.get('new1')).toBe('value');\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.test.ts",
    "function_name": "anonymous",
    "start_line": 100,
    "end_line": 110,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => {\r\n            cache.set('key1', 'original');\r\n            cache.set('key1', 'updated');\r\n\r\n            expect(cache.get('key1')).toBe('updated');\r\n            expect(cache.stats().size).toBe(1);\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.test.ts",
    "function_name": "anonymous",
    "start_line": 112,
    "end_line": 118,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => {\r\n        it('removes existing entry', () => {\r\n            cache.set('key1', 'value1');\r\n            cache.delete('key1');\r\n            expect(cache.get('key1')).toBeNull();\r\n        });\r\n\r\n        it('handles deletion of non-existent key gracefully', () => {\r\n            expect(() => cache.delete('nonexistent')).not.toThrow();\r\n        });\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.test.ts",
    "function_name": "anonymous",
    "start_line": 121,
    "end_line": 131,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => {\r\n            cache.set('key1', 'value1');\r\n            cache.delete('key1');\r\n            expect(cache.get('key1')).toBeNull();\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.test.ts",
    "function_name": "anonymous",
    "start_line": 122,
    "end_line": 126,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => {\r\n            expect(() => cache.delete('nonexistent')).not.toThrow();\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.test.ts",
    "function_name": "anonymous",
    "start_line": 128,
    "end_line": 130,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => cache.delete('nonexistent')",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.test.ts",
    "function_name": "anonymous",
    "start_line": 129,
    "end_line": 129,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => {\r\n        it('removes all entries', () => {\r\n            cache.set('key1', 'value1');\r\n            cache.set('key2', 'value2');\r\n            cache.clear();\r\n\r\n            expect(cache.stats().size).toBe(0);\r\n            expect(cache.get('key1')).toBeNull();\r\n        });\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.test.ts",
    "function_name": "anonymous",
    "start_line": 133,
    "end_line": 142,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => {\r\n            cache.set('key1', 'value1');\r\n            cache.set('key2', 'value2');\r\n            cache.clear();\r\n\r\n            expect(cache.stats().size).toBe(0);\r\n            expect(cache.get('key1')).toBeNull();\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.test.ts",
    "function_name": "anonymous",
    "start_line": 134,
    "end_line": 141,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => {\r\n        it('removes only expired entries and returns count', () => {\r\n            cache.set('expires-soon', 'value1', 30);\r\n            cache.set('expires-later', 'value2', 120);\r\n            \r\n            vi.advanceTimersByTime(31 * 1000);\r\n            const pruned = cache.prune();\r\n\r\n            expect(pruned).toBe(1);\r\n            expect(cache.get('expires-soon')).toBeNull();\r\n            expect(cache.get('expires-later')).toBe('value2');\r\n        });\r\n\r\n        it('returns zero when no entries expired', () => {\r\n            cache.set('key1', 'value1', 300);\r\n            expect(cache.prune()).toBe(0);\r\n        });\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.test.ts",
    "function_name": "anonymous",
    "start_line": 144,
    "end_line": 161,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => {\r\n            cache.set('expires-soon', 'value1', 30);\r\n            cache.set('expires-later', 'value2', 120);\r\n            \r\n            vi.advanceTimersByTime(31 * 1000);\r\n            const pruned = cache.prune();\r\n\r\n            expect(pruned).toBe(1);\r\n            expect(cache.get('expires-soon')).toBeNull();\r\n            expect(cache.get('expires-later')).toBe('value2');\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.test.ts",
    "function_name": "anonymous",
    "start_line": 145,
    "end_line": 155,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const pruned = cache.prune();",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.test.ts",
    "function_name": "anonymous",
    "start_line": 150,
    "end_line": 150,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "() => {\r\n            cache.set('key1', 'value1', 300);\r\n            expect(cache.prune()).toBe(0);\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.test.ts",
    "function_name": "anonymous",
    "start_line": 157,
    "end_line": 160,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => {\r\n        it('returns current size and configured max entries', () => {\r\n            cache.set('key1', 'value1');\r\n            cache.set('key2', 'value2');\r\n\r\n            const stats = cache.stats();\r\n            expect(stats.size).toBe(2);\r\n            expect(stats.maxEntries).toBe(3);\r\n        });\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.test.ts",
    "function_name": "anonymous",
    "start_line": 163,
    "end_line": 172,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => {\r\n            cache.set('key1', 'value1');\r\n            cache.set('key2', 'value2');\r\n\r\n            const stats = cache.stats();\r\n            expect(stats.size).toBe(2);\r\n            expect(stats.maxEntries).toBe(3);\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.test.ts",
    "function_name": "anonymous",
    "start_line": 164,
    "end_line": 171,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const stats = cache.stats();",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.test.ts",
    "function_name": "anonymous",
    "start_line": 168,
    "end_line": 168,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "let instance: CacheService | null = null;",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.ts",
    "function_name": "anonymous",
    "start_line": 3,
    "end_line": 3,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "interface CacheConfig {\r\n    maxEntries: number;\r\n    defaultTtlSeconds: number;\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.ts",
    "function_name": "CacheConfig",
    "start_line": 5,
    "end_line": 8,
    "language": "typescript",
    "chunk_type": "interface"
  },
  {
    "content": "interface ICacheService {\r\n    buildCacheKey(cacheType: string, paramsForKey: Record<string, any>): string;\r\n    get<T>(key: string): T | null;\r\n    set<T>(key: string, data: T, ttlSeconds?: number): void;\r\n    delete(key: string): void;\r\n    clear(): void;\r\n    prune(): number;\r\n    stats(): { size: number; maxEntries: number };\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.ts",
    "function_name": "ICacheService",
    "start_line": 10,
    "end_line": 18,
    "language": "typescript",
    "chunk_type": "interface"
  },
  {
    "content": "const DEFAULT_CONFIG: CacheConfig = {\r\n    maxEntries: 100,        // Adjust based on your data size\r\n    defaultTtlSeconds: 300, // 5 minutes\r\n};",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.ts",
    "function_name": "anonymous",
    "start_line": 20,
    "end_line": 23,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "class CacheService implements ICacheService {\r\n    private cache: Map<string, CacheEntry<unknown>>;\r\n    private config: CacheConfig;\r\n\r\n    constructor(config: Partial<CacheConfig> = {}) {\r\n        this.cache = new Map<string, CacheEntry<unknown>>();\r\n        this.config = { ...DEFAULT_CONFIG, ...config };\r\n    }\r\n\r\n    buildCacheKey(cacheType: string, paramsForKey: Record<string, any>): string {\r\n        return `${cacheType}:${Object.entries(paramsForKey)\r\n            .map(([key, value]) => `${key}:${value}`)\r\n            .join(\"|\")}`;\r\n    }\r\n\r\n    get<T>(key: string): T | null {\r\n        const entry = this.cache.get(key) as CacheEntry<T> | undefined;\r\n        \r\n        // Check if expired\r\n        if (!entry || Date.now() > entry.expiresAt) {\r\n            this.cache.delete(key);\r\n            return null;\r\n        }\r\n\r\n        // LRU: Move to end (most recently used)\r\n        this.cache.delete(key);\r\n        this.cache.set(key, entry);\r\n\r\n        return entry.data;\r\n    }\r\n\r\n    set<T>(key: string, data: T, ttlSeconds?: number): void {\r\n        // If key exists, delete first (for LRU ordering)\r\n        if (this.cache.has(key)) {\r\n            this.cache.delete(key);\r\n        }\r\n\r\n        // Evict oldest entries if at capacity\r\n        while (this.cache.size >= this.config.maxEntries) {\r\n            const oldestKey = this.cache.keys().next().value!; // Non-null assertion: guaranteed to exist\r\n            this.cache.delete(oldestKey);\r\n        }\r\n\r\n        this.cache.set(key, {\r\n            data,\r\n            expiresAt: Date.now() + (ttlSeconds ?? this.config.defaultTtlSeconds) * 1000,\r\n        });\r\n    }\r\n\r\n    delete(key: string): void {\r\n        this.cache.delete(key);\r\n    }\r\n\r\n    clear(): void {\r\n        this.cache.clear();\r\n    }\r\n\r\n    // Remove all expired entries - call periodically if needed\r\n    prune(): number {\r\n        const now = Date.now();\r\n        let pruned = 0;\r\n        for (const [key, entry] of this.cache) {\r\n            if (now > entry.expiresAt) {\r\n                this.cache.delete(key);\r\n                pruned++;\r\n            }\r\n        }\r\n        return pruned;\r\n    }\r\n\r\n    // For debugging/monitoring\r\n    stats(): { size: number; maxEntries: number } {\r\n        return {\r\n            size: this.cache.size,\r\n            maxEntries: this.config.maxEntries,\r\n        };\r\n    }\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.ts",
    "function_name": "CacheService",
    "start_line": 25,
    "end_line": 102,
    "language": "typescript",
    "chunk_type": "class"
  },
  {
    "content": "constructor(config: Partial<CacheConfig> = {}) {\r\n        this.cache = new Map<string, CacheEntry<unknown>>();\r\n        this.config = { ...DEFAULT_CONFIG, ...config };\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.ts",
    "function_name": "anonymous",
    "start_line": 29,
    "end_line": 32,
    "language": "typescript",
    "chunk_type": "method"
  },
  {
    "content": "buildCacheKey(cacheType: string, paramsForKey: Record<string, any>): string {\r\n        return `${cacheType}:${Object.entries(paramsForKey)\r\n            .map(([key, value]) => `${key}:${value}`)\r\n            .join(\"|\")}`;\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.ts",
    "function_name": "anonymous",
    "start_line": 34,
    "end_line": 38,
    "language": "typescript",
    "chunk_type": "method"
  },
  {
    "content": "([key, value]) => `${key}:${value}`",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.ts",
    "function_name": "anonymous",
    "start_line": 36,
    "end_line": 36,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "get<T>(key: string): T | null {\r\n        const entry = this.cache.get(key) as CacheEntry<T> | undefined;\r\n        \r\n        // Check if expired\r\n        if (!entry || Date.now() > entry.expiresAt) {\r\n            this.cache.delete(key);\r\n            return null;\r\n        }\r\n\r\n        // LRU: Move to end (most recently used)\r\n        this.cache.delete(key);\r\n        this.cache.set(key, entry);\r\n\r\n        return entry.data;\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.ts",
    "function_name": "anonymous",
    "start_line": 40,
    "end_line": 54,
    "language": "typescript",
    "chunk_type": "method"
  },
  {
    "content": "const entry = this.cache.get(key) as CacheEntry<T> | undefined;",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.ts",
    "function_name": "anonymous",
    "start_line": 41,
    "end_line": 41,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "set<T>(key: string, data: T, ttlSeconds?: number): void {\r\n        // If key exists, delete first (for LRU ordering)\r\n        if (this.cache.has(key)) {\r\n            this.cache.delete(key);\r\n        }\r\n\r\n        // Evict oldest entries if at capacity\r\n        while (this.cache.size >= this.config.maxEntries) {\r\n            const oldestKey = this.cache.keys().next().value!; // Non-null assertion: guaranteed to exist\r\n            this.cache.delete(oldestKey);\r\n        }\r\n\r\n        this.cache.set(key, {\r\n            data,\r\n            expiresAt: Date.now() + (ttlSeconds ?? this.config.defaultTtlSeconds) * 1000,\r\n        });\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.ts",
    "function_name": "anonymous",
    "start_line": 56,
    "end_line": 72,
    "language": "typescript",
    "chunk_type": "method"
  },
  {
    "content": "const oldestKey = this.cache.keys().next().value!;",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.ts",
    "function_name": "anonymous",
    "start_line": 64,
    "end_line": 64,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "delete(key: string): void {\r\n        this.cache.delete(key);\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.ts",
    "function_name": "anonymous",
    "start_line": 74,
    "end_line": 76,
    "language": "typescript",
    "chunk_type": "method"
  },
  {
    "content": "clear(): void {\r\n        this.cache.clear();\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.ts",
    "function_name": "anonymous",
    "start_line": 78,
    "end_line": 80,
    "language": "typescript",
    "chunk_type": "method"
  },
  {
    "content": "prune(): number {\r\n        const now = Date.now();\r\n        let pruned = 0;\r\n        for (const [key, entry] of this.cache) {\r\n            if (now > entry.expiresAt) {\r\n                this.cache.delete(key);\r\n                pruned++;\r\n            }\r\n        }\r\n        return pruned;\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.ts",
    "function_name": "anonymous",
    "start_line": 83,
    "end_line": 93,
    "language": "typescript",
    "chunk_type": "method"
  },
  {
    "content": "const now = Date.now();",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.ts",
    "function_name": "anonymous",
    "start_line": 84,
    "end_line": 84,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "stats(): { size: number; maxEntries: number } {\r\n        return {\r\n            size: this.cache.size,\r\n            maxEntries: this.config.maxEntries,\r\n        };\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.ts",
    "function_name": "anonymous",
    "start_line": 96,
    "end_line": 101,
    "language": "typescript",
    "chunk_type": "method"
  },
  {
    "content": "function cacheServiceFactory(config?: Partial<CacheConfig>): CacheService {\r\n    if (!instance) {\r\n        instance = new CacheService(config);\r\n    }\r\n    return instance;\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\services\\cacheService.ts",
    "function_name": "cacheServiceFactory",
    "start_line": 104,
    "end_line": 109,
    "language": "typescript",
    "chunk_type": "function"
  },
  {
    "content": "type CacheEntry<T> = { data: T; expiresAt: number };",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\types\\cache\\cache.ts",
    "function_name": "CacheEntry",
    "start_line": 2,
    "end_line": 2,
    "language": "typescript",
    "chunk_type": "type"
  },
  {
    "content": "function meetDTOFactory(meetsRaw: MeetRepo[]): MeetDTO[] {\r\n    return meetsRaw.map((meetRaw) => ({\r\n        id: meetRaw._id.toString(),\r\n        name: meetRaw.meet_name,\r\n        location: {\r\n            address: meetRaw.address,\r\n            city: meetRaw.city,\r\n            state: meetRaw.state,\r\n            latitude: meetRaw.latitude,\r\n            longitude: meetRaw.longitude,\r\n            location: meetRaw.location,\r\n            hostedBy: meetRaw.hosted_by,\r\n        },\r\n        dates: {\r\n            startDate: meetRaw.start_date,\r\n            endDate: meetRaw.end_date,\r\n            reportedDate: meetRaw.reported_date,\r\n        },\r\n        source: {\r\n            source: meetRaw.source,\r\n            meetLink: meetRaw.meet_link,\r\n            resultsLink: meetRaw.results_link,\r\n            logoLink: meetRaw.logo_link,\r\n        }\r\n    }));\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\types\\meets\\dto\\MeetDTO.ts",
    "function_name": "meetDTOFactory",
    "start_line": 3,
    "end_line": 28,
    "language": "typescript",
    "chunk_type": "function"
  },
  {
    "content": "(meetRaw) => ({\r\n        id: meetRaw._id.toString(),\r\n        name: meetRaw.meet_name,\r\n        location: {\r\n            address: meetRaw.address,\r\n            city: meetRaw.city,\r\n            state: meetRaw.state,\r\n            latitude: meetRaw.latitude,\r\n            longitude: meetRaw.longitude,\r\n            location: meetRaw.location,\r\n            hostedBy: meetRaw.hosted_by,\r\n        },\r\n        dates: {\r\n            startDate: meetRaw.start_date,\r\n            endDate: meetRaw.end_date,\r\n            reportedDate: meetRaw.reported_date,\r\n        },\r\n        source: {\r\n            source: meetRaw.source,\r\n            meetLink: meetRaw.meet_link,\r\n            resultsLink: meetRaw.results_link,\r\n            logoLink: meetRaw.logo_link,\r\n        }\r\n    })",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\types\\meets\\dto\\MeetDTO.ts",
    "function_name": "anonymous",
    "start_line": 4,
    "end_line": 27,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "type MeetDTO = {\r\n    id: string;\r\n    name: string;\r\n    location: MeetLocationDTO;\r\n    dates: MeetDateDTO;\r\n    source: MeetSourceDTO;\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\types\\meets\\dto\\MeetDTO.ts",
    "function_name": "MeetDTO",
    "start_line": 30,
    "end_line": 36,
    "language": "typescript",
    "chunk_type": "type"
  },
  {
    "content": "type MeetLocationDTO = {\r\n    address: string;\r\n    city: string;\r\n    state: string;\r\n    latitude: number;\r\n    longitude: number;\r\n    location: string;\r\n    hostedBy: string;\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\types\\meets\\dto\\MeetDTO.ts",
    "function_name": "MeetLocationDTO",
    "start_line": 38,
    "end_line": 46,
    "language": "typescript",
    "chunk_type": "type"
  },
  {
    "content": "type MeetDateDTO = {\r\n    startDate: string;\r\n    endDate: string;\r\n    reportedDate: string;\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\types\\meets\\dto\\MeetDTO.ts",
    "function_name": "MeetDateDTO",
    "start_line": 48,
    "end_line": 52,
    "language": "typescript",
    "chunk_type": "type"
  },
  {
    "content": "type MeetSourceDTO = {\r\n    source: string;\r\n    meetLink: string;\r\n    resultsLink: string | null;\r\n    logoLink: string;\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\types\\meets\\dto\\MeetDTO.ts",
    "function_name": "MeetSourceDTO",
    "start_line": 54,
    "end_line": 59,
    "language": "typescript",
    "chunk_type": "type"
  },
  {
    "content": "type MeetRepo = {\r\n    _id: ObjectId;\r\n    match_key: string;\r\n    address: string;\r\n    city: string;\r\n    created_at: string;\r\n    end_date: string;\r\n    first_seen_at: string;\r\n    hosted_by: string;\r\n    latitude: number;\r\n    location: string;\r\n    logo_link: string;\r\n    longitude: number;\r\n    meet_link: string;\r\n    meet_name: string;\r\n    reported_date: string;\r\n    results_link: string | null;\r\n    source: string;\r\n    sources: string[];\r\n    start_date: string;\r\n    state: string;\r\n    updated_at: string;\r\n};",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\types\\meets\\repository\\MeetRepo.ts",
    "function_name": "MeetRepo",
    "start_line": 3,
    "end_line": 25,
    "language": "typescript",
    "chunk_type": "type"
  },
  {
    "content": "interface RouteInterface {\r\n    event: any;\r\n    context: any;\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\types\\routes\\routeInterface.ts",
    "function_name": "RouteInterface",
    "start_line": 1,
    "end_line": 4,
    "language": "typescript",
    "chunk_type": "interface"
  },
  {
    "content": "() => ({\r\n    logInfo: vi.fn(),\r\n    logError: vi.fn(),\r\n    logWarn: vi.fn(),\r\n    logDebug: vi.fn()\r\n})",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 6,
    "end_line": 11,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const mockMeetsRepository = {\r\n    getMeets: vi.fn(),\r\n    getMeetById: vi.fn()\r\n};",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 14,
    "end_line": 17,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "() => ({\r\n    MeetsRepository: vi.fn(function(this: any) {\r\n        return mockMeetsRepository;\r\n    })\r\n})",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 19,
    "end_line": 23,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => ({\r\n    meetDTOFactory: vi.fn()\r\n})",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 26,
    "end_line": 28,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => {\r\n    let useCase: ReturnType<typeof meetsUseCaseFactory>;\r\n    let meetDTOFactory: any;\r\n\r\n    const mockMeetRepo = {\r\n        _id: new ObjectId('507f1f77bcf86cd799439011'),\r\n        match_key: 'test-meet-2024',\r\n        address: '123 Track St',\r\n        city: 'Test City',\r\n        created_at: '2024-01-01T00:00:00.000Z',\r\n        end_date: '2024-06-15',\r\n        first_seen_at: '2024-01-01T00:00:00.000Z',\r\n        hosted_by: 'Test High School',\r\n        latitude: 40.7128,\r\n        location: 'Test Stadium',\r\n        logo_link: 'https://example.com/logo.png',\r\n        longitude: -74.0060,\r\n        meet_link: 'https://example.com/meet',\r\n        meet_name: 'Test Invitational',\r\n        reported_date: '2024-06-14',\r\n        results_link: 'https://example.com/results',\r\n        source: 'athleticnet',\r\n        sources: ['athleticnet', 'milesplit'],\r\n        start_date: '2024-06-14',\r\n        state: 'NY',\r\n        updated_at: '2024-01-01T00:00:00.000Z'\r\n    };\r\n\r\n    const mockMeetDTO = {\r\n        id: '507f1f77bcf86cd799439011',\r\n        name: 'Test Invitational',\r\n        location: {\r\n            address: '123 Track St',\r\n            city: 'Test City',\r\n            state: 'NY',\r\n            latitude: 40.7128,\r\n            longitude: -74.0060,\r\n            location: 'Test Stadium',\r\n            hostedBy: 'Test High School'\r\n        },\r\n        dates: {\r\n            startDate: '2024-06-14',\r\n            endDate: '2024-06-15',\r\n            reportedDate: '2024-06-14'\r\n        },\r\n        source: {\r\n            source: 'athleticnet',\r\n            meetLink: 'https://example.com/meet',\r\n            resultsLink: 'https://example.com/results',\r\n            logoLink: 'https://example.com/logo.png'\r\n        }\r\n    };\r\n\r\n    beforeEach(async () => {\r\n        vi.clearAllMocks();\r\n        const dtoModule = await import('../../types/meets/dto/MeetDTO');\r\n        meetDTOFactory = dtoModule.meetDTOFactory as any;\r\n        useCase = meetsUseCaseFactory();\r\n    });\r\n\r\n    describe('factory', () => {\r\n        it('creates instance of MeetsUseCase', () => {\r\n            expect(useCase).toBeDefined();\r\n        });\r\n\r\n        it('initializes with MeetsRepository', () => {\r\n            expect((useCase as any).meetsRepository).toBeDefined();\r\n        });\r\n    });\r\n\r\n    describe('getMeets', () => {\r\n        it('fetches meets and maps to DTOs', async () => {\r\n            mockMeetsRepository.getMeets.mockResolvedValueOnce([mockMeetRepo]);\r\n            meetDTOFactory.mockReturnValueOnce([mockMeetDTO]);\r\n\r\n            const result = await useCase.getMeets(10, 0);\r\n\r\n            expect(mockMeetsRepository.getMeets).toHaveBeenCalledWith(10, 0);\r\n            expect(meetDTOFactory).toHaveBeenCalledWith([mockMeetRepo]);\r\n            expect(result).toEqual([mockMeetDTO]);\r\n        });\r\n\r\n        it('limits take parameter to maximum of 40', async () => {\r\n            mockMeetsRepository.getMeets.mockResolvedValueOnce([]);\r\n            meetDTOFactory.mockReturnValueOnce([]);\r\n\r\n            await useCase.getMeets(100, 0);\r\n\r\n            expect(mockMeetsRepository.getMeets).toHaveBeenCalledWith(40, 0);\r\n        });\r\n\r\n        it('allows take parameter less than 40', async () => {\r\n            mockMeetsRepository.getMeets.mockResolvedValueOnce([]);\r\n            meetDTOFactory.mockReturnValueOnce([]);\r\n\r\n            await useCase.getMeets(20, 0);\r\n\r\n            expect(mockMeetsRepository.getMeets).toHaveBeenCalledWith(20, 0);\r\n        });\r\n\r\n        it('allows take parameter exactly 40', async () => {\r\n            mockMeetsRepository.getMeets.mockResolvedValueOnce([]);\r\n            meetDTOFactory.mockReturnValueOnce([]);\r\n\r\n            await useCase.getMeets(40, 0);\r\n\r\n            expect(mockMeetsRepository.getMeets).toHaveBeenCalledWith(40, 0);\r\n        });\r\n\r\n        it('passes skip parameter when provided', async () => {\r\n            mockMeetsRepository.getMeets.mockResolvedValueOnce([]);\r\n            meetDTOFactory.mockReturnValueOnce([]);\r\n\r\n            await useCase.getMeets(10, 50);\r\n\r\n            expect(mockMeetsRepository.getMeets).toHaveBeenCalledWith(10, 50);\r\n        });\r\n\r\n        it('passes undefined skip when not provided', async () => {\r\n            mockMeetsRepository.getMeets.mockResolvedValueOnce([]);\r\n            meetDTOFactory.mockReturnValueOnce([]);\r\n\r\n            await useCase.getMeets(10);\r\n\r\n            expect(mockMeetsRepository.getMeets).toHaveBeenCalledWith(10, undefined);\r\n        });\r\n\r\n        it('returns empty array when no meets found', async () => {\r\n            mockMeetsRepository.getMeets.mockResolvedValueOnce([]);\r\n            meetDTOFactory.mockReturnValueOnce([]);\r\n\r\n            const result = await useCase.getMeets(10);\r\n\r\n            expect(result).toEqual([]);\r\n        });\r\n\r\n        it('handles multiple meets', async () => {\r\n            const multipleMeets = [mockMeetRepo, { ...mockMeetRepo, _id: new ObjectId() }];\r\n            const multipleDTOs = [mockMeetDTO, { ...mockMeetDTO, id: 'different-id' }];\r\n            \r\n            mockMeetsRepository.getMeets.mockResolvedValueOnce(multipleMeets);\r\n            meetDTOFactory.mockReturnValueOnce(multipleDTOs);\r\n\r\n            const result = await useCase.getMeets(10);\r\n\r\n            expect(result).toHaveLength(2);\r\n            expect(result).toEqual(multipleDTOs);\r\n        });\r\n\r\n        it('throws error when repository fails', async () => {\r\n            const error = new Error('Repository error');\r\n            mockMeetsRepository.getMeets.mockRejectedValueOnce(error);\r\n\r\n            await expect(useCase.getMeets(10)).rejects.toThrow('Repository error');\r\n        });\r\n\r\n        it('throws error when DTO factory fails', async () => {\r\n            const error = new Error('DTO factory error');\r\n            mockMeetsRepository.getMeets.mockResolvedValueOnce([mockMeetRepo]);\r\n            meetDTOFactory.mockImplementationOnce(() => { throw error; });\r\n\r\n            await expect(useCase.getMeets(10)).rejects.toThrow('DTO factory error');\r\n        });\r\n    });\r\n\r\n    describe('getMeetById', () => {\r\n        const testMeetId = '507f1f77bcf86cd799439011';\r\n\r\n        it('fetches meet by ID and maps to DTO', async () => {\r\n            mockMeetsRepository.getMeetById.mockResolvedValueOnce(mockMeetRepo);\r\n            meetDTOFactory.mockReturnValueOnce([mockMeetDTO]);\r\n\r\n            const result = await useCase.getMeetById(testMeetId);\r\n\r\n            expect(mockMeetsRepository.getMeetById).toHaveBeenCalledWith(testMeetId);\r\n            expect(meetDTOFactory).toHaveBeenCalledWith([mockMeetRepo]);\r\n            expect(result).toEqual(mockMeetDTO);\r\n        });\r\n\r\n        it('returns null when meet not found', async () => {\r\n            mockMeetsRepository.getMeetById.mockResolvedValueOnce(null);\r\n\r\n            const result = await useCase.getMeetById(testMeetId);\r\n\r\n            expect(result).toBeNull();\r\n            expect(meetDTOFactory).not.toHaveBeenCalled();\r\n        });\r\n\r\n        it('returns first element from DTO array', async () => {\r\n            const multipleDTOs = [mockMeetDTO, { ...mockMeetDTO, id: 'should-not-return' }];\r\n            mockMeetsRepository.getMeetById.mockResolvedValueOnce(mockMeetRepo);\r\n            meetDTOFactory.mockReturnValueOnce(multipleDTOs);\r\n\r\n            const result = await useCase.getMeetById(testMeetId);\r\n\r\n            expect(result).toEqual(mockMeetDTO);\r\n            expect(result?.id).toBe('507f1f77bcf86cd799439011');\r\n        });\r\n\r\n        it('throws error when DTO factory returns empty array', async () => {\r\n            mockMeetsRepository.getMeetById.mockResolvedValueOnce(mockMeetRepo);\r\n            meetDTOFactory.mockReturnValueOnce([]);\r\n\r\n            await expect(useCase.getMeetById(testMeetId)).rejects.toThrow(\r\n                'Mapped meet DTO is null or empty'\r\n            );\r\n        });\r\n\r\n        it('throws error when repository fails', async () => {\r\n            const error = new Error('Repository error');\r\n            mockMeetsRepository.getMeetById.mockRejectedValueOnce(error);\r\n\r\n            await expect(useCase.getMeetById(testMeetId)).rejects.toThrow('Repository error');\r\n        });\r\n\r\n        it('throws error when DTO factory fails', async () => {\r\n            const error = new Error('DTO factory error');\r\n            mockMeetsRepository.getMeetById.mockResolvedValueOnce(mockMeetRepo);\r\n            meetDTOFactory.mockImplementationOnce(() => { throw error; });\r\n\r\n            await expect(useCase.getMeetById(testMeetId)).rejects.toThrow('DTO factory error');\r\n        });\r\n\r\n        it('passes meet ID through to repository', async () => {\r\n            const customId = 'custom-meet-id-123';\r\n            mockMeetsRepository.getMeetById.mockResolvedValueOnce(null);\r\n\r\n            await useCase.getMeetById(customId);\r\n\r\n            expect(mockMeetsRepository.getMeetById).toHaveBeenCalledWith(customId);\r\n        });\r\n\r\n        it('wraps single meet in array when calling DTO factory', async () => {\r\n            mockMeetsRepository.getMeetById.mockResolvedValueOnce(mockMeetRepo);\r\n            meetDTOFactory.mockReturnValueOnce([mockMeetDTO]);\r\n\r\n            await useCase.getMeetById(testMeetId);\r\n\r\n            const factoryCall = meetDTOFactory.mock.calls[0][0];\r\n            expect(Array.isArray(factoryCall)).toBe(true);\r\n            expect(factoryCall).toHaveLength(1);\r\n            expect(factoryCall[0]).toEqual(mockMeetRepo);\r\n        });\r\n    });\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 30,
    "end_line": 274,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "let useCase: ReturnType<typeof meetsUseCaseFactory>;",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 31,
    "end_line": 31,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "let meetDTOFactory: any;",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 32,
    "end_line": 32,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "const mockMeetRepo = {\r\n        _id: new ObjectId('507f1f77bcf86cd799439011'),\r\n        match_key: 'test-meet-2024',\r\n        address: '123 Track St',\r\n        city: 'Test City',\r\n        created_at: '2024-01-01T00:00:00.000Z',\r\n        end_date: '2024-06-15',\r\n        first_seen_at: '2024-01-01T00:00:00.000Z',\r\n        hosted_by: 'Test High School',\r\n        latitude: 40.7128,\r\n        location: 'Test Stadium',\r\n        logo_link: 'https://example.com/logo.png',\r\n        longitude: -74.0060,\r\n        meet_link: 'https://example.com/meet',\r\n        meet_name: 'Test Invitational',\r\n        reported_date: '2024-06-14',\r\n        results_link: 'https://example.com/results',\r\n        source: 'athleticnet',\r\n        sources: ['athleticnet', 'milesplit'],\r\n        start_date: '2024-06-14',\r\n        state: 'NY',\r\n        updated_at: '2024-01-01T00:00:00.000Z'\r\n    };",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 34,
    "end_line": 56,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "const mockMeetDTO = {\r\n        id: '507f1f77bcf86cd799439011',\r\n        name: 'Test Invitational',\r\n        location: {\r\n            address: '123 Track St',\r\n            city: 'Test City',\r\n            state: 'NY',\r\n            latitude: 40.7128,\r\n            longitude: -74.0060,\r\n            location: 'Test Stadium',\r\n            hostedBy: 'Test High School'\r\n        },\r\n        dates: {\r\n            startDate: '2024-06-14',\r\n            endDate: '2024-06-15',\r\n            reportedDate: '2024-06-14'\r\n        },\r\n        source: {\r\n            source: 'athleticnet',\r\n            meetLink: 'https://example.com/meet',\r\n            resultsLink: 'https://example.com/results',\r\n            logoLink: 'https://example.com/logo.png'\r\n        }\r\n    };",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 58,
    "end_line": 81,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "async () => {\r\n        vi.clearAllMocks();\r\n        const dtoModule = await import('../../types/meets/dto/MeetDTO');\r\n        meetDTOFactory = dtoModule.meetDTOFactory as any;\r\n        useCase = meetsUseCaseFactory();\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 83,
    "end_line": 88,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const dtoModule = await import('../../types/meets/dto/MeetDTO');",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 85,
    "end_line": 85,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "() => {\r\n        it('creates instance of MeetsUseCase', () => {\r\n            expect(useCase).toBeDefined();\r\n        });\r\n\r\n        it('initializes with MeetsRepository', () => {\r\n            expect((useCase as any).meetsRepository).toBeDefined();\r\n        });\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 90,
    "end_line": 98,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => {\r\n            expect(useCase).toBeDefined();\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 91,
    "end_line": 93,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => {\r\n            expect((useCase as any).meetsRepository).toBeDefined();\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 95,
    "end_line": 97,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => {\r\n        it('fetches meets and maps to DTOs', async () => {\r\n            mockMeetsRepository.getMeets.mockResolvedValueOnce([mockMeetRepo]);\r\n            meetDTOFactory.mockReturnValueOnce([mockMeetDTO]);\r\n\r\n            const result = await useCase.getMeets(10, 0);\r\n\r\n            expect(mockMeetsRepository.getMeets).toHaveBeenCalledWith(10, 0);\r\n            expect(meetDTOFactory).toHaveBeenCalledWith([mockMeetRepo]);\r\n            expect(result).toEqual([mockMeetDTO]);\r\n        });\r\n\r\n        it('limits take parameter to maximum of 40', async () => {\r\n            mockMeetsRepository.getMeets.mockResolvedValueOnce([]);\r\n            meetDTOFactory.mockReturnValueOnce([]);\r\n\r\n            await useCase.getMeets(100, 0);\r\n\r\n            expect(mockMeetsRepository.getMeets).toHaveBeenCalledWith(40, 0);\r\n        });\r\n\r\n        it('allows take parameter less than 40', async () => {\r\n            mockMeetsRepository.getMeets.mockResolvedValueOnce([]);\r\n            meetDTOFactory.mockReturnValueOnce([]);\r\n\r\n            await useCase.getMeets(20, 0);\r\n\r\n            expect(mockMeetsRepository.getMeets).toHaveBeenCalledWith(20, 0);\r\n        });\r\n\r\n        it('allows take parameter exactly 40', async () => {\r\n            mockMeetsRepository.getMeets.mockResolvedValueOnce([]);\r\n            meetDTOFactory.mockReturnValueOnce([]);\r\n\r\n            await useCase.getMeets(40, 0);\r\n\r\n            expect(mockMeetsRepository.getMeets).toHaveBeenCalledWith(40, 0);\r\n        });\r\n\r\n        it('passes skip parameter when provided', async () => {\r\n            mockMeetsRepository.getMeets.mockResolvedValueOnce([]);\r\n            meetDTOFactory.mockReturnValueOnce([]);\r\n\r\n            await useCase.getMeets(10, 50);\r\n\r\n            expect(mockMeetsRepository.getMeets).toHaveBeenCalledWith(10, 50);\r\n        });\r\n\r\n        it('passes undefined skip when not provided', async () => {\r\n            mockMeetsRepository.getMeets.mockResolvedValueOnce([]);\r\n            meetDTOFactory.mockReturnValueOnce([]);\r\n\r\n            await useCase.getMeets(10);\r\n\r\n            expect(mockMeetsRepository.getMeets).toHaveBeenCalledWith(10, undefined);\r\n        });\r\n\r\n        it('returns empty array when no meets found', async () => {\r\n            mockMeetsRepository.getMeets.mockResolvedValueOnce([]);\r\n            meetDTOFactory.mockReturnValueOnce([]);\r\n\r\n            const result = await useCase.getMeets(10);\r\n\r\n            expect(result).toEqual([]);\r\n        });\r\n\r\n        it('handles multiple meets', async () => {\r\n            const multipleMeets = [mockMeetRepo, { ...mockMeetRepo, _id: new ObjectId() }];\r\n            const multipleDTOs = [mockMeetDTO, { ...mockMeetDTO, id: 'different-id' }];\r\n            \r\n            mockMeetsRepository.getMeets.mockResolvedValueOnce(multipleMeets);\r\n            meetDTOFactory.mockReturnValueOnce(multipleDTOs);\r\n\r\n            const result = await useCase.getMeets(10);\r\n\r\n            expect(result).toHaveLength(2);\r\n            expect(result).toEqual(multipleDTOs);\r\n        });\r\n\r\n        it('throws error when repository fails', async () => {\r\n            const error = new Error('Repository error');\r\n            mockMeetsRepository.getMeets.mockRejectedValueOnce(error);\r\n\r\n            await expect(useCase.getMeets(10)).rejects.toThrow('Repository error');\r\n        });\r\n\r\n        it('throws error when DTO factory fails', async () => {\r\n            const error = new Error('DTO factory error');\r\n            mockMeetsRepository.getMeets.mockResolvedValueOnce([mockMeetRepo]);\r\n            meetDTOFactory.mockImplementationOnce(() => { throw error; });\r\n\r\n            await expect(useCase.getMeets(10)).rejects.toThrow('DTO factory error');\r\n        });\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 100,
    "end_line": 193,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "async () => {\r\n            mockMeetsRepository.getMeets.mockResolvedValueOnce([mockMeetRepo]);\r\n            meetDTOFactory.mockReturnValueOnce([mockMeetDTO]);\r\n\r\n            const result = await useCase.getMeets(10, 0);\r\n\r\n            expect(mockMeetsRepository.getMeets).toHaveBeenCalledWith(10, 0);\r\n            expect(meetDTOFactory).toHaveBeenCalledWith([mockMeetRepo]);\r\n            expect(result).toEqual([mockMeetDTO]);\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 101,
    "end_line": 110,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const result = await useCase.getMeets(10, 0);",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 105,
    "end_line": 105,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "async () => {\r\n            mockMeetsRepository.getMeets.mockResolvedValueOnce([]);\r\n            meetDTOFactory.mockReturnValueOnce([]);\r\n\r\n            await useCase.getMeets(100, 0);\r\n\r\n            expect(mockMeetsRepository.getMeets).toHaveBeenCalledWith(40, 0);\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 112,
    "end_line": 119,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "async () => {\r\n            mockMeetsRepository.getMeets.mockResolvedValueOnce([]);\r\n            meetDTOFactory.mockReturnValueOnce([]);\r\n\r\n            await useCase.getMeets(20, 0);\r\n\r\n            expect(mockMeetsRepository.getMeets).toHaveBeenCalledWith(20, 0);\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 121,
    "end_line": 128,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "async () => {\r\n            mockMeetsRepository.getMeets.mockResolvedValueOnce([]);\r\n            meetDTOFactory.mockReturnValueOnce([]);\r\n\r\n            await useCase.getMeets(40, 0);\r\n\r\n            expect(mockMeetsRepository.getMeets).toHaveBeenCalledWith(40, 0);\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 130,
    "end_line": 137,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "async () => {\r\n            mockMeetsRepository.getMeets.mockResolvedValueOnce([]);\r\n            meetDTOFactory.mockReturnValueOnce([]);\r\n\r\n            await useCase.getMeets(10, 50);\r\n\r\n            expect(mockMeetsRepository.getMeets).toHaveBeenCalledWith(10, 50);\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 139,
    "end_line": 146,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "async () => {\r\n            mockMeetsRepository.getMeets.mockResolvedValueOnce([]);\r\n            meetDTOFactory.mockReturnValueOnce([]);\r\n\r\n            await useCase.getMeets(10);\r\n\r\n            expect(mockMeetsRepository.getMeets).toHaveBeenCalledWith(10, undefined);\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 148,
    "end_line": 155,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "async () => {\r\n            mockMeetsRepository.getMeets.mockResolvedValueOnce([]);\r\n            meetDTOFactory.mockReturnValueOnce([]);\r\n\r\n            const result = await useCase.getMeets(10);\r\n\r\n            expect(result).toEqual([]);\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 157,
    "end_line": 164,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const result = await useCase.getMeets(10);",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 161,
    "end_line": 161,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "async () => {\r\n            const multipleMeets = [mockMeetRepo, { ...mockMeetRepo, _id: new ObjectId() }];\r\n            const multipleDTOs = [mockMeetDTO, { ...mockMeetDTO, id: 'different-id' }];\r\n            \r\n            mockMeetsRepository.getMeets.mockResolvedValueOnce(multipleMeets);\r\n            meetDTOFactory.mockReturnValueOnce(multipleDTOs);\r\n\r\n            const result = await useCase.getMeets(10);\r\n\r\n            expect(result).toHaveLength(2);\r\n            expect(result).toEqual(multipleDTOs);\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 166,
    "end_line": 177,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const multipleMeets = [mockMeetRepo, { ...mockMeetRepo, _id: new ObjectId() }];",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 167,
    "end_line": 167,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "const multipleDTOs = [mockMeetDTO, { ...mockMeetDTO, id: 'different-id' }];",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 168,
    "end_line": 168,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "const result = await useCase.getMeets(10);",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 173,
    "end_line": 173,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "async () => {\r\n            const error = new Error('Repository error');\r\n            mockMeetsRepository.getMeets.mockRejectedValueOnce(error);\r\n\r\n            await expect(useCase.getMeets(10)).rejects.toThrow('Repository error');\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 179,
    "end_line": 184,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const error = new Error('Repository error');",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 180,
    "end_line": 180,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "async () => {\r\n            const error = new Error('DTO factory error');\r\n            mockMeetsRepository.getMeets.mockResolvedValueOnce([mockMeetRepo]);\r\n            meetDTOFactory.mockImplementationOnce(() => { throw error; });\r\n\r\n            await expect(useCase.getMeets(10)).rejects.toThrow('DTO factory error');\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 186,
    "end_line": 192,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const error = new Error('DTO factory error');",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 187,
    "end_line": 187,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "() => { throw error; }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 189,
    "end_line": 189,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => {\r\n        const testMeetId = '507f1f77bcf86cd799439011';\r\n\r\n        it('fetches meet by ID and maps to DTO', async () => {\r\n            mockMeetsRepository.getMeetById.mockResolvedValueOnce(mockMeetRepo);\r\n            meetDTOFactory.mockReturnValueOnce([mockMeetDTO]);\r\n\r\n            const result = await useCase.getMeetById(testMeetId);\r\n\r\n            expect(mockMeetsRepository.getMeetById).toHaveBeenCalledWith(testMeetId);\r\n            expect(meetDTOFactory).toHaveBeenCalledWith([mockMeetRepo]);\r\n            expect(result).toEqual(mockMeetDTO);\r\n        });\r\n\r\n        it('returns null when meet not found', async () => {\r\n            mockMeetsRepository.getMeetById.mockResolvedValueOnce(null);\r\n\r\n            const result = await useCase.getMeetById(testMeetId);\r\n\r\n            expect(result).toBeNull();\r\n            expect(meetDTOFactory).not.toHaveBeenCalled();\r\n        });\r\n\r\n        it('returns first element from DTO array', async () => {\r\n            const multipleDTOs = [mockMeetDTO, { ...mockMeetDTO, id: 'should-not-return' }];\r\n            mockMeetsRepository.getMeetById.mockResolvedValueOnce(mockMeetRepo);\r\n            meetDTOFactory.mockReturnValueOnce(multipleDTOs);\r\n\r\n            const result = await useCase.getMeetById(testMeetId);\r\n\r\n            expect(result).toEqual(mockMeetDTO);\r\n            expect(result?.id).toBe('507f1f77bcf86cd799439011');\r\n        });\r\n\r\n        it('throws error when DTO factory returns empty array', async () => {\r\n            mockMeetsRepository.getMeetById.mockResolvedValueOnce(mockMeetRepo);\r\n            meetDTOFactory.mockReturnValueOnce([]);\r\n\r\n            await expect(useCase.getMeetById(testMeetId)).rejects.toThrow(\r\n                'Mapped meet DTO is null or empty'\r\n            );\r\n        });\r\n\r\n        it('throws error when repository fails', async () => {\r\n            const error = new Error('Repository error');\r\n            mockMeetsRepository.getMeetById.mockRejectedValueOnce(error);\r\n\r\n            await expect(useCase.getMeetById(testMeetId)).rejects.toThrow('Repository error');\r\n        });\r\n\r\n        it('throws error when DTO factory fails', async () => {\r\n            const error = new Error('DTO factory error');\r\n            mockMeetsRepository.getMeetById.mockResolvedValueOnce(mockMeetRepo);\r\n            meetDTOFactory.mockImplementationOnce(() => { throw error; });\r\n\r\n            await expect(useCase.getMeetById(testMeetId)).rejects.toThrow('DTO factory error');\r\n        });\r\n\r\n        it('passes meet ID through to repository', async () => {\r\n            const customId = 'custom-meet-id-123';\r\n            mockMeetsRepository.getMeetById.mockResolvedValueOnce(null);\r\n\r\n            await useCase.getMeetById(customId);\r\n\r\n            expect(mockMeetsRepository.getMeetById).toHaveBeenCalledWith(customId);\r\n        });\r\n\r\n        it('wraps single meet in array when calling DTO factory', async () => {\r\n            mockMeetsRepository.getMeetById.mockResolvedValueOnce(mockMeetRepo);\r\n            meetDTOFactory.mockReturnValueOnce([mockMeetDTO]);\r\n\r\n            await useCase.getMeetById(testMeetId);\r\n\r\n            const factoryCall = meetDTOFactory.mock.calls[0][0];\r\n            expect(Array.isArray(factoryCall)).toBe(true);\r\n            expect(factoryCall).toHaveLength(1);\r\n            expect(factoryCall[0]).toEqual(mockMeetRepo);\r\n        });\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 195,
    "end_line": 273,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const testMeetId = '507f1f77bcf86cd799439011';",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 196,
    "end_line": 196,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "async () => {\r\n            mockMeetsRepository.getMeetById.mockResolvedValueOnce(mockMeetRepo);\r\n            meetDTOFactory.mockReturnValueOnce([mockMeetDTO]);\r\n\r\n            const result = await useCase.getMeetById(testMeetId);\r\n\r\n            expect(mockMeetsRepository.getMeetById).toHaveBeenCalledWith(testMeetId);\r\n            expect(meetDTOFactory).toHaveBeenCalledWith([mockMeetRepo]);\r\n            expect(result).toEqual(mockMeetDTO);\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 198,
    "end_line": 207,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const result = await useCase.getMeetById(testMeetId);",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 202,
    "end_line": 202,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "async () => {\r\n            mockMeetsRepository.getMeetById.mockResolvedValueOnce(null);\r\n\r\n            const result = await useCase.getMeetById(testMeetId);\r\n\r\n            expect(result).toBeNull();\r\n            expect(meetDTOFactory).not.toHaveBeenCalled();\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 209,
    "end_line": 216,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const result = await useCase.getMeetById(testMeetId);",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 212,
    "end_line": 212,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "async () => {\r\n            const multipleDTOs = [mockMeetDTO, { ...mockMeetDTO, id: 'should-not-return' }];\r\n            mockMeetsRepository.getMeetById.mockResolvedValueOnce(mockMeetRepo);\r\n            meetDTOFactory.mockReturnValueOnce(multipleDTOs);\r\n\r\n            const result = await useCase.getMeetById(testMeetId);\r\n\r\n            expect(result).toEqual(mockMeetDTO);\r\n            expect(result?.id).toBe('507f1f77bcf86cd799439011');\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 218,
    "end_line": 227,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const multipleDTOs = [mockMeetDTO, { ...mockMeetDTO, id: 'should-not-return' }];",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 219,
    "end_line": 219,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "const result = await useCase.getMeetById(testMeetId);",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 223,
    "end_line": 223,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "async () => {\r\n            mockMeetsRepository.getMeetById.mockResolvedValueOnce(mockMeetRepo);\r\n            meetDTOFactory.mockReturnValueOnce([]);\r\n\r\n            await expect(useCase.getMeetById(testMeetId)).rejects.toThrow(\r\n                'Mapped meet DTO is null or empty'\r\n            );\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 229,
    "end_line": 236,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "async () => {\r\n            const error = new Error('Repository error');\r\n            mockMeetsRepository.getMeetById.mockRejectedValueOnce(error);\r\n\r\n            await expect(useCase.getMeetById(testMeetId)).rejects.toThrow('Repository error');\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 238,
    "end_line": 243,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const error = new Error('Repository error');",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 239,
    "end_line": 239,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "async () => {\r\n            const error = new Error('DTO factory error');\r\n            mockMeetsRepository.getMeetById.mockResolvedValueOnce(mockMeetRepo);\r\n            meetDTOFactory.mockImplementationOnce(() => { throw error; });\r\n\r\n            await expect(useCase.getMeetById(testMeetId)).rejects.toThrow('DTO factory error');\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 245,
    "end_line": 251,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const error = new Error('DTO factory error');",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 246,
    "end_line": 246,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "() => { throw error; }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 248,
    "end_line": 248,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "async () => {\r\n            const customId = 'custom-meet-id-123';\r\n            mockMeetsRepository.getMeetById.mockResolvedValueOnce(null);\r\n\r\n            await useCase.getMeetById(customId);\r\n\r\n            expect(mockMeetsRepository.getMeetById).toHaveBeenCalledWith(customId);\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 253,
    "end_line": 260,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const customId = 'custom-meet-id-123';",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 254,
    "end_line": 254,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "async () => {\r\n            mockMeetsRepository.getMeetById.mockResolvedValueOnce(mockMeetRepo);\r\n            meetDTOFactory.mockReturnValueOnce([mockMeetDTO]);\r\n\r\n            await useCase.getMeetById(testMeetId);\r\n\r\n            const factoryCall = meetDTOFactory.mock.calls[0][0];\r\n            expect(Array.isArray(factoryCall)).toBe(true);\r\n            expect(factoryCall).toHaveLength(1);\r\n            expect(factoryCall[0]).toEqual(mockMeetRepo);\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 262,
    "end_line": 272,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const factoryCall = meetDTOFactory.mock.calls[0][0];",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.test.ts",
    "function_name": "anonymous",
    "start_line": 268,
    "end_line": 268,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "class MeetsUseCase {\r\n    private meetsRepository: MeetsRepository\r\n    private readonly MODULE = \"MeetsUseCase\";\r\n\r\n    constructor() {\r\n        this.meetsRepository = new MeetsRepository();\r\n    }\r\n\r\n    async getMeets(take: number, skip?: number): Promise<MeetDTO[]> {\r\n        try {\r\n            // ensure that take is no larger than 40\r\n            if (take > 40) {\r\n                take = 40;\r\n            }\r\n\r\n            //make fetch\r\n            const rawMeets = await this.meetsRepository.getMeets(take, skip);\r\n\r\n            //map to dto\r\n            const meetsDTO: MeetDTO[] = meetDTOFactory(rawMeets);\r\n\r\n            //return\r\n            return meetsDTO;\r\n\r\n        } catch (error) {\r\n            logError(\"Error in getMeets\", { error }, this.MODULE);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async getMeetById(meetId: string): Promise<MeetDTO | null> {\r\n        try {\r\n            //make fetch\r\n            const rawMeets = await this.meetsRepository.getMeetById(meetId);\r\n\r\n            if (!rawMeets) {\r\n                return null;\r\n            }\r\n\r\n            //map to dto\r\n            const meetsDTO: MeetDTO[] = meetDTOFactory([rawMeets]);\r\n\r\n            if (!meetsDTO || meetsDTO.length === 0) {\r\n                throw new Error(\"Mapped meet DTO is null or empty\");\r\n            }\r\n\r\n            //return\r\n            return meetsDTO[0];\r\n        } catch (error) {\r\n            logError(\"Error in getMeetById\", { error, meetId }, this.MODULE);\r\n            throw error;\r\n        }\r\n    }\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.ts",
    "function_name": "MeetsUseCase",
    "start_line": 5,
    "end_line": 58,
    "language": "typescript",
    "chunk_type": "class"
  },
  {
    "content": "constructor() {\r\n        this.meetsRepository = new MeetsRepository();\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.ts",
    "function_name": "anonymous",
    "start_line": 9,
    "end_line": 11,
    "language": "typescript",
    "chunk_type": "method"
  },
  {
    "content": "async getMeets(take: number, skip?: number): Promise<MeetDTO[]> {\r\n        try {\r\n            // ensure that take is no larger than 40\r\n            if (take > 40) {\r\n                take = 40;\r\n            }\r\n\r\n            //make fetch\r\n            const rawMeets = await this.meetsRepository.getMeets(take, skip);\r\n\r\n            //map to dto\r\n            const meetsDTO: MeetDTO[] = meetDTOFactory(rawMeets);\r\n\r\n            //return\r\n            return meetsDTO;\r\n\r\n        } catch (error) {\r\n            logError(\"Error in getMeets\", { error }, this.MODULE);\r\n            throw error;\r\n        }\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.ts",
    "function_name": "anonymous",
    "start_line": 13,
    "end_line": 33,
    "language": "typescript",
    "chunk_type": "method"
  },
  {
    "content": "const rawMeets = await this.meetsRepository.getMeets(take, skip);",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.ts",
    "function_name": "anonymous",
    "start_line": 21,
    "end_line": 21,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "const meetsDTO: MeetDTO[] = meetDTOFactory(rawMeets);",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.ts",
    "function_name": "anonymous",
    "start_line": 24,
    "end_line": 24,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "async getMeetById(meetId: string): Promise<MeetDTO | null> {\r\n        try {\r\n            //make fetch\r\n            const rawMeets = await this.meetsRepository.getMeetById(meetId);\r\n\r\n            if (!rawMeets) {\r\n                return null;\r\n            }\r\n\r\n            //map to dto\r\n            const meetsDTO: MeetDTO[] = meetDTOFactory([rawMeets]);\r\n\r\n            if (!meetsDTO || meetsDTO.length === 0) {\r\n                throw new Error(\"Mapped meet DTO is null or empty\");\r\n            }\r\n\r\n            //return\r\n            return meetsDTO[0];\r\n        } catch (error) {\r\n            logError(\"Error in getMeetById\", { error, meetId }, this.MODULE);\r\n            throw error;\r\n        }\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.ts",
    "function_name": "anonymous",
    "start_line": 35,
    "end_line": 57,
    "language": "typescript",
    "chunk_type": "method"
  },
  {
    "content": "const rawMeets = await this.meetsRepository.getMeetById(meetId);",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.ts",
    "function_name": "anonymous",
    "start_line": 38,
    "end_line": 38,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "const meetsDTO: MeetDTO[] = meetDTOFactory([rawMeets]);",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.ts",
    "function_name": "anonymous",
    "start_line": 45,
    "end_line": 45,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "function meetsUseCaseFactory() {\r\n    return new MeetsUseCase();\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\usecase\\meets\\MeetsUseCase.ts",
    "function_name": "meetsUseCaseFactory",
    "start_line": 60,
    "end_line": 62,
    "language": "typescript",
    "chunk_type": "function"
  },
  {
    "content": "const baseLogger = new Logger({\r\n    serviceName: 'StrideSyncAPI',\r\n    logLevel: (process.env.LOG_LEVEL as any) || 'INFO',\r\n    sampleRateValue: parseFloat(process.env.POWERTOOLS_LOGGER_SAMPLE_RATE || '0'),\r\n    persistentLogAttributes: {\r\n        environment: process.env.ENVIRONMENT || 'development',\r\n    },\r\n});",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\logger.ts",
    "function_name": "anonymous",
    "start_line": 4,
    "end_line": 11,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "type LogInput = {\r\n    message: string;\r\n    data: Record<string, unknown>;\r\n    module: string;\r\n};",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\logger.ts",
    "function_name": "LogInput",
    "start_line": 13,
    "end_line": 17,
    "language": "typescript",
    "chunk_type": "type"
  },
  {
    "content": "const logger = {\r\n    info: ({ message, data, module }: LogInput) => {\r\n        baseLogger.info(message, { module, ...data });\r\n    },\r\n    warn: ({ message, data, module }: LogInput) => {\r\n        baseLogger.warn(message, { module, ...data });\r\n    },\r\n    error: ({ message, data, module }: LogInput) => {\r\n        baseLogger.error(message, { module, ...data });\r\n    },\r\n};",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\logger.ts",
    "function_name": "anonymous",
    "start_line": 19,
    "end_line": 29,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "({ message, data, module }: LogInput) => {\r\n        baseLogger.info(message, { module, ...data });\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\logger.ts",
    "function_name": "anonymous",
    "start_line": 20,
    "end_line": 22,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "({ message, data, module }: LogInput) => {\r\n        baseLogger.warn(message, { module, ...data });\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\logger.ts",
    "function_name": "anonymous",
    "start_line": 23,
    "end_line": 25,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "({ message, data, module }: LogInput) => {\r\n        baseLogger.error(message, { module, ...data });\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\logger.ts",
    "function_name": "anonymous",
    "start_line": 26,
    "end_line": 28,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "function logInfo(message: string, data: Record<string, unknown> = {}, module = 'UnknownModule'): void {\r\n    logger.info({ message, data, module });\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\logger.ts",
    "function_name": "logInfo",
    "start_line": 31,
    "end_line": 33,
    "language": "typescript",
    "chunk_type": "function"
  },
  {
    "content": "function logWarn(message: string, data: Record<string, unknown> = {}, module = 'UnknownModule'): void {\r\n    logger.warn({ message, data, module });\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\logger.ts",
    "function_name": "logWarn",
    "start_line": 35,
    "end_line": 37,
    "language": "typescript",
    "chunk_type": "function"
  },
  {
    "content": "function logError(message: string, data: Record<string, unknown> = {}, module = 'UnknownModule'): void {\r\n    logger.error({ message, data, module });\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\logger.ts",
    "function_name": "logError",
    "start_line": 39,
    "end_line": 41,
    "language": "typescript",
    "chunk_type": "function"
  },
  {
    "content": "() => {\r\n    describe('validateMethod', () => {\r\n        it('returns 405 error when method is not allowed', () => {\r\n            const result = validateMethod(['GET', 'POST'], 'DELETE');\r\n            \r\n            expect(result).toEqual({\r\n                statusCode: 405,\r\n                headers: { \"Content-Type\": \"application/json\" },\r\n                body: JSON.stringify({ message: \"Method Not Allowed\" })\r\n            });\r\n        });\r\n\r\n        it('returns undefined when method is allowed', () => {\r\n            const result = validateMethod(['GET', 'POST'], 'GET');\r\n            expect(result).toBeUndefined();\r\n        });\r\n\r\n        it('is case-insensitive for allowed methods', () => {\r\n            const result = validateMethod(['get', 'post'], 'GET');\r\n            expect(result).toBeUndefined();\r\n        });\r\n\r\n        it('is case-insensitive for event method', () => {\r\n            const result = validateMethod(['GET', 'POST'], 'get');\r\n            expect(result).toBeUndefined();\r\n        });\r\n\r\n        it('handles mixed case in both parameters', () => {\r\n            const result = validateMethod(['GeT', 'PoSt'], 'gEt');\r\n            expect(result).toBeUndefined();\r\n        });\r\n\r\n        it('returns error for empty allowed methods array', () => {\r\n            const result = validateMethod([], 'GET');\r\n            \r\n            expect(result).toEqual({\r\n                statusCode: 405,\r\n                headers: { \"Content-Type\": \"application/json\" },\r\n                body: JSON.stringify({ message: \"Method Not Allowed\" })\r\n            });\r\n        });\r\n    });\r\n\r\n    describe('validateQueryParams', () => {\r\n        it('returns 400 error when required params are missing', () => {\r\n            const result = validateQueryParams(['id', 'name'], {});\r\n            \r\n            expect(result).toEqual({\r\n                statusCode: 400,\r\n                headers: { \"Content-Type\": \"application/json\" },\r\n                body: JSON.stringify({ \r\n                    message: \"The request was missing the following required parameters\", \r\n                    missingParams: ['id', 'name']\r\n                })\r\n            });\r\n        });\r\n\r\n        it('returns undefined when all required params are present', () => {\r\n            const result = validateQueryParams(['id', 'name'], { id: '123', name: 'test' });\r\n            expect(result).toBeUndefined();\r\n        });\r\n\r\n        it('is case-insensitive for parameter names', () => {\r\n            const result = validateQueryParams(['id', 'name'], { ID: '123', NAME: 'test' });\r\n            expect(result).toBeUndefined();\r\n        });\r\n\r\n        it('returns only missing parameters in error', () => {\r\n            const result = validateQueryParams(['id', 'name', 'email'], { id: '123' });\r\n            \r\n            expect(result).toEqual({\r\n                statusCode: 400,\r\n                headers: { \"Content-Type\": \"application/json\" },\r\n                body: JSON.stringify({ \r\n                    message: \"The request was missing the following required parameters\", \r\n                    missingParams: ['name', 'email']\r\n                })\r\n            });\r\n        });\r\n\r\n        it('handles empty required params array', () => {\r\n            const result = validateQueryParams([], { id: '123' });\r\n            expect(result).toBeUndefined();\r\n        });\r\n\r\n        it('validates with mixed case parameters', () => {\r\n            const result = validateQueryParams(['UserId', 'UserName'], { userid: '123', USERNAME: 'test' });\r\n            expect(result).toBeUndefined();\r\n        });\r\n\r\n        it('ignores extra parameters not in required list', () => {\r\n            const result = validateQueryParams(['id'], { id: '123', extra: 'value', another: 'param' });\r\n            expect(result).toBeUndefined();\r\n        });\r\n    });\r\n\r\n    describe('safeExractQueryParam', () => {\r\n        it('extracts parameter when present', () => {\r\n            const result = safeExractQueryParam('id', { id: '123' });\r\n            expect(result).toBe('123');\r\n        });\r\n\r\n        it('returns null when parameter is missing', () => {\r\n            const result = safeExractQueryParam('id', {});\r\n            expect(result).toBeNull();\r\n        });\r\n\r\n        it('is case-insensitive for parameter name', () => {\r\n            const result = safeExractQueryParam('id', { ID: '123' });\r\n            expect(result).toBe('123');\r\n        });\r\n\r\n        it('is case-insensitive for query params keys', () => {\r\n            const result = safeExractQueryParam('UserId', { userid: '123' });\r\n            expect(result).toBe('123');\r\n        });\r\n\r\n        it('handles mixed case in both parameters', () => {\r\n            const result = safeExractQueryParam('UserId', { USERID: '123' });\r\n            expect(result).toBe('123');\r\n        });\r\n\r\n        it('returns null for empty query params object', () => {\r\n            const result = safeExractQueryParam('id', {});\r\n            expect(result).toBeNull();\r\n        });\r\n\r\n        it('extracts correct value when multiple params present', () => {\r\n            const result = safeExractQueryParam('name', { id: '123', name: 'test', email: 'test@example.com' });\r\n            expect(result).toBe('test');\r\n        });\r\n\r\n        it('returns null for empty string values due to falsy check', () => {\r\n            const result = safeExractQueryParam('id', { id: '' });\r\n            expect(result).toBeNull();\r\n        });\r\n\r\n        it('returns null instead of empty string when param not found', () => {\r\n            const result = safeExractQueryParam('missing', { id: '123' });\r\n            expect(result).toBeNull();\r\n        });\r\n    });\r\n\r\n    describe('lambdaReturnSuccessfullResponse', () => {\r\n        it('returns 200 response with data wrapped in data property', () => {\r\n            const data = { id: '123', name: 'test' };\r\n            const result = lambdaReturnSuccessfullResponse(data);\r\n            \r\n            expect(result).toEqual({\r\n                statusCode: 200,\r\n                headers: { \"Content-Type\": \"application/json\" },\r\n                body: JSON.stringify({\r\n                    data: {\r\n                        id: '123',\r\n                        name: 'test'\r\n                    }\r\n                })\r\n            });\r\n        });\r\n\r\n        it('handles empty object', () => {\r\n            const result = lambdaReturnSuccessfullResponse({});\r\n            \r\n            expect(result).toEqual({\r\n                statusCode: 200,\r\n                headers: { \"Content-Type\": \"application/json\" },\r\n                body: JSON.stringify({\r\n                    data: {}\r\n                })\r\n            });\r\n        });\r\n\r\n        it('handles array data', () => {\r\n            const data = { items: [1, 2, 3] };\r\n            const result = lambdaReturnSuccessfullResponse(data);\r\n            \r\n            expect(result).toEqual({\r\n                statusCode: 200,\r\n                headers: { \"Content-Type\": \"application/json\" },\r\n                body: JSON.stringify({\r\n                    data: {\r\n                        items: [1, 2, 3]\r\n                    }\r\n                })\r\n            });\r\n        });\r\n\r\n        it('handles nested objects', () => {\r\n            const data = { user: { id: '123', profile: { name: 'test' } } };\r\n            const result = lambdaReturnSuccessfullResponse(data);\r\n            \r\n            expect(result).toEqual({\r\n                statusCode: 200,\r\n                headers: { \"Content-Type\": \"application/json\" },\r\n                body: JSON.stringify({\r\n                    data: {\r\n                        user: { id: '123', profile: { name: 'test' } }\r\n                    }\r\n                })\r\n            });\r\n        });\r\n\r\n        it('handles null values', () => {\r\n            const data = { value: null };\r\n            const result = lambdaReturnSuccessfullResponse(data);\r\n            \r\n            expect(result).toEqual({\r\n                statusCode: 200,\r\n                headers: { \"Content-Type\": \"application/json\" },\r\n                body: JSON.stringify({\r\n                    data: {\r\n                        value: null\r\n                    }\r\n                })\r\n            });\r\n        });\r\n\r\n        it('spreads data properties correctly', () => {\r\n            const data = { a: 1, b: 2, c: 3 };\r\n            const result = lambdaReturnSuccessfullResponse(data);\r\n            const parsed = JSON.parse(result.body);\r\n            \r\n            expect(parsed.data).toEqual({ a: 1, b: 2, c: 3 });\r\n        });\r\n    });\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 9,
    "end_line": 234,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => {\r\n        it('returns 405 error when method is not allowed', () => {\r\n            const result = validateMethod(['GET', 'POST'], 'DELETE');\r\n            \r\n            expect(result).toEqual({\r\n                statusCode: 405,\r\n                headers: { \"Content-Type\": \"application/json\" },\r\n                body: JSON.stringify({ message: \"Method Not Allowed\" })\r\n            });\r\n        });\r\n\r\n        it('returns undefined when method is allowed', () => {\r\n            const result = validateMethod(['GET', 'POST'], 'GET');\r\n            expect(result).toBeUndefined();\r\n        });\r\n\r\n        it('is case-insensitive for allowed methods', () => {\r\n            const result = validateMethod(['get', 'post'], 'GET');\r\n            expect(result).toBeUndefined();\r\n        });\r\n\r\n        it('is case-insensitive for event method', () => {\r\n            const result = validateMethod(['GET', 'POST'], 'get');\r\n            expect(result).toBeUndefined();\r\n        });\r\n\r\n        it('handles mixed case in both parameters', () => {\r\n            const result = validateMethod(['GeT', 'PoSt'], 'gEt');\r\n            expect(result).toBeUndefined();\r\n        });\r\n\r\n        it('returns error for empty allowed methods array', () => {\r\n            const result = validateMethod([], 'GET');\r\n            \r\n            expect(result).toEqual({\r\n                statusCode: 405,\r\n                headers: { \"Content-Type\": \"application/json\" },\r\n                body: JSON.stringify({ message: \"Method Not Allowed\" })\r\n            });\r\n        });\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 10,
    "end_line": 50,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => {\r\n            const result = validateMethod(['GET', 'POST'], 'DELETE');\r\n            \r\n            expect(result).toEqual({\r\n                statusCode: 405,\r\n                headers: { \"Content-Type\": \"application/json\" },\r\n                body: JSON.stringify({ message: \"Method Not Allowed\" })\r\n            });\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 11,
    "end_line": 19,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const result = validateMethod(['GET', 'POST'], 'DELETE');",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 12,
    "end_line": 12,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "() => {\r\n            const result = validateMethod(['GET', 'POST'], 'GET');\r\n            expect(result).toBeUndefined();\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 21,
    "end_line": 24,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const result = validateMethod(['GET', 'POST'], 'GET');",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 22,
    "end_line": 22,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "() => {\r\n            const result = validateMethod(['get', 'post'], 'GET');\r\n            expect(result).toBeUndefined();\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 26,
    "end_line": 29,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const result = validateMethod(['get', 'post'], 'GET');",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 27,
    "end_line": 27,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "() => {\r\n            const result = validateMethod(['GET', 'POST'], 'get');\r\n            expect(result).toBeUndefined();\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 31,
    "end_line": 34,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const result = validateMethod(['GET', 'POST'], 'get');",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 32,
    "end_line": 32,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "() => {\r\n            const result = validateMethod(['GeT', 'PoSt'], 'gEt');\r\n            expect(result).toBeUndefined();\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 36,
    "end_line": 39,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const result = validateMethod(['GeT', 'PoSt'], 'gEt');",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 37,
    "end_line": 37,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "() => {\r\n            const result = validateMethod([], 'GET');\r\n            \r\n            expect(result).toEqual({\r\n                statusCode: 405,\r\n                headers: { \"Content-Type\": \"application/json\" },\r\n                body: JSON.stringify({ message: \"Method Not Allowed\" })\r\n            });\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 41,
    "end_line": 49,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const result = validateMethod([], 'GET');",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 42,
    "end_line": 42,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "() => {\r\n        it('returns 400 error when required params are missing', () => {\r\n            const result = validateQueryParams(['id', 'name'], {});\r\n            \r\n            expect(result).toEqual({\r\n                statusCode: 400,\r\n                headers: { \"Content-Type\": \"application/json\" },\r\n                body: JSON.stringify({ \r\n                    message: \"The request was missing the following required parameters\", \r\n                    missingParams: ['id', 'name']\r\n                })\r\n            });\r\n        });\r\n\r\n        it('returns undefined when all required params are present', () => {\r\n            const result = validateQueryParams(['id', 'name'], { id: '123', name: 'test' });\r\n            expect(result).toBeUndefined();\r\n        });\r\n\r\n        it('is case-insensitive for parameter names', () => {\r\n            const result = validateQueryParams(['id', 'name'], { ID: '123', NAME: 'test' });\r\n            expect(result).toBeUndefined();\r\n        });\r\n\r\n        it('returns only missing parameters in error', () => {\r\n            const result = validateQueryParams(['id', 'name', 'email'], { id: '123' });\r\n            \r\n            expect(result).toEqual({\r\n                statusCode: 400,\r\n                headers: { \"Content-Type\": \"application/json\" },\r\n                body: JSON.stringify({ \r\n                    message: \"The request was missing the following required parameters\", \r\n                    missingParams: ['name', 'email']\r\n                })\r\n            });\r\n        });\r\n\r\n        it('handles empty required params array', () => {\r\n            const result = validateQueryParams([], { id: '123' });\r\n            expect(result).toBeUndefined();\r\n        });\r\n\r\n        it('validates with mixed case parameters', () => {\r\n            const result = validateQueryParams(['UserId', 'UserName'], { userid: '123', USERNAME: 'test' });\r\n            expect(result).toBeUndefined();\r\n        });\r\n\r\n        it('ignores extra parameters not in required list', () => {\r\n            const result = validateQueryParams(['id'], { id: '123', extra: 'value', another: 'param' });\r\n            expect(result).toBeUndefined();\r\n        });\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 52,
    "end_line": 103,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => {\r\n            const result = validateQueryParams(['id', 'name'], {});\r\n            \r\n            expect(result).toEqual({\r\n                statusCode: 400,\r\n                headers: { \"Content-Type\": \"application/json\" },\r\n                body: JSON.stringify({ \r\n                    message: \"The request was missing the following required parameters\", \r\n                    missingParams: ['id', 'name']\r\n                })\r\n            });\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 53,
    "end_line": 64,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const result = validateQueryParams(['id', 'name'], {});",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 54,
    "end_line": 54,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "() => {\r\n            const result = validateQueryParams(['id', 'name'], { id: '123', name: 'test' });\r\n            expect(result).toBeUndefined();\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 66,
    "end_line": 69,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const result = validateQueryParams(['id', 'name'], { id: '123', name: 'test' });",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 67,
    "end_line": 67,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "() => {\r\n            const result = validateQueryParams(['id', 'name'], { ID: '123', NAME: 'test' });\r\n            expect(result).toBeUndefined();\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 71,
    "end_line": 74,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const result = validateQueryParams(['id', 'name'], { ID: '123', NAME: 'test' });",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 72,
    "end_line": 72,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "() => {\r\n            const result = validateQueryParams(['id', 'name', 'email'], { id: '123' });\r\n            \r\n            expect(result).toEqual({\r\n                statusCode: 400,\r\n                headers: { \"Content-Type\": \"application/json\" },\r\n                body: JSON.stringify({ \r\n                    message: \"The request was missing the following required parameters\", \r\n                    missingParams: ['name', 'email']\r\n                })\r\n            });\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 76,
    "end_line": 87,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const result = validateQueryParams(['id', 'name', 'email'], { id: '123' });",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 77,
    "end_line": 77,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "() => {\r\n            const result = validateQueryParams([], { id: '123' });\r\n            expect(result).toBeUndefined();\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 89,
    "end_line": 92,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const result = validateQueryParams([], { id: '123' });",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 90,
    "end_line": 90,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "() => {\r\n            const result = validateQueryParams(['UserId', 'UserName'], { userid: '123', USERNAME: 'test' });\r\n            expect(result).toBeUndefined();\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 94,
    "end_line": 97,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const result = validateQueryParams(['UserId', 'UserName'], { userid: '123', USERNAME: 'test' });",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 95,
    "end_line": 95,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "() => {\r\n            const result = validateQueryParams(['id'], { id: '123', extra: 'value', another: 'param' });\r\n            expect(result).toBeUndefined();\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 99,
    "end_line": 102,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const result = validateQueryParams(['id'], { id: '123', extra: 'value', another: 'param' });",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 100,
    "end_line": 100,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "() => {\r\n        it('extracts parameter when present', () => {\r\n            const result = safeExractQueryParam('id', { id: '123' });\r\n            expect(result).toBe('123');\r\n        });\r\n\r\n        it('returns null when parameter is missing', () => {\r\n            const result = safeExractQueryParam('id', {});\r\n            expect(result).toBeNull();\r\n        });\r\n\r\n        it('is case-insensitive for parameter name', () => {\r\n            const result = safeExractQueryParam('id', { ID: '123' });\r\n            expect(result).toBe('123');\r\n        });\r\n\r\n        it('is case-insensitive for query params keys', () => {\r\n            const result = safeExractQueryParam('UserId', { userid: '123' });\r\n            expect(result).toBe('123');\r\n        });\r\n\r\n        it('handles mixed case in both parameters', () => {\r\n            const result = safeExractQueryParam('UserId', { USERID: '123' });\r\n            expect(result).toBe('123');\r\n        });\r\n\r\n        it('returns null for empty query params object', () => {\r\n            const result = safeExractQueryParam('id', {});\r\n            expect(result).toBeNull();\r\n        });\r\n\r\n        it('extracts correct value when multiple params present', () => {\r\n            const result = safeExractQueryParam('name', { id: '123', name: 'test', email: 'test@example.com' });\r\n            expect(result).toBe('test');\r\n        });\r\n\r\n        it('returns null for empty string values due to falsy check', () => {\r\n            const result = safeExractQueryParam('id', { id: '' });\r\n            expect(result).toBeNull();\r\n        });\r\n\r\n        it('returns null instead of empty string when param not found', () => {\r\n            const result = safeExractQueryParam('missing', { id: '123' });\r\n            expect(result).toBeNull();\r\n        });\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 105,
    "end_line": 150,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => {\r\n            const result = safeExractQueryParam('id', { id: '123' });\r\n            expect(result).toBe('123');\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 106,
    "end_line": 109,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const result = safeExractQueryParam('id', { id: '123' });",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 107,
    "end_line": 107,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "() => {\r\n            const result = safeExractQueryParam('id', {});\r\n            expect(result).toBeNull();\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 111,
    "end_line": 114,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const result = safeExractQueryParam('id', {});",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 112,
    "end_line": 112,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "() => {\r\n            const result = safeExractQueryParam('id', { ID: '123' });\r\n            expect(result).toBe('123');\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 116,
    "end_line": 119,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const result = safeExractQueryParam('id', { ID: '123' });",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 117,
    "end_line": 117,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "() => {\r\n            const result = safeExractQueryParam('UserId', { userid: '123' });\r\n            expect(result).toBe('123');\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 121,
    "end_line": 124,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const result = safeExractQueryParam('UserId', { userid: '123' });",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 122,
    "end_line": 122,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "() => {\r\n            const result = safeExractQueryParam('UserId', { USERID: '123' });\r\n            expect(result).toBe('123');\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 126,
    "end_line": 129,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const result = safeExractQueryParam('UserId', { USERID: '123' });",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 127,
    "end_line": 127,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "() => {\r\n            const result = safeExractQueryParam('id', {});\r\n            expect(result).toBeNull();\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 131,
    "end_line": 134,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const result = safeExractQueryParam('id', {});",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 132,
    "end_line": 132,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "() => {\r\n            const result = safeExractQueryParam('name', { id: '123', name: 'test', email: 'test@example.com' });\r\n            expect(result).toBe('test');\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 136,
    "end_line": 139,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const result = safeExractQueryParam('name', { id: '123', name: 'test', email: 'test@example.com' });",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 137,
    "end_line": 137,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "() => {\r\n            const result = safeExractQueryParam('id', { id: '' });\r\n            expect(result).toBeNull();\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 141,
    "end_line": 144,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const result = safeExractQueryParam('id', { id: '' });",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 142,
    "end_line": 142,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "() => {\r\n            const result = safeExractQueryParam('missing', { id: '123' });\r\n            expect(result).toBeNull();\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 146,
    "end_line": 149,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const result = safeExractQueryParam('missing', { id: '123' });",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 147,
    "end_line": 147,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "() => {\r\n        it('returns 200 response with data wrapped in data property', () => {\r\n            const data = { id: '123', name: 'test' };\r\n            const result = lambdaReturnSuccessfullResponse(data);\r\n            \r\n            expect(result).toEqual({\r\n                statusCode: 200,\r\n                headers: { \"Content-Type\": \"application/json\" },\r\n                body: JSON.stringify({\r\n                    data: {\r\n                        id: '123',\r\n                        name: 'test'\r\n                    }\r\n                })\r\n            });\r\n        });\r\n\r\n        it('handles empty object', () => {\r\n            const result = lambdaReturnSuccessfullResponse({});\r\n            \r\n            expect(result).toEqual({\r\n                statusCode: 200,\r\n                headers: { \"Content-Type\": \"application/json\" },\r\n                body: JSON.stringify({\r\n                    data: {}\r\n                })\r\n            });\r\n        });\r\n\r\n        it('handles array data', () => {\r\n            const data = { items: [1, 2, 3] };\r\n            const result = lambdaReturnSuccessfullResponse(data);\r\n            \r\n            expect(result).toEqual({\r\n                statusCode: 200,\r\n                headers: { \"Content-Type\": \"application/json\" },\r\n                body: JSON.stringify({\r\n                    data: {\r\n                        items: [1, 2, 3]\r\n                    }\r\n                })\r\n            });\r\n        });\r\n\r\n        it('handles nested objects', () => {\r\n            const data = { user: { id: '123', profile: { name: 'test' } } };\r\n            const result = lambdaReturnSuccessfullResponse(data);\r\n            \r\n            expect(result).toEqual({\r\n                statusCode: 200,\r\n                headers: { \"Content-Type\": \"application/json\" },\r\n                body: JSON.stringify({\r\n                    data: {\r\n                        user: { id: '123', profile: { name: 'test' } }\r\n                    }\r\n                })\r\n            });\r\n        });\r\n\r\n        it('handles null values', () => {\r\n            const data = { value: null };\r\n            const result = lambdaReturnSuccessfullResponse(data);\r\n            \r\n            expect(result).toEqual({\r\n                statusCode: 200,\r\n                headers: { \"Content-Type\": \"application/json\" },\r\n                body: JSON.stringify({\r\n                    data: {\r\n                        value: null\r\n                    }\r\n                })\r\n            });\r\n        });\r\n\r\n        it('spreads data properties correctly', () => {\r\n            const data = { a: 1, b: 2, c: 3 };\r\n            const result = lambdaReturnSuccessfullResponse(data);\r\n            const parsed = JSON.parse(result.body);\r\n            \r\n            expect(parsed.data).toEqual({ a: 1, b: 2, c: 3 });\r\n        });\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 152,
    "end_line": 233,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "() => {\r\n            const data = { id: '123', name: 'test' };\r\n            const result = lambdaReturnSuccessfullResponse(data);\r\n            \r\n            expect(result).toEqual({\r\n                statusCode: 200,\r\n                headers: { \"Content-Type\": \"application/json\" },\r\n                body: JSON.stringify({\r\n                    data: {\r\n                        id: '123',\r\n                        name: 'test'\r\n                    }\r\n                })\r\n            });\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 153,
    "end_line": 167,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const data = { id: '123', name: 'test' };",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 154,
    "end_line": 154,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "const result = lambdaReturnSuccessfullResponse(data);",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 155,
    "end_line": 155,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "() => {\r\n            const result = lambdaReturnSuccessfullResponse({});\r\n            \r\n            expect(result).toEqual({\r\n                statusCode: 200,\r\n                headers: { \"Content-Type\": \"application/json\" },\r\n                body: JSON.stringify({\r\n                    data: {}\r\n                })\r\n            });\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 169,
    "end_line": 179,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const result = lambdaReturnSuccessfullResponse({});",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 170,
    "end_line": 170,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "() => {\r\n            const data = { items: [1, 2, 3] };\r\n            const result = lambdaReturnSuccessfullResponse(data);\r\n            \r\n            expect(result).toEqual({\r\n                statusCode: 200,\r\n                headers: { \"Content-Type\": \"application/json\" },\r\n                body: JSON.stringify({\r\n                    data: {\r\n                        items: [1, 2, 3]\r\n                    }\r\n                })\r\n            });\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 181,
    "end_line": 194,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const data = { items: [1, 2, 3] };",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 182,
    "end_line": 182,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "const result = lambdaReturnSuccessfullResponse(data);",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 183,
    "end_line": 183,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "() => {\r\n            const data = { user: { id: '123', profile: { name: 'test' } } };\r\n            const result = lambdaReturnSuccessfullResponse(data);\r\n            \r\n            expect(result).toEqual({\r\n                statusCode: 200,\r\n                headers: { \"Content-Type\": \"application/json\" },\r\n                body: JSON.stringify({\r\n                    data: {\r\n                        user: { id: '123', profile: { name: 'test' } }\r\n                    }\r\n                })\r\n            });\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 196,
    "end_line": 209,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const data = { user: { id: '123', profile: { name: 'test' } } };",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 197,
    "end_line": 197,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "const result = lambdaReturnSuccessfullResponse(data);",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 198,
    "end_line": 198,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "() => {\r\n            const data = { value: null };\r\n            const result = lambdaReturnSuccessfullResponse(data);\r\n            \r\n            expect(result).toEqual({\r\n                statusCode: 200,\r\n                headers: { \"Content-Type\": \"application/json\" },\r\n                body: JSON.stringify({\r\n                    data: {\r\n                        value: null\r\n                    }\r\n                })\r\n            });\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 211,
    "end_line": 224,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const data = { value: null };",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 212,
    "end_line": 212,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "const result = lambdaReturnSuccessfullResponse(data);",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 213,
    "end_line": 213,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "() => {\r\n            const data = { a: 1, b: 2, c: 3 };\r\n            const result = lambdaReturnSuccessfullResponse(data);\r\n            const parsed = JSON.parse(result.body);\r\n            \r\n            expect(parsed.data).toEqual({ a: 1, b: 2, c: 3 });\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 226,
    "end_line": 232,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const data = { a: 1, b: 2, c: 3 };",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 227,
    "end_line": 227,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "const result = lambdaReturnSuccessfullResponse(data);",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 228,
    "end_line": 228,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "const parsed = JSON.parse(result.body);",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.test.ts",
    "function_name": "anonymous",
    "start_line": 229,
    "end_line": 229,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "const validateMethod = (allowedMehtods: string[], eventMethod: string): any => {\r\n    if (!allowedMehtods.some(method => method.toLocaleLowerCase() == eventMethod.toLowerCase())) {\r\n        return {\r\n            statusCode: 405,\r\n            headers: { \"Content-Type\": \"application/json\" },\r\n            body: JSON.stringify({ message: \"Method Not Allowed\" }),\r\n        }\r\n    } else { return }\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.ts",
    "function_name": "anonymous",
    "start_line": 3,
    "end_line": 11,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "(allowedMehtods: string[], eventMethod: string): any => {\r\n    if (!allowedMehtods.some(method => method.toLocaleLowerCase() == eventMethod.toLowerCase())) {\r\n        return {\r\n            statusCode: 405,\r\n            headers: { \"Content-Type\": \"application/json\" },\r\n            body: JSON.stringify({ message: \"Method Not Allowed\" }),\r\n        }\r\n    } else { return }\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.ts",
    "function_name": "anonymous",
    "start_line": 3,
    "end_line": 11,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "method => method.toLocaleLowerCase() == eventMethod.toLowerCase()",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.ts",
    "function_name": "method",
    "start_line": 4,
    "end_line": 4,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const validateQueryParams = (requiredParams: string[], eventQueryParams: Record<string, string>): any => {\r\n    const lowerParams = Object.keys(eventQueryParams).reduce((acc, key) => {\r\n        acc[key.toLowerCase()] = eventQueryParams[key];\r\n        return acc;\r\n    }, {} as Record<string, string>);\r\n    \r\n    const missingParams = requiredParams.filter(param => !(param.toLowerCase() in lowerParams))\r\n    \r\n    if (missingParams.length > 0) {\r\n        return {\r\n            statusCode: 400,\r\n            headers: { \"Content-Type\": \"application/json\" },\r\n            body: JSON.stringify({ \r\n                message: \"The request was missing the following required parameters\", \r\n                missingParams\r\n            }),\r\n        }\r\n    }\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.ts",
    "function_name": "anonymous",
    "start_line": 13,
    "end_line": 31,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "(requiredParams: string[], eventQueryParams: Record<string, string>): any => {\r\n    const lowerParams = Object.keys(eventQueryParams).reduce((acc, key) => {\r\n        acc[key.toLowerCase()] = eventQueryParams[key];\r\n        return acc;\r\n    }, {} as Record<string, string>);\r\n    \r\n    const missingParams = requiredParams.filter(param => !(param.toLowerCase() in lowerParams))\r\n    \r\n    if (missingParams.length > 0) {\r\n        return {\r\n            statusCode: 400,\r\n            headers: { \"Content-Type\": \"application/json\" },\r\n            body: JSON.stringify({ \r\n                message: \"The request was missing the following required parameters\", \r\n                missingParams\r\n            }),\r\n        }\r\n    }\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.ts",
    "function_name": "anonymous",
    "start_line": 13,
    "end_line": 31,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const lowerParams = Object.keys(eventQueryParams).reduce((acc, key) => {\r\n        acc[key.toLowerCase()] = eventQueryParams[key];\r\n        return acc;\r\n    }, {} as Record<string, string>);",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.ts",
    "function_name": "anonymous",
    "start_line": 14,
    "end_line": 17,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "(acc, key) => {\r\n        acc[key.toLowerCase()] = eventQueryParams[key];\r\n        return acc;\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.ts",
    "function_name": "anonymous",
    "start_line": 14,
    "end_line": 17,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const missingParams = requiredParams.filter(param => !(param.toLowerCase() in lowerParams))",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.ts",
    "function_name": "anonymous",
    "start_line": 19,
    "end_line": 19,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "param => !(param.toLowerCase() in lowerParams)",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.ts",
    "function_name": "param",
    "start_line": 19,
    "end_line": 19,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const safeExractQueryParam = (paramName: string, eventQueryParams: Record<string, string>): string | null => {\r\n    const lowerParams = Object.keys(eventQueryParams).reduce((acc, key) => {\r\n        acc[key.toLowerCase()] = eventQueryParams[key];\r\n        return acc;\r\n    }, {} as Record<string, string>);\r\n    return lowerParams[paramName.toLowerCase()] || null;\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.ts",
    "function_name": "anonymous",
    "start_line": 33,
    "end_line": 39,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "(paramName: string, eventQueryParams: Record<string, string>): string | null => {\r\n    const lowerParams = Object.keys(eventQueryParams).reduce((acc, key) => {\r\n        acc[key.toLowerCase()] = eventQueryParams[key];\r\n        return acc;\r\n    }, {} as Record<string, string>);\r\n    return lowerParams[paramName.toLowerCase()] || null;\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.ts",
    "function_name": "anonymous",
    "start_line": 33,
    "end_line": 39,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const lowerParams = Object.keys(eventQueryParams).reduce((acc, key) => {\r\n        acc[key.toLowerCase()] = eventQueryParams[key];\r\n        return acc;\r\n    }, {} as Record<string, string>);",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.ts",
    "function_name": "anonymous",
    "start_line": 34,
    "end_line": 37,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "(acc, key) => {\r\n        acc[key.toLowerCase()] = eventQueryParams[key];\r\n        return acc;\r\n    }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.ts",
    "function_name": "anonymous",
    "start_line": 34,
    "end_line": 37,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "const lambdaReturnSuccessfullResponse = (data: any): any => {\r\n    return {\r\n        statusCode: 200,\r\n        headers: { \"Content-Type\": \"application/json\" },\r\n        body: JSON.stringify({\r\n            data: {\r\n                ...data\r\n            }\r\n        }),\r\n    }\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.ts",
    "function_name": "anonymous",
    "start_line": 41,
    "end_line": 51,
    "language": "typescript",
    "chunk_type": "variable"
  },
  {
    "content": "(data: any): any => {\r\n    return {\r\n        statusCode: 200,\r\n        headers: { \"Content-Type\": \"application/json\" },\r\n        body: JSON.stringify({\r\n            data: {\r\n                ...data\r\n            }\r\n        }),\r\n    }\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPI\\src\\util\\lambda\\lambdaValidation.ts",
    "function_name": "anonymous",
    "start_line": 41,
    "end_line": 51,
    "language": "typescript",
    "chunk_type": "arrow_function"
  },
  {
    "content": "func handler(ctx context.Context, request events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {\r\n\r\n\tutil.LogInfo(\"Incoming request\", map[string]interface{}{\r\n\t\t\"path\":      request.Path,\r\n\t\t\"method\":    request.HTTPMethod,\r\n\t\t\"requestId\": request.RequestContext.RequestID,\r\n\t}, \"MainHandler\")\r\n\r\n\tvar routeHandler func(context.Context, events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error)\r\n\r\n\tswitch request.Path {\r\n\tcase \"/meets\":\r\n\t\trouteHandler = handlers.MeetsHandler\r\n\tcase \"/meet-info\":\r\n\t\trouteHandler = handlers.MeetInfoHandler\r\n\tdefault:\r\n\t\treturn events.APIGatewayProxyResponse{\r\n\t\t\tStatusCode: 404,\r\n\t\t\tHeaders:    map[string]string{\"Content-Type\": \"application/json\"},\r\n\t\t\tBody:       `{\"message\":\"Route Not Found\"}`,\r\n\t\t}, nil\r\n\t}\r\n\r\n\treturn routeHandler(ctx, request)\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\main.go",
    "function_name": "handler",
    "start_line": 12,
    "end_line": 36,
    "language": "go",
    "chunk_type": "function"
  },
  {
    "content": "func main() {\r\n\tlambda.Start(handler)\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\main.go",
    "function_name": "main",
    "start_line": 38,
    "end_line": 40,
    "language": "go",
    "chunk_type": "function"
  },
  {
    "content": "func main() {\r\n\t// Load .env file for local development\r\n\tif err := godotenv.Load(); err != nil {\r\n\t\tlog.Println(\"Warning: .env file not found, using system environment variables\")\r\n\t}\r\n\thttp.HandleFunc(\"/meets\", func(w http.ResponseWriter, r *http.Request) {\r\n\t\tctx := r.Context()\r\n\t\ttake := r.URL.Query().Get(\"take\")\r\n\t\tskip := r.URL.Query().Get(\"skip\")\r\n\r\n\t\ttakeInt := 10\r\n\t\tskipInt := 0\r\n\r\n\t\tif t, err := strconv.Atoi(take); err == nil {\r\n\t\t\ttakeInt = t\r\n\t\t}\r\n\t\tif s, err := strconv.Atoi(skip); err == nil {\r\n\t\t\tskipInt = s\r\n\t\t}\r\n\r\n\t\t// Convert to APIGatewayProxyRequest format\r\n\t\treq := events.APIGatewayProxyRequest{\r\n\t\t\tHTTPMethod: r.Method,\r\n\t\t\tPath:       \"/meets\",\r\n\t\t\tQueryStringParameters: map[string]string{\r\n\t\t\t\t\"take\": strconv.Itoa(takeInt),\r\n\t\t\t\t\"skip\": strconv.Itoa(skipInt),\r\n\t\t\t},\r\n\t\t}\r\n\r\n\t\tresp, err := handlers.MeetsHandler(ctx, req)\r\n\t\tif err != nil {\r\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\r\n\t\t\tjson.NewEncoder(w).Encode(map[string]string{\"error\": err.Error()})\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\r\n\t\tw.WriteHeader(resp.StatusCode)\r\n\t\tw.Write([]byte(resp.Body))\r\n\t})\r\n\thttp.HandleFunc(\"/meet-info\", func(w http.ResponseWriter, r *http.Request) {\r\n\t\tctx := r.Context()\r\n\t\tmeetId := r.URL.Query().Get(\"meetId\")\r\n\t\tif meetId == \"\" {\r\n\t\t\tw.WriteHeader(http.StatusBadRequest)\r\n\t\t\tjson.NewEncoder(w).Encode(map[string]string{\"error\": \"Missing 'meetId' query parameter\"})\r\n\t\t\treturn\r\n\t\t}\r\n\t\t// Convert to APIGatewayProxyRequest format\r\n\t\treq := events.APIGatewayProxyRequest{\r\n\t\t\tHTTPMethod: r.Method,\r\n\t\t\tPath:       \"/meet-info\",\r\n\t\t\tQueryStringParameters: map[string]string{\r\n\t\t\t\t\"meetId\": meetId,\r\n\t\t\t},\r\n\t\t}\r\n\t\tresp, err := handlers.MeetInfoHandler(ctx, req)\r\n\t\tif err != nil {\r\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\r\n\t\t\tjson.NewEncoder(w).Encode(map[string]string{\"error\": err.Error()})\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\r\n\t\tw.WriteHeader(resp.StatusCode)\r\n\t\tw.Write([]byte(resp.Body))\r\n\t})\r\n\r\n\tlog.Println(\"Local server running on http://localhost:8080\")\r\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\cmd\\server.go",
    "function_name": "main",
    "start_line": 14,
    "end_line": 85,
    "language": "go",
    "chunk_type": "function"
  },
  {
    "content": "func MeetsHandler(ctx context.Context, request events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {\r\n\t// Log incoming request\r\n\tutil.LogInfo(\"MeetsHandler called\", map[string]interface{}{\r\n\t\t\"method\": request.HTTPMethod,\r\n\t\t\"path\":   request.Path,\r\n\t}, \"MeetsHandler\")\r\n\r\n\t// validate method is a GET\r\n\tif methodErr := lambda.ValidateHTTPMethod([]string{\"GET\"}, request.HTTPMethod); methodErr != nil {\r\n\t\treturn *methodErr, nil\r\n\t}\r\n\r\n\t// get Query Params\r\n\tqueryParams := request.QueryStringParameters\r\n\ttakeRaw := queryParams[\"take\"]\r\n\tskipRaw := queryParams[\"skip\"]\r\n\r\n\t//default to 20, max 40\r\n\ttakeActual := 20\r\n\tif takeRaw != \"\" {\r\n\t\ttakeParsed, err := lambda.ParsePositiveInt(takeRaw)\r\n\t\tif err != nil {\r\n\t\t\treturn lambda.BuildFailedHTTPResponse(400, `{\"message\":\"Invalid 'take' query parameter\"}`), nil\r\n\t\t}\r\n\t\tif takeParsed > 40 {\r\n\t\t\ttakeParsed = 40\r\n\t\t}\r\n\t\ttakeActual = takeParsed\r\n\t}\r\n\r\n\t// default to undefined for skipActual\r\n\tvar skipActual *int\r\n\tif skipRaw != \"\" {\r\n\t\tskipParsed, err := lambda.ParsePositiveInt(skipRaw)\r\n\t\tif err != nil {\r\n\t\t\treturn lambda.BuildFailedHTTPResponse(400, `{\"message\":\"Invalid 'skip' query parameter\"}`), nil\r\n\t\t}\r\n\t\tskipActual = &skipParsed\r\n\t}\r\n\r\n\t// Initialize usecase\r\n\tmeetsUseCase, err := meets_usecase.NewMeetsUseCase()\r\n\tif err != nil {\r\n\t\tutil.LogError(\"Error creating MeetsUseCase\", map[string]interface{}{\"error\": err}, \"MeetsHandler\")\r\n\t\treturn events.APIGatewayProxyResponse{\r\n\t\t\tStatusCode: 500,\r\n\t\t\tHeaders:    map[string]string{\"Content-Type\": \"application/json\"},\r\n\t\t\tBody:       `{\"message\":\"Internal Server Error\"}`,\r\n\t\t}, err\r\n\t}\r\n\r\n\t// Call usecase to get meets\r\n\tmeets, err := meetsUseCase.GetMeets(ctx, takeActual, skipActual)\r\n\tif err != nil {\r\n\t\tutil.LogError(\"Error in meetsHandler\", map[string]interface{}{\"error\": err}, \"MeetsHandler\")\r\n\t\treturn events.APIGatewayProxyResponse{\r\n\t\t\tStatusCode: 500,\r\n\t\t\tHeaders:    map[string]string{\"Content-Type\": \"application/json\"},\r\n\t\t\tBody:       `{\"message\":\"There was an internal server error while processing the meets request\"}`,\r\n\t\t}, err\r\n\t}\r\n\r\n\t// Build successful response\r\n\tresponseData := map[string]interface{}{\r\n\t\t\"data\": map[string]interface{}{\r\n\t\t\t\"meets\": meets,\r\n\t\t},\r\n\t}\r\n\r\n\tbody, err := json.Marshal(responseData)\r\n\tif err != nil {\r\n\t\tutil.LogError(\"Error marshaling response\", map[string]interface{}{\"error\": err}, \"MeetsHandler\")\r\n\t\treturn events.APIGatewayProxyResponse{\r\n\t\t\tStatusCode: 500,\r\n\t\t\tHeaders:    map[string]string{\"Content-Type\": \"application/json\"},\r\n\t\t\tBody:       `{\"message\":\"Internal Server Error\"}`,\r\n\t\t}, err\r\n\t}\r\n\r\n\treturn events.APIGatewayProxyResponse{\r\n\t\tStatusCode: 200,\r\n\t\tHeaders:    map[string]string{\"Content-Type\": \"application/json\"},\r\n\t\tBody:       string(body),\r\n\t}, nil\r\n\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\src\\handlers\\meets_handler.go",
    "function_name": "MeetsHandler",
    "start_line": 14,
    "end_line": 99,
    "language": "go",
    "chunk_type": "function"
  },
  {
    "content": "func MeetInfoHandler(ctx context.Context, request events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {\r\n\tutil.LogInfo(\"MeetInfoHandler called\", map[string]interface{}{\r\n\t\t\"method\": request.HTTPMethod,\r\n\t\t\"path\":   request.Path,\r\n\t}, \"MeetInfoHandler\")\r\n\r\n\t// validate method is a GET\r\n\tif methodErr := lambda.ValidateHTTPMethod([]string{\"GET\"}, request.HTTPMethod); methodErr != nil {\r\n\t\treturn *methodErr, nil\r\n\t}\r\n\r\n\t// Get Query Params\r\n\tqueryParams := request.QueryStringParameters\r\n\tmeetId := queryParams[\"meetId\"]\r\n\r\n\tif meetId == \"\" {\r\n\t\treturn lambda.BuildFailedHTTPResponse(400, `{\"message\":\"Missing 'meetId' query parameter\"}`), nil\r\n\t}\r\n\r\n\t// Initialize usecase\r\n\tmeetsUseCase, err := meets_usecase.NewMeetsUseCase()\r\n\tif err != nil {\r\n\t\tutil.LogError(\"Error creating MeetsUseCase\", map[string]interface{}{\"error\": err}, \"MeetsHandler\")\r\n\t\treturn events.APIGatewayProxyResponse{\r\n\t\t\tStatusCode: 500,\r\n\t\t\tHeaders:    map[string]string{\"Content-Type\": \"application/json\"},\r\n\t\t\tBody:       `{\"message\":\"Internal Server Error\"}`,\r\n\t\t}, err\r\n\t}\r\n\r\n\tmeet, err := meetsUseCase.GetMeetById(ctx, meetId)\r\n\tif err != nil {\r\n\t\tutil.LogError(\"Error in GetMeetById\", map[string]interface{}{\"error\": err, \"meetId\": meetId}, \"MeetInfoHandler\")\r\n\t\treturn events.APIGatewayProxyResponse{\r\n\t\t\tStatusCode: 500,\r\n\t\t\tHeaders:    map[string]string{\"Content-Type\": \"application/json\"},\r\n\t\t\tBody:       `{\"message\":\"Internal Server Error\"}`,\r\n\t\t}, err\r\n\t}\r\n\r\n\tresponseData := map[string]interface{}{\r\n\t\t\"data\": map[string]interface{}{\r\n\t\t\t\"meet\": meet,\r\n\t\t},\r\n\t}\r\n\r\n\tbody, err := json.Marshal(responseData)\r\n\tif err != nil {\r\n\t\tutil.LogError(\"Error marshaling response\", map[string]interface{}{\"error\": err}, \"MeetsHandler\")\r\n\t\treturn events.APIGatewayProxyResponse{\r\n\t\t\tStatusCode: 500,\r\n\t\t\tHeaders:    map[string]string{\"Content-Type\": \"application/json\"},\r\n\t\t\tBody:       `{\"message\":\"Internal Server Error\"}`,\r\n\t\t}, err\r\n\t}\r\n\r\n\treturn events.APIGatewayProxyResponse{\r\n\t\tStatusCode: 200,\r\n\t\tHeaders:    map[string]string{\"Content-Type\": \"application/json\"},\r\n\t\tBody:       string(body),\r\n\t}, nil\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\src\\handlers\\meet_info_handler.go",
    "function_name": "MeetInfoHandler",
    "start_line": 13,
    "end_line": 74,
    "language": "go",
    "chunk_type": "function"
  },
  {
    "content": "type MeetsRepository struct {\r\n\tmongoRepo               *MongoDBRepository\r\n\tcache                   *services.CacheService\r\n\tcollection              string\r\n\tmeetsCacheTTLSeconds    int\r\n\tmeetByIDCacheTTLSeconds int\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\src\\repositories\\meets_repository.go",
    "function_name": "anonymous",
    "start_line": 16,
    "end_line": 22,
    "language": "go",
    "chunk_type": "type"
  },
  {
    "content": "func NewMeetsRepository() (*MeetsRepository, error) {\r\n\tmongoRepo, err := NewMongoDBRepository()\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn &MeetsRepository{\r\n\t\tmongoRepo:               mongoRepo,\r\n\t\tcache:                   services.GetCacheServiceInstance(),\r\n\t\tcollection:              \"meets\",\r\n\t\tmeetsCacheTTLSeconds:    300, // 5 minutes\r\n\t\tmeetByIDCacheTTLSeconds: 300, // 5 minutes\r\n\t}, nil\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\src\\repositories\\meets_repository.go",
    "function_name": "NewMeetsRepository",
    "start_line": 24,
    "end_line": 37,
    "language": "go",
    "chunk_type": "function"
  },
  {
    "content": "func (r *MeetsRepository) GetMeets(\r\n\tctx context.Context,\r\n\ttake int,\r\n\tskip *int,\r\n\tdisableCache bool,\r\n) ([]meet_repo.MeetRepo, error) {\r\n\tutil.LogInfo(\"Fetching meets\", map[string]interface{}{\r\n\t\t\"take\":         take,\r\n\t\t\"skip\":         skip,\r\n\t\t\"disableCache\": disableCache,\r\n\t}, MEETS_REPOSITORY_MODULE)\r\n\r\n\tskipValue := 0\r\n\tif skip != nil {\r\n\t\tskipValue = *skip\r\n\t}\r\n\r\n\tcacheKey := r.cache.BuildCacheKey(\"meets\", map[string]interface{}{\r\n\t\t\"take\": take,\r\n\t\t\"skip\": skipValue,\r\n\t})\r\n\r\n\tif !disableCache {\r\n\t\tif cached, found := r.cache.Get(cacheKey); found {\r\n\t\t\tif meets, ok := cached.([]meet_repo.MeetRepo); ok {\r\n\t\t\t\treturn meets, nil\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tlimit := int64(take)\r\n\tskipInt64 := int64(skipValue)\r\n\r\n\tresults, err := r.mongoRepo.Fetch(ctx, r.collection, bson.M{}, &FetchOptions{\r\n\t\tLimit: &limit,\r\n\t\tSkip:  &skipInt64,\r\n\t})\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\tmeets := make([]meet_repo.MeetRepo, 0, len(results))\r\n\tfor _, result := range results {\r\n\t\tvar meet meet_repo.MeetRepo\r\n\t\tbsonBytes, err := bson.Marshal(result)\r\n\t\tif err != nil {\r\n\t\t\treturn nil, fmt.Errorf(\"failed to marshal result: %w\", err)\r\n\t\t}\r\n\t\tif err := bson.Unmarshal(bsonBytes, &meet); err != nil {\r\n\t\t\treturn nil, fmt.Errorf(\"failed to unmarshal meet: %w\", err)\r\n\t\t}\r\n\t\tmeets = append(meets, meet)\r\n\t}\r\n\r\n\tif !disableCache {\r\n\t\tr.cache.Set(cacheKey, meets, r.meetsCacheTTLSeconds)\r\n\t}\r\n\r\n\treturn meets, nil\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\src\\repositories\\meets_repository.go",
    "function_name": "GetMeets",
    "start_line": 39,
    "end_line": 98,
    "language": "go",
    "chunk_type": "method"
  },
  {
    "content": "func (r *MeetsRepository) GetMeetById(\r\n\tctx context.Context,\r\n\tmeetId string,\r\n\tdisableCache bool,\r\n) (*meet_repo.MeetRepo, error) {\r\n\tutil.LogInfo(\"Fetching meet by ID\", map[string]interface{}{\r\n\t\t\"meetId\":       meetId,\r\n\t\t\"disableCache\": disableCache,\r\n\t}, MEETS_REPOSITORY_MODULE)\r\n\r\n\tcacheKey := r.cache.BuildCacheKey(\"meet\", map[string]interface{}{\r\n\t\t\"id\": meetId,\r\n\t})\r\n\r\n\tif !disableCache {\r\n\t\tif cached, found := r.cache.Get(cacheKey); found {\r\n\t\t\tif meet, ok := cached.(*meet_repo.MeetRepo); ok {\r\n\t\t\t\treturn meet, nil\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tobjectId, err := primitive.ObjectIDFromHex(meetId)\r\n\tif err != nil {\r\n\t\treturn nil, fmt.Errorf(\"invalid meet ID: %w\", err)\r\n\t}\r\n\r\n\tlimit := int64(1)\r\n\tresults, err := r.mongoRepo.Fetch(ctx, r.collection, bson.M{\r\n\t\t\"_id\": objectId,\r\n\t}, &FetchOptions{\r\n\t\tLimit: &limit,\r\n\t})\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\tif len(results) == 0 {\r\n\t\treturn nil, nil\r\n\t}\r\n\r\n\tvar meet meet_repo.MeetRepo\r\n\tbsonBytes, err := bson.Marshal(results[0])\r\n\tif err != nil {\r\n\t\treturn nil, fmt.Errorf(\"failed to marshal result: %w\", err)\r\n\t}\r\n\tif err := bson.Unmarshal(bsonBytes, &meet); err != nil {\r\n\t\treturn nil, fmt.Errorf(\"failed to unmarshal meet: %w\", err)\r\n\t}\r\n\r\n\tif !disableCache {\r\n\t\tr.cache.Set(cacheKey, &meet, r.meetByIDCacheTTLSeconds)\r\n\t}\r\n\r\n\treturn &meet, nil\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\src\\repositories\\meets_repository.go",
    "function_name": "GetMeetById",
    "start_line": 100,
    "end_line": 155,
    "language": "go",
    "chunk_type": "method"
  },
  {
    "content": "type MongoDBRepository struct {\r\n\tclient           *mongo.Client\r\n\tdb               *mongo.Database\r\n\tconnectionString string\r\n\tdatabaseName     string\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\src\\repositories\\mongodb_repository.go",
    "function_name": "anonymous",
    "start_line": 16,
    "end_line": 21,
    "language": "go",
    "chunk_type": "type"
  },
  {
    "content": "func NewMongoDBRepository() (*MongoDBRepository, error) {\r\n\tconnectionString, err := repo.CreateRepoConnectionString()\r\n\tdatabaseName, err2 := repo.GetDatabaseName()\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\tif err2 != nil {\r\n\t\treturn nil, err2\r\n\t}\r\n\treturn &MongoDBRepository{\r\n\t\tconnectionString: connectionString,\r\n\t\tdatabaseName:     databaseName,\r\n\t}, nil\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\src\\repositories\\mongodb_repository.go",
    "function_name": "NewMongoDBRepository",
    "start_line": 23,
    "end_line": 36,
    "language": "go",
    "chunk_type": "function"
  },
  {
    "content": "func (r *MongoDBRepository) isConnectionOpen() bool {\r\n\treturn r.client != nil && r.db != nil\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\src\\repositories\\mongodb_repository.go",
    "function_name": "isConnectionOpen",
    "start_line": 38,
    "end_line": 40,
    "language": "go",
    "chunk_type": "method"
  },
  {
    "content": "func (r *MongoDBRepository) ensureConnection(ctx context.Context) error {\r\n\tif !r.isConnectionOpen() {\r\n\t\tutil.LogInfo(\"Establishing MongoDB connection\", map[string]interface{}{}, MODULE)\r\n\t\treturn r.Connect(ctx)\r\n\t}\r\n\treturn nil\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\src\\repositories\\mongodb_repository.go",
    "function_name": "ensureConnection",
    "start_line": 42,
    "end_line": 48,
    "language": "go",
    "chunk_type": "method"
  },
  {
    "content": "func (r *MongoDBRepository) Connect(ctx context.Context) error {\r\n\tif r.client != nil {\r\n\t\treturn nil\r\n\t}\r\n\r\n\tclientOptions := options.Client().ApplyURI(r.connectionString)\r\n\tclient, err := mongo.Connect(ctx, clientOptions)\r\n\tif err != nil {\r\n\t\treturn fmt.Errorf(\"failed to connect to MongoDB: %w\", err)\r\n\t}\r\n\r\n\t// Ping the database to verify connection\r\n\tif err := client.Ping(ctx, nil); err != nil {\r\n\t\treturn fmt.Errorf(\"failed to ping MongoDB: %w\", err)\r\n\t}\r\n\r\n\tr.client = client\r\n\tr.db = client.Database(r.databaseName)\r\n\treturn nil\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\src\\repositories\\mongodb_repository.go",
    "function_name": "Connect",
    "start_line": 50,
    "end_line": 69,
    "language": "go",
    "chunk_type": "method"
  },
  {
    "content": "func (r *MongoDBRepository) Disconnect(ctx context.Context) error {\r\n\tif r.client != nil {\r\n\t\tif err := r.client.Disconnect(ctx); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tr.client = nil\r\n\t\tr.db = nil\r\n\t}\r\n\treturn nil\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\src\\repositories\\mongodb_repository.go",
    "function_name": "Disconnect",
    "start_line": 71,
    "end_line": 80,
    "language": "go",
    "chunk_type": "method"
  },
  {
    "content": "type FetchOptions struct {\r\n\tLimit *int64\r\n\tSkip  *int64\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\src\\repositories\\mongodb_repository.go",
    "function_name": "anonymous",
    "start_line": 82,
    "end_line": 85,
    "language": "go",
    "chunk_type": "type"
  },
  {
    "content": "func (r *MongoDBRepository) Fetch(\r\n\tctx context.Context,\r\n\tcollectionName string,\r\n\tquery bson.M,\r\n\topts *FetchOptions,\r\n) ([]bson.M, error) {\r\n\tif err := r.ensureConnection(ctx); err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\tif r.db == nil {\r\n\t\treturn nil, fmt.Errorf(\"database connection is not established\")\r\n\t}\r\n\r\n\tutil.LogInfo(\"Fetching data from MongoDB\", map[string]interface{}{\r\n\t\t\"collection\": collectionName,\r\n\t\t\"query\":      query,\r\n\t\t\"options\":    opts,\r\n\t}, MODULE)\r\n\r\n\tcollection := r.db.Collection(collectionName)\r\n\tfindOptions := options.Find()\r\n\r\n\tif opts != nil {\r\n\t\tif opts.Skip != nil {\r\n\t\t\tfindOptions.SetSkip(*opts.Skip)\r\n\t\t}\r\n\t\tif opts.Limit != nil {\r\n\t\t\tfindOptions.SetLimit(*opts.Limit)\r\n\t\t}\r\n\t}\r\n\r\n\tcursor, err := collection.Find(ctx, query, findOptions)\r\n\tif err != nil {\r\n\t\treturn nil, fmt.Errorf(\"failed to execute find query: %w\", err)\r\n\t}\r\n\tdefer cursor.Close(ctx)\r\n\r\n\tvar results []bson.M\r\n\tif err := cursor.All(ctx, &results); err != nil {\r\n\t\treturn nil, fmt.Errorf(\"failed to decode results: %w\", err)\r\n\t}\r\n\r\n\treturn results, nil\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\src\\repositories\\mongodb_repository.go",
    "function_name": "Fetch",
    "start_line": 87,
    "end_line": 131,
    "language": "go",
    "chunk_type": "method"
  },
  {
    "content": "type CacheEntry struct {\r\n\tData      interface{}\r\n\tExpiresAt time.Time\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\src\\services\\cache_service.go",
    "function_name": "anonymous",
    "start_line": 11,
    "end_line": 14,
    "language": "go",
    "chunk_type": "type"
  },
  {
    "content": "type CacheConfig struct {\r\n\tMaxEntries        int\r\n\tDefaultTTLSeconds int\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\src\\services\\cache_service.go",
    "function_name": "anonymous",
    "start_line": 16,
    "end_line": 19,
    "language": "go",
    "chunk_type": "type"
  },
  {
    "content": "type CacheService struct {\r\n\tcache  map[string]*CacheEntry\r\n\tconfig CacheConfig\r\n\tmu     sync.RWMutex // Thread-safe operations\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\src\\services\\cache_service.go",
    "function_name": "anonymous",
    "start_line": 31,
    "end_line": 35,
    "language": "go",
    "chunk_type": "type"
  },
  {
    "content": "func NewCacheService() *CacheService {\r\n\treturn &CacheService{\r\n\t\tcache:  make(map[string]*CacheEntry),\r\n\t\tconfig: defaultConfig,\r\n\t}\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\src\\services\\cache_service.go",
    "function_name": "NewCacheService",
    "start_line": 38,
    "end_line": 43,
    "language": "go",
    "chunk_type": "function"
  },
  {
    "content": "func GetCacheServiceInstance(config ...CacheConfig) *CacheService {\r\n\tonce.Do(func() {\r\n\t\tcfg := defaultConfig\r\n\t\tif len(config) > 0 {\r\n\t\t\tcfg = config[0]\r\n\t\t}\r\n\t\tinstance = &CacheService{\r\n\t\t\tcache:  make(map[string]*CacheEntry),\r\n\t\t\tconfig: cfg,\r\n\t\t}\r\n\t})\r\n\treturn instance\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\src\\services\\cache_service.go",
    "function_name": "GetCacheServiceInstance",
    "start_line": 46,
    "end_line": 58,
    "language": "go",
    "chunk_type": "function"
  },
  {
    "content": "func (cs *CacheService) BuildCacheKey(cacheType string, paramsForKey map[string]interface{}) string {\r\n\t// Sort keys for consistent ordering\r\n\tkeys := make([]string, 0, len(paramsForKey))\r\n\tfor k := range paramsForKey {\r\n\t\tkeys = append(keys, k)\r\n\t}\r\n\tsort.Strings(keys)\r\n\r\n\tparts := make([]string, 0, len(paramsForKey))\r\n\tfor _, k := range keys {\r\n\t\tparts = append(parts, fmt.Sprintf(\"%s:%v\", k, paramsForKey[k]))\r\n\t}\r\n\r\n\treturn fmt.Sprintf(\"%s:%s\", cacheType, strings.Join(parts, \"|\"))\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\src\\services\\cache_service.go",
    "function_name": "BuildCacheKey",
    "start_line": 61,
    "end_line": 75,
    "language": "go",
    "chunk_type": "method"
  },
  {
    "content": "func (cs *CacheService) Get(key string) (interface{}, bool) {\r\n\tcs.mu.Lock()\r\n\tdefer cs.mu.Unlock()\r\n\r\n\tentry, exists := cs.cache[key]\r\n\tif !exists {\r\n\t\treturn nil, false\r\n\t}\r\n\r\n\t// Check if expired\r\n\tif time.Now().After(entry.ExpiresAt) {\r\n\t\tdelete(cs.cache, key)\r\n\t\treturn nil, false\r\n\t}\r\n\r\n\t// LRU: Move to end (most recently used) by recreating\r\n\t// In Go, we simulate this by deleting and re-adding\r\n\tdelete(cs.cache, key)\r\n\tcs.cache[key] = entry\r\n\r\n\treturn entry.Data, true\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\src\\services\\cache_service.go",
    "function_name": "Get",
    "start_line": 78,
    "end_line": 99,
    "language": "go",
    "chunk_type": "method"
  },
  {
    "content": "func (cs *CacheService) Set(key string, data interface{}, ttlSeconds ...int) {\r\n\tcs.mu.Lock()\r\n\tdefer cs.mu.Unlock()\r\n\r\n\t// If key exists, delete first (for LRU ordering)\r\n\tif _, exists := cs.cache[key]; exists {\r\n\t\tdelete(cs.cache, key)\r\n\t}\r\n\r\n\t// Evict oldest entries if at capacity\r\n\tfor len(cs.cache) >= cs.config.MaxEntries {\r\n\t\t// Get first key (oldest in insertion order - Go 1.12+ maintains insertion order)\r\n\t\tfor oldestKey := range cs.cache {\r\n\t\t\tdelete(cs.cache, oldestKey)\r\n\t\t\tbreak\r\n\t\t}\r\n\t}\r\n\r\n\tttl := cs.config.DefaultTTLSeconds\r\n\tif len(ttlSeconds) > 0 {\r\n\t\tttl = ttlSeconds[0]\r\n\t}\r\n\r\n\tcs.cache[key] = &CacheEntry{\r\n\t\tData:      data,\r\n\t\tExpiresAt: time.Now().Add(time.Duration(ttl) * time.Second),\r\n\t}\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\src\\services\\cache_service.go",
    "function_name": "Set",
    "start_line": 102,
    "end_line": 129,
    "language": "go",
    "chunk_type": "method"
  },
  {
    "content": "func (cs *CacheService) Delete(key string) {\r\n\tcs.mu.Lock()\r\n\tdefer cs.mu.Unlock()\r\n\tdelete(cs.cache, key)\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\src\\services\\cache_service.go",
    "function_name": "Delete",
    "start_line": 132,
    "end_line": 136,
    "language": "go",
    "chunk_type": "method"
  },
  {
    "content": "func (cs *CacheService) Clear() {\r\n\tcs.mu.Lock()\r\n\tdefer cs.mu.Unlock()\r\n\tcs.cache = make(map[string]*CacheEntry)\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\src\\services\\cache_service.go",
    "function_name": "Clear",
    "start_line": 139,
    "end_line": 143,
    "language": "go",
    "chunk_type": "method"
  },
  {
    "content": "func (cs *CacheService) Prune() int {\r\n\tcs.mu.Lock()\r\n\tdefer cs.mu.Unlock()\r\n\r\n\tnow := time.Now()\r\n\tpruned := 0\r\n\r\n\tfor key, entry := range cs.cache {\r\n\t\tif now.After(entry.ExpiresAt) {\r\n\t\t\tdelete(cs.cache, key)\r\n\t\t\tpruned++\r\n\t\t}\r\n\t}\r\n\r\n\treturn pruned\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\src\\services\\cache_service.go",
    "function_name": "Prune",
    "start_line": 146,
    "end_line": 161,
    "language": "go",
    "chunk_type": "method"
  },
  {
    "content": "func (cs *CacheService) Stats() map[string]int {\r\n\tcs.mu.RLock()\r\n\tdefer cs.mu.RUnlock()\r\n\r\n\treturn map[string]int{\r\n\t\t\"size\":       len(cs.cache),\r\n\t\t\"maxEntries\": cs.config.MaxEntries,\r\n\t}\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\src\\services\\cache_service.go",
    "function_name": "Stats",
    "start_line": 164,
    "end_line": 172,
    "language": "go",
    "chunk_type": "method"
  },
  {
    "content": "type MeetDTO struct {\r\n\tId       string          `json:\"id\"`\r\n\tName     string          `json:\"name\"`\r\n\tLocation MeetLocationDTO `json:\"location\"`\r\n\tDates    MeetDateDTO     `json:\"dates\"`\r\n\tSource   MeetSourceDTO   `json:\"source\"`\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\src\\types\\meets\\dto\\meet.go",
    "function_name": "anonymous",
    "start_line": 5,
    "end_line": 11,
    "language": "go",
    "chunk_type": "type"
  },
  {
    "content": "type MeetLocationDTO struct {\r\n\tAddress   string  `json:\"address\"`\r\n\tCity      string  `json:\"city\"`\r\n\tState     string  `json:\"state\"`\r\n\tLatitude  float64 `json:\"latitude\"`\r\n\tLongitude float64 `json:\"longitude\"`\r\n\tLocation  string  `json:\"location\"`\r\n\tHostedBy  string  `json:\"hosted_by\"`\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\src\\types\\meets\\dto\\meet.go",
    "function_name": "anonymous",
    "start_line": 13,
    "end_line": 21,
    "language": "go",
    "chunk_type": "type"
  },
  {
    "content": "type MeetDateDTO struct {\r\n\tStartDate    string `json:\"start_date\"`\r\n\tEndDate      string `json:\"end_date\"`\r\n\tReportedDate string `json:\"reported_date\"`\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\src\\types\\meets\\dto\\meet.go",
    "function_name": "anonymous",
    "start_line": 23,
    "end_line": 27,
    "language": "go",
    "chunk_type": "type"
  },
  {
    "content": "type MeetSourceDTO struct {\r\n\tSource      string  `json:\"source\"`\r\n\tMeetLink    string  `json:\"meet_link\"`\r\n\tResultsLink *string `json:\"results_link\"`\r\n\tLogoLink    string  `json:\"logo_link\"`\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\src\\types\\meets\\dto\\meet.go",
    "function_name": "anonymous",
    "start_line": 29,
    "end_line": 34,
    "language": "go",
    "chunk_type": "type"
  },
  {
    "content": "func MeetDTOFactory(meetsRaw []meet_repo.MeetRepo) []MeetDTO {\r\n\tmeets := make([]MeetDTO, len(meetsRaw))\r\n\tfor i, meetRaw := range meetsRaw {\r\n\t\tmeets[i] = MeetDTO{\r\n\t\t\tId:   meetRaw.ID,\r\n\t\t\tName: meetRaw.MeetName,\r\n\t\t\tLocation: MeetLocationDTO{\r\n\t\t\t\tAddress:   meetRaw.Address,\r\n\t\t\t\tCity:      meetRaw.City,\r\n\t\t\t\tState:     meetRaw.State,\r\n\t\t\t\tLatitude:  meetRaw.Latitude,\r\n\t\t\t\tLongitude: meetRaw.Longitude,\r\n\t\t\t\tLocation:  meetRaw.Location,\r\n\t\t\t\tHostedBy:  meetRaw.HostedBy,\r\n\t\t\t},\r\n\t\t\tDates: MeetDateDTO{\r\n\t\t\t\tStartDate:    meetRaw.StartDate,\r\n\t\t\t\tEndDate:      meetRaw.EndDate,\r\n\t\t\t\tReportedDate: meetRaw.ReportedDate,\r\n\t\t\t},\r\n\t\t\tSource: MeetSourceDTO{\r\n\t\t\t\tSource:      meetRaw.Source,\r\n\t\t\t\tMeetLink:    meetRaw.MeetLink,\r\n\t\t\t\tResultsLink: meetRaw.ResultsLink,\r\n\t\t\t\tLogoLink:    meetRaw.LogoLink,\r\n\t\t\t},\r\n\t\t}\r\n\t}\r\n\treturn meets\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\src\\types\\meets\\dto\\meet.go",
    "function_name": "MeetDTOFactory",
    "start_line": 36,
    "end_line": 65,
    "language": "go",
    "chunk_type": "function"
  },
  {
    "content": "type MeetRepo struct {\r\n\tID           string   `bson:\"_id\"`\r\n\tMatchKey     string   `bson:\"match_key\"`\r\n\tAddress      string   `bson:\"address\"`\r\n\tCity         string   `bson:\"city\"`\r\n\tCreatedAt    string   `bson:\"created_at\"`\r\n\tEndDate      string   `bson:\"end_date\"`\r\n\tFirstSeenAt  string   `bson:\"first_seen_at\"`\r\n\tHostedBy     string   `bson:\"hosted_by\"`\r\n\tLatitude     float64  `bson:\"latitude\"`\r\n\tLocation     string   `bson:\"location\"`\r\n\tLogoLink     string   `bson:\"logo_link\"`\r\n\tLongitude    float64  `bson:\"longitude\"`\r\n\tMeetLink     string   `bson:\"meet_link\"`\r\n\tMeetName     string   `bson:\"meet_name\"`\r\n\tReportedDate string   `bson:\"reported_date\"`\r\n\tResultsLink  *string  `bson:\"results_link\"`\r\n\tSource       string   `bson:\"source\"`\r\n\tSources      []string `bson:\"sources\"`\r\n\tStartDate    string   `bson:\"start_date\"`\r\n\tState        string   `bson:\"state\"`\r\n\tUpdatedAt    string   `bson:\"updated_at\"`\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\src\\types\\meets\\repository\\meet.go",
    "function_name": "anonymous",
    "start_line": 3,
    "end_line": 25,
    "language": "go",
    "chunk_type": "type"
  },
  {
    "content": "type MeetsUseCase struct {\r\n\tmeetsRepository *repositories.MeetsRepository\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\src\\usecase\\meets\\meets_usecase.go",
    "function_name": "anonymous",
    "start_line": 15,
    "end_line": 17,
    "language": "go",
    "chunk_type": "type"
  },
  {
    "content": "func NewMeetsUseCase() (*MeetsUseCase, error) {\r\n\trepo, err := repositories.NewMeetsRepository()\r\n\tif err != nil {\r\n\t\treturn nil, fmt.Errorf(\"failed to create meets repository: %w\", err)\r\n\t}\r\n\r\n\treturn &MeetsUseCase{\r\n\t\tmeetsRepository: repo,\r\n\t}, nil\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\src\\usecase\\meets\\meets_usecase.go",
    "function_name": "NewMeetsUseCase",
    "start_line": 19,
    "end_line": 28,
    "language": "go",
    "chunk_type": "function"
  },
  {
    "content": "func (uc *MeetsUseCase) GetMeets(ctx context.Context, take int, skip *int) ([]meet_dto.MeetDTO, error) {\r\n\t// ensure that take is no larger than 40\r\n\tif take > 40 {\r\n\t\ttake = 40\r\n\t}\r\n\r\n\t// make fetch\r\n\trawMeets, err := uc.meetsRepository.GetMeets(ctx, take, skip, false)\r\n\tif err != nil {\r\n\t\tutil.LogError(\"Error in GetMeets\", map[string]interface{}{\"error\": err}, MODULE)\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\t// map to dto\r\n\tmeetsDTO := meet_dto.MeetDTOFactory(rawMeets)\r\n\r\n\treturn meetsDTO, nil\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\src\\usecase\\meets\\meets_usecase.go",
    "function_name": "GetMeets",
    "start_line": 30,
    "end_line": 47,
    "language": "go",
    "chunk_type": "method"
  },
  {
    "content": "func (uc *MeetsUseCase) GetMeetById(ctx context.Context, meetId string) (*meet_dto.MeetDTO, error) {\r\n\t// make fetch\r\n\trawMeet, err := uc.meetsRepository.GetMeetById(ctx, meetId, false)\r\n\tif err != nil {\r\n\t\tutil.LogError(\"Error in GetMeetById\", map[string]interface{}{\"error\": err, \"meetId\": meetId}, MODULE)\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\tif rawMeet == nil {\r\n\t\treturn nil, nil\r\n\t}\r\n\r\n\t// map to dto\r\n\tmeetsDTO := meet_dto.MeetDTOFactory([]meet_repo.MeetRepo{*rawMeet})\r\n\r\n\tif len(meetsDTO) == 0 {\r\n\t\terr := fmt.Errorf(\"mapped meet DTO is empty\")\r\n\t\tutil.LogError(\"Error in GetMeetById\", map[string]interface{}{\"error\": err, \"meetId\": meetId}, MODULE)\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn &meetsDTO[0], nil\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\src\\usecase\\meets\\meets_usecase.go",
    "function_name": "GetMeetById",
    "start_line": 49,
    "end_line": 71,
    "language": "go",
    "chunk_type": "method"
  },
  {
    "content": "func InitLogger(serviceName string) {\r\n\tenvironment := os.Getenv(\"ENVIRONMENT\")\r\n\tif environment == \"\" {\r\n\t\tenvironment = \"development\"\r\n\t}\r\n\r\n\tlogLevel := os.Getenv(\"LOG_LEVEL\")\r\n\tvar level slog.Level\r\n\tswitch logLevel {\r\n\tcase \"DEBUG\":\r\n\t\tlevel = slog.LevelDebug\r\n\tcase \"WARN\":\r\n\t\tlevel = slog.LevelWarn\r\n\tcase \"ERROR\":\r\n\t\tlevel = slog.LevelError\r\n\tdefault:\r\n\t\tlevel = slog.LevelInfo\r\n\t}\r\n\r\n\t// JSON handler for structured logging (Lambda CloudWatch friendly)\r\n\thandler := slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{\r\n\t\tLevel: level,\r\n\t})\r\n\r\n\tloggerInstance = slog.New(handler).With(\r\n\t\t\"service\", serviceName,\r\n\t\t\"environment\", environment,\r\n\t)\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\src\\util\\logger.go",
    "function_name": "InitLogger",
    "start_line": 10,
    "end_line": 38,
    "language": "go",
    "chunk_type": "function"
  },
  {
    "content": "func getLogger() *slog.Logger {\r\n\tif loggerInstance == nil {\r\n\t\tInitLogger(\"StrideSyncAPI\")\r\n\t}\r\n\treturn loggerInstance\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\src\\util\\logger.go",
    "function_name": "getLogger",
    "start_line": 40,
    "end_line": 45,
    "language": "go",
    "chunk_type": "function"
  },
  {
    "content": "func LogInfo(message string, data map[string]interface{}, module string) {\r\n\tattrs := buildAttrs(data, module)\r\n\tgetLogger().Info(message, attrs...)\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\src\\util\\logger.go",
    "function_name": "LogInfo",
    "start_line": 48,
    "end_line": 51,
    "language": "go",
    "chunk_type": "function"
  },
  {
    "content": "func LogWarn(message string, data map[string]interface{}, module string) {\r\n\tattrs := buildAttrs(data, module)\r\n\tgetLogger().Warn(message, attrs...)\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\src\\util\\logger.go",
    "function_name": "LogWarn",
    "start_line": 53,
    "end_line": 56,
    "language": "go",
    "chunk_type": "function"
  },
  {
    "content": "func LogError(message string, data map[string]interface{}, module string) {\r\n\tattrs := buildAttrs(data, module)\r\n\tgetLogger().Error(message, attrs...)\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\src\\util\\logger.go",
    "function_name": "LogError",
    "start_line": 58,
    "end_line": 61,
    "language": "go",
    "chunk_type": "function"
  },
  {
    "content": "func buildAttrs(data map[string]interface{}, module string) []any {\r\n\tattrs := []any{\"module\", module}\r\n\tfor k, v := range data {\r\n\t\tattrs = append(attrs, k, v)\r\n\t}\r\n\treturn attrs\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\src\\util\\logger.go",
    "function_name": "buildAttrs",
    "start_line": 63,
    "end_line": 69,
    "language": "go",
    "chunk_type": "function"
  },
  {
    "content": "func ValidateHTTPMethod(allowedMethods []string, eventMethod string) *events.APIGatewayProxyResponse {\r\n\tfor _, method := range allowedMethods {\r\n\t\tif strings.EqualFold(method, eventMethod) {\r\n\t\t\treturn nil\r\n\t\t}\r\n\t}\r\n\r\n\t// Here when we use & we are saying return the value at that memory address.\r\n\t// So we return the actual response instead of a pointer to the response.\r\n\tresponse := BuildFailedHTTPResponse(405, `{\"message\":\"Method Not Allowed\"}`)\r\n\treturn &response\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\src\\util\\lambda\\lambda_request.go",
    "function_name": "ValidateHTTPMethod",
    "start_line": 13,
    "end_line": 24,
    "language": "go",
    "chunk_type": "function"
  },
  {
    "content": "func ParsePositiveInt(s string) (int, error) {\r\n\tval, err := strconv.Atoi(s)\r\n\tif err != nil {\r\n\t\treturn 0, err\r\n\t}\r\n\tif val <= 0 {\r\n\t\treturn 0, err\r\n\t}\r\n\treturn val, nil\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\src\\util\\lambda\\lambda_request.go",
    "function_name": "ParsePositiveInt",
    "start_line": 26,
    "end_line": 35,
    "language": "go",
    "chunk_type": "function"
  },
  {
    "content": "func BuildFailedHTTPResponse(statusCode int, body string) events.APIGatewayProxyResponse {\r\n\treturn events.APIGatewayProxyResponse{\r\n\t\tStatusCode: statusCode,\r\n\t\tHeaders:    map[string]string{\"Content-Type\": \"application/json\"},\r\n\t\tBody:       body,\r\n\t}\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\src\\util\\lambda\\lambda_response.go",
    "function_name": "BuildFailedHTTPResponse",
    "start_line": 5,
    "end_line": 11,
    "language": "go",
    "chunk_type": "function"
  },
  {
    "content": "func BuildSuccessHTTPResponse(body string) events.APIGatewayProxyResponse {\r\n\treturn events.APIGatewayProxyResponse{\r\n\t\tStatusCode: 200,\r\n\t\tHeaders:    map[string]string{\"Content-Type\": \"application/json\"},\r\n\t\tBody:       body,\r\n\t}\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\src\\util\\lambda\\lambda_response.go",
    "function_name": "BuildSuccessHTTPResponse",
    "start_line": 13,
    "end_line": 19,
    "language": "go",
    "chunk_type": "function"
  },
  {
    "content": "func CreateRepoConnectionString() (string, error) {\r\n\thost := os.Getenv(\"MONGODB_HOST\")\r\n\tport := os.Getenv(\"MONGODB_PORT\")\r\n\tusername := os.Getenv(\"MONGODB_USERNAME\")\r\n\tpassword := os.Getenv(\"MONGODB_PASSWORD\")\r\n\tdatabase := os.Getenv(\"MONGODB_DATABASE\")\r\n\r\n\tif host == \"\" || port == \"\" || username == \"\" || password == \"\" || database == \"\" {\r\n\t\treturn \"\", errors.New(\"missing required MongoDB connection environment variables\")\r\n\t}\r\n\r\n\treturn \"mongodb://\" + username + \":\" + password + \"@\" + host + \":\" + port + \"/\" + database, nil\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\src\\util\\repo\\connection.go",
    "function_name": "CreateRepoConnectionString",
    "start_line": 8,
    "end_line": 20,
    "language": "go",
    "chunk_type": "function"
  },
  {
    "content": "func GetDatabaseName() (string, error) {\r\n\tdatabase := os.Getenv(\"MONGODB_DATABASE\")\r\n\r\n\tif database == \"\" {\r\n\t\treturn \"\", errors.New(\"missing required MongoDB database environment variable\")\r\n\t}\r\n\r\n\treturn database, nil\r\n}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncAPIGO\\src\\util\\repo\\connection.go",
    "function_name": "GetDatabaseName",
    "start_line": 22,
    "end_line": 30,
    "language": "go",
    "chunk_type": "function"
  },
  {
    "content": "def handler(event, context):\r\n    \"\"\"\r\n    AWS Lambda handler function.\r\n    \r\n    Args:\r\n        event: Lambda event object (from EventBridge scheduled trigger)\r\n        context: Lambda context object with runtime information\r\n        \r\n    Returns:\r\n        dict: Response with status code and execution details\r\n    \"\"\"\r\n    log_info(\r\n        \"Lambda function invoked\",\r\n        module=MODULE,\r\n        data={\r\n            \"request_id\": context.aws_request_id,\r\n            \"function_name\": context.function_name,\r\n            \"memory_limit\": context.memory_limit_in_mb,\r\n            \"event\": event\r\n        }\r\n    )\r\n    \r\n    try:\r\n        # Execute the main scraping logic\r\n        main()\r\n        \r\n        log_info(\r\n            \"Lambda function completed successfully\",\r\n            module=MODULE,\r\n            data={\"request_id\": context.aws_request_id}\r\n        )\r\n        \r\n        return {\r\n            \"statusCode\": 200,\r\n            \"body\": json.dumps({\r\n                \"message\": \"Scraping completed successfully\",\r\n                \"request_id\": context.aws_request_id\r\n            })\r\n        }\r\n        \r\n    except Exception as e:\r\n        log_error(\r\n            \"Lambda function failed\",\r\n            module=MODULE,\r\n            data={\r\n                \"request_id\": context.aws_request_id,\r\n                \"error\": str(e),\r\n                \"error_type\": type(e).__name__\r\n            }\r\n        )\r\n        \r\n        # Re-raise the exception so Lambda marks the invocation as failed\r\n        raise",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\lambda_handler.py",
    "function_name": "handler",
    "start_line": 14,
    "end_line": 66,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "def main():\r\n    # Initialize and validate config vars\r\n    try:\r\n        config_vars = ConfigVars()\r\n        log_info(\"Config vars loaded successfully\", module=MODULE, data={})\r\n    except Exception as e:\r\n        log_error(\"Failed to load config vars\", module=MODULE, data={\"error\": str(e)})\r\n        return\r\n    \r\n    # exit()\r\n    \r\n    scraping_strategies = [\r\n        TffrsStrategy(config_vars),\r\n    ]\r\n    \r\n    for strategy in scraping_strategies:\r\n        log_info(\"Starting scraping strategy: \" + strategy.strategy_name, module=MODULE, data={})\r\n        \r\n        strategy.scrape()\r\n        \r\n        strategy.close_strategy()",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\main.py",
    "function_name": "main",
    "start_line": 8,
    "end_line": 28,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "class DatabaseRepo:\r\n    def __init__(self, config_vars: ConfigVars):\r\n        # MongoDB Atlas requires mongodb+srv:// protocol (SRV format)\r\n        # Port is not specified in SRV connection strings as it's automatically determined\r\n        uri = f\"mongodb+srv://{config_vars.mongodb_username}:{config_vars.mongodb_password}@{config_vars.mongodb_host}/{config_vars.mongodb_database}?retryWrites=true&w=majority\"\r\n        logger.info(f\"Connecting to MongoDB at {config_vars.mongodb_host}\")\r\n        self.client = MongoClient(uri)\r\n        self.db = self.client[config_vars.mongodb_database]\r\n        logger.info(f\"Successfully connected to database: {config_vars.mongodb_database}\")\r\n\r\n    def ensure_index(self, collection: str, keys: Union[str, List[tuple]], unique: bool = False, **kwargs) -> str:\r\n        \"\"\"\r\n        Ensure an index exists on a collection. Idempotent \u2014 if the index\r\n        already exists, this is a no-op.\r\n\r\n        Args:\r\n            collection: Collection name\r\n            keys: A single field name (str) for a simple ascending index,\r\n                  or a list of (field, direction) tuples for compound indexes.\r\n                  Example: \"athlete_id\" or [(\"athlete_id\", ASCENDING)]\r\n            unique: Whether the index should enforce uniqueness\r\n            **kwargs: Extra arguments forwarded to create_index (e.g. name, sparse)\r\n\r\n        Returns:\r\n            The name of the created (or existing) index.\r\n        \"\"\"\r\n        if isinstance(keys, str):\r\n            keys = [(keys, ASCENDING)]\r\n        index_name = self.db[collection].create_index(keys, unique=unique, **kwargs)\r\n        logger.debug(f\"Ensured index '{index_name}' on {collection}\")\r\n        return index_name\r\n\r\n    def insert_one(self, collection: str, document: dict):\r\n        self.db[collection].insert_one(document)\r\n\r\n    def insert_many(self, collection: str, documents: list[dict]):\r\n        self.db[collection].insert_many(documents)\r\n    \r\n    def upsert_one(self, collection: str, filter: Dict[str, Any], document: dict) -> bool:\r\n        \"\"\"\r\n        Upsert a single document using the provided filter.\r\n        \r\n        Args:\r\n            collection: Collection name\r\n            filter: MongoDB filter to find existing document\r\n            document: Document to insert or update\r\n            \r\n        Returns:\r\n            True if document was inserted (new), False if updated (existing)\r\n        \"\"\"\r\n        result = self.db[collection].update_one(\r\n            filter,\r\n            {\"$set\": document},\r\n            upsert=True\r\n        )\r\n        # If upserted_id exists, it was inserted (new document)\r\n        # If matched_count > 0, it was updated (existing document)\r\n        return result.upserted_id is not None\r\n    \r\n    def find_one(self, collection: str, filter: Dict[str, Any]) -> Dict[str, Any] | None:\r\n        \"\"\"\r\n        Find a single document matching the filter.\r\n        \r\n        Args:\r\n            collection: Collection name\r\n            filter: MongoDB filter query\r\n            \r\n        Returns:\r\n            Document if found, None otherwise\r\n        \"\"\"\r\n        return self.db[collection].find_one(filter)\r\n    \r\n    def bulk_upsert(self, collection: str, operations: List[Dict[str, Any]], chunk_size: int = 1000) -> Dict[str, Any]:\r\n        \"\"\"\r\n        Perform bulk upsert operations in chunks for better performance.\r\n        \r\n        Args:\r\n            collection: Collection name\r\n            operations: List of operations, each containing 'filter' and 'document' keys\r\n            chunk_size: Number of operations to process per chunk (default: 1000)\r\n            \r\n        Returns:\r\n            Dictionary with statistics: {'inserted': count, 'updated': count, 'matched': count}\r\n        \"\"\"\r\n        from pymongo import UpdateOne\r\n        \r\n        if not operations:\r\n            return {'inserted': 0, 'updated': 0, 'matched': 0}\r\n        \r\n        total_inserted = 0\r\n        total_updated = 0\r\n        total_matched = 0\r\n        num_chunks = (len(operations) + chunk_size - 1) // chunk_size\r\n        \r\n        logger.debug(f\"Processing {len(operations)} operations in {num_chunks} chunk(s) of {chunk_size}\")\r\n        \r\n        # Process in chunks\r\n        for i in range(0, len(operations), chunk_size):\r\n            chunk = operations[i:i + chunk_size]\r\n            bulk_ops = []\r\n            \r\n            for op in chunk:\r\n                bulk_ops.append(\r\n                    UpdateOne(\r\n                        op['filter'],\r\n                        {\"$set\": op['document']},\r\n                        upsert=True\r\n                    )\r\n                )\r\n            \r\n            # Use ordered=False for better parallelization\r\n            result = self.db[collection].bulk_write(bulk_ops, ordered=False)\r\n            \r\n            total_inserted += result.upserted_count\r\n            total_updated += result.modified_count\r\n            total_matched += result.matched_count\r\n        \r\n        return {\r\n            'inserted': total_inserted,\r\n            'updated': total_updated,\r\n            'matched': total_matched\r\n        }\r\n\r\n    def bulk_write_operations(self, collection: str, operations: List[UpdateOne], chunk_size: int = 2000) -> Dict[str, Any]:\r\n        \"\"\"\r\n        Execute pre-built UpdateOne (or other) operations via bulk_write.\r\n        Unlike bulk_upsert(), this accepts raw pymongo operation objects,\r\n        allowing callers to use aggregation-pipeline updates.\r\n\r\n        Args:\r\n            collection: Collection name\r\n            operations: List of pymongo WriteOperation objects (e.g. UpdateOne)\r\n            chunk_size: Number of operations per bulk_write call (default: 2000)\r\n\r\n        Returns:\r\n            Dictionary with statistics: {'inserted': count, 'updated': count, 'matched': count}\r\n        \"\"\"\r\n        if not operations:\r\n            return {'inserted': 0, 'updated': 0, 'matched': 0}\r\n\r\n        total_inserted = 0\r\n        total_updated = 0\r\n        total_matched = 0\r\n        num_chunks = (len(operations) + chunk_size - 1) // chunk_size\r\n\r\n        logger.debug(f\"Processing {len(operations)} operations in {num_chunks} chunk(s) of {chunk_size}\")\r\n\r\n        for i in range(0, len(operations), chunk_size):\r\n            chunk = operations[i:i + chunk_size]\r\n            result = self.db[collection].bulk_write(chunk, ordered=False)\r\n\r\n            total_inserted += result.upserted_count\r\n            total_updated += result.modified_count\r\n            total_matched += result.matched_count\r\n\r\n        return {\r\n            'inserted': total_inserted,\r\n            'updated': total_updated,\r\n            'matched': total_matched\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\database\\db_repo.py",
    "function_name": "DatabaseRepo",
    "start_line": 10,
    "end_line": 169,
    "language": "python",
    "chunk_type": "class"
  },
  {
    "content": "def __init__(self, config_vars: ConfigVars):\r\n        # MongoDB Atlas requires mongodb+srv:// protocol (SRV format)\r\n        # Port is not specified in SRV connection strings as it's automatically determined\r\n        uri = f\"mongodb+srv://{config_vars.mongodb_username}:{config_vars.mongodb_password}@{config_vars.mongodb_host}/{config_vars.mongodb_database}?retryWrites=true&w=majority\"\r\n        logger.info(f\"Connecting to MongoDB at {config_vars.mongodb_host}\")\r\n        self.client = MongoClient(uri)\r\n        self.db = self.client[config_vars.mongodb_database]\r\n        logger.info(f\"Successfully connected to database: {config_vars.mongodb_database}\")",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\database\\db_repo.py",
    "function_name": "__init__",
    "start_line": 11,
    "end_line": 18,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "def ensure_index(self, collection: str, keys: Union[str, List[tuple]], unique: bool = False, **kwargs) -> str:\r\n        \"\"\"\r\n        Ensure an index exists on a collection. Idempotent \u2014 if the index\r\n        already exists, this is a no-op.\r\n\r\n        Args:\r\n            collection: Collection name\r\n            keys: A single field name (str) for a simple ascending index,\r\n                  or a list of (field, direction) tuples for compound indexes.\r\n                  Example: \"athlete_id\" or [(\"athlete_id\", ASCENDING)]\r\n            unique: Whether the index should enforce uniqueness\r\n            **kwargs: Extra arguments forwarded to create_index (e.g. name, sparse)\r\n\r\n        Returns:\r\n            The name of the created (or existing) index.\r\n        \"\"\"\r\n        if isinstance(keys, str):\r\n            keys = [(keys, ASCENDING)]\r\n        index_name = self.db[collection].create_index(keys, unique=unique, **kwargs)\r\n        logger.debug(f\"Ensured index '{index_name}' on {collection}\")\r\n        return index_name",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\database\\db_repo.py",
    "function_name": "ensure_index",
    "start_line": 20,
    "end_line": 40,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "def insert_one(self, collection: str, document: dict):\r\n        self.db[collection].insert_one(document)",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\database\\db_repo.py",
    "function_name": "insert_one",
    "start_line": 42,
    "end_line": 43,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "def insert_many(self, collection: str, documents: list[dict]):\r\n        self.db[collection].insert_many(documents)",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\database\\db_repo.py",
    "function_name": "insert_many",
    "start_line": 45,
    "end_line": 46,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "def upsert_one(self, collection: str, filter: Dict[str, Any], document: dict) -> bool:\r\n        \"\"\"\r\n        Upsert a single document using the provided filter.\r\n        \r\n        Args:\r\n            collection: Collection name\r\n            filter: MongoDB filter to find existing document\r\n            document: Document to insert or update\r\n            \r\n        Returns:\r\n            True if document was inserted (new), False if updated (existing)\r\n        \"\"\"\r\n        result = self.db[collection].update_one(\r\n            filter,\r\n            {\"$set\": document},\r\n            upsert=True\r\n        )\r\n        # If upserted_id exists, it was inserted (new document)\r\n        # If matched_count > 0, it was updated (existing document)\r\n        return result.upserted_id is not None",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\database\\db_repo.py",
    "function_name": "upsert_one",
    "start_line": 48,
    "end_line": 67,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "def find_one(self, collection: str, filter: Dict[str, Any]) -> Dict[str, Any] | None:\r\n        \"\"\"\r\n        Find a single document matching the filter.\r\n        \r\n        Args:\r\n            collection: Collection name\r\n            filter: MongoDB filter query\r\n            \r\n        Returns:\r\n            Document if found, None otherwise\r\n        \"\"\"\r\n        return self.db[collection].find_one(filter)",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\database\\db_repo.py",
    "function_name": "find_one",
    "start_line": 69,
    "end_line": 80,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "def bulk_upsert(self, collection: str, operations: List[Dict[str, Any]], chunk_size: int = 1000) -> Dict[str, Any]:\r\n        \"\"\"\r\n        Perform bulk upsert operations in chunks for better performance.\r\n        \r\n        Args:\r\n            collection: Collection name\r\n            operations: List of operations, each containing 'filter' and 'document' keys\r\n            chunk_size: Number of operations to process per chunk (default: 1000)\r\n            \r\n        Returns:\r\n            Dictionary with statistics: {'inserted': count, 'updated': count, 'matched': count}\r\n        \"\"\"\r\n        from pymongo import UpdateOne\r\n        \r\n        if not operations:\r\n            return {'inserted': 0, 'updated': 0, 'matched': 0}\r\n        \r\n        total_inserted = 0\r\n        total_updated = 0\r\n        total_matched = 0\r\n        num_chunks = (len(operations) + chunk_size - 1) // chunk_size\r\n        \r\n        logger.debug(f\"Processing {len(operations)} operations in {num_chunks} chunk(s) of {chunk_size}\")\r\n        \r\n        # Process in chunks\r\n        for i in range(0, len(operations), chunk_size):\r\n            chunk = operations[i:i + chunk_size]\r\n            bulk_ops = []\r\n            \r\n            for op in chunk:\r\n                bulk_ops.append(\r\n                    UpdateOne(\r\n                        op['filter'],\r\n                        {\"$set\": op['document']},\r\n                        upsert=True\r\n                    )\r\n                )\r\n            \r\n            # Use ordered=False for better parallelization\r\n            result = self.db[collection].bulk_write(bulk_ops, ordered=False)\r\n            \r\n            total_inserted += result.upserted_count\r\n            total_updated += result.modified_count\r\n            total_matched += result.matched_count\r\n        \r\n        return {\r\n            'inserted': total_inserted,\r\n            'updated': total_updated,\r\n            'matched': total_matched\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\database\\db_repo.py",
    "function_name": "bulk_upsert",
    "start_line": 82,
    "end_line": 131,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "def bulk_write_operations(self, collection: str, operations: List[UpdateOne], chunk_size: int = 2000) -> Dict[str, Any]:\r\n        \"\"\"\r\n        Execute pre-built UpdateOne (or other) operations via bulk_write.\r\n        Unlike bulk_upsert(), this accepts raw pymongo operation objects,\r\n        allowing callers to use aggregation-pipeline updates.\r\n\r\n        Args:\r\n            collection: Collection name\r\n            operations: List of pymongo WriteOperation objects (e.g. UpdateOne)\r\n            chunk_size: Number of operations per bulk_write call (default: 2000)\r\n\r\n        Returns:\r\n            Dictionary with statistics: {'inserted': count, 'updated': count, 'matched': count}\r\n        \"\"\"\r\n        if not operations:\r\n            return {'inserted': 0, 'updated': 0, 'matched': 0}\r\n\r\n        total_inserted = 0\r\n        total_updated = 0\r\n        total_matched = 0\r\n        num_chunks = (len(operations) + chunk_size - 1) // chunk_size\r\n\r\n        logger.debug(f\"Processing {len(operations)} operations in {num_chunks} chunk(s) of {chunk_size}\")\r\n\r\n        for i in range(0, len(operations), chunk_size):\r\n            chunk = operations[i:i + chunk_size]\r\n            result = self.db[collection].bulk_write(chunk, ordered=False)\r\n\r\n            total_inserted += result.upserted_count\r\n            total_updated += result.modified_count\r\n            total_matched += result.matched_count\r\n\r\n        return {\r\n            'inserted': total_inserted,\r\n            'updated': total_updated,\r\n            'matched': total_matched\r\n        }",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\database\\db_repo.py",
    "function_name": "bulk_write_operations",
    "start_line": 133,
    "end_line": 169,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "class TffrsAthletesRepo:\r\n    def __init__(self, config_vars: ConfigVars):\r\n        self.db_service = DatabaseRepo(config_vars=config_vars)\r\n        self.collection_name = \"athletes\"\r\n\r\n        # Ensure a unique index on athlete_id for fast upsert lookups.\r\n        # Idempotent \u2014 skips creation if it already exists.\r\n        self.db_service.ensure_index(self.collection_name, \"athlete_id\", unique=True)\r\n        logger.info(\"Ensured unique index on athletes.athlete_id\")\r\n\r\n    def upsert_athletes(self, athletes: dict[str, dict]) -> Dict[str, int]:\r\n        \"\"\"\r\n        Bulk upsert athletes into the athletes collection.\r\n        Match key is athlete_id.\r\n\r\n        Scalar fields are overwritten. Performances are merged by (event, season):\r\n          - If an incoming performance matches an existing one on (event, season),\r\n            the existing entry is replaced with the incoming one.\r\n          - If no match exists, the incoming performance is appended.\r\n\r\n        Args:\r\n            athletes: {athlete_id: athlete_dict} as produced by process_teams_to_athletes.\r\n\r\n        Returns:\r\n            Dict with 'inserted', 'updated', and 'matched' counts.\r\n        \"\"\"\r\n        log_info(f\"Upserting {len(athletes)} athletes into the database\", module=\"TffrsAthletesRepo\", data={})\r\n        if not athletes:\r\n            return {'inserted': 0, 'updated': 0, 'matched': 0}\r\n\r\n        now = datetime.now().isoformat()\r\n        operations: List[UpdateOne] = []\r\n\r\n        for athlete_id, athlete in athletes.items():\r\n            match_filter = {'athlete_id': athlete_id}\r\n            incoming_performances = athlete.get('performances', [])\r\n\r\n            # Build the set of (event, season) keys from the incoming batch\r\n            # so we can filter out stale entries from the existing array.\r\n            incoming_keys = [\r\n                {\"event\": p.get(\"event\"), \"season\": p.get(\"season\")}\r\n                for p in incoming_performances\r\n            ]\r\n\r\n            # Aggregation-pipeline update (MongoDB 4.2+):\r\n            #   1. Set all scalar fields unconditionally.\r\n            #   2. For performances:\r\n            #      a. Filter out any existing performance whose (event, season)\r\n            #         matches an incoming one (those get replaced).\r\n            #      b. Concatenate the filtered existing array with all incoming\r\n            #         performances.\r\n            #      If the document is new ($ifNull guards against missing field),\r\n            #      performances is simply set to the incoming array.\r\n            pipeline = [\r\n                {\r\n                    \"$set\": {\r\n                        \"source_system\": SOURCE_SYSTEM,\r\n                        \"athlete_id\": athlete_id,\r\n                        \"athlete_name\": athlete.get(\"athlete_name\"),\r\n                        \"athlete_url\": athlete.get(\"athlete_url\"),\r\n                        \"year\": athlete.get(\"year\"),\r\n                        \"gender\": athlete.get(\"gender\"),\r\n                        \"team_name\": athlete.get(\"team_name\"),\r\n                        \"team_url\": athlete.get(\"team_url\"),\r\n                        \"updated_at\": now,\r\n                        \"performances\": {\r\n                            \"$concatArrays\": [\r\n                                # Keep existing performances whose (event, season)\r\n                                # is NOT in the incoming batch.\r\n                                {\r\n                                    \"$filter\": {\r\n                                        \"input\": {\"$ifNull\": [\"$performances\", []]},\r\n                                        \"as\": \"existing\",\r\n                                        \"cond\": {\r\n                                            \"$not\": {\r\n                                                \"$in\": [\r\n                                                    {\r\n                                                        \"event\": \"$$existing.event\",\r\n                                                        \"season\": \"$$existing.season\",\r\n                                                    },\r\n                                                    incoming_keys,\r\n                                                ]\r\n                                            }\r\n                                        },\r\n                                    }\r\n                                },\r\n                                # Append all incoming performances.\r\n                                incoming_performances,\r\n                            ]\r\n                        },\r\n                    }\r\n                }\r\n            ]\r\n\r\n            operations.append(UpdateOne(match_filter, pipeline, upsert=True))\r\n\r\n        result = self.db_service.bulk_write_operations(self.collection_name, operations)\r\n        logger.info(\r\n            f\"Athletes upsert: {result.get('inserted', 0)} inserted, \"\r\n            f\"{result.get('updated', 0)} updated, {result.get('matched', 0)} matched\"\r\n        )\r\n        return result",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\database\\tffrs\\tffrs_repo.py",
    "function_name": "TffrsAthletesRepo",
    "start_line": 16,
    "end_line": 117,
    "language": "python",
    "chunk_type": "class"
  },
  {
    "content": "def __init__(self, config_vars: ConfigVars):\r\n        self.db_service = DatabaseRepo(config_vars=config_vars)\r\n        self.collection_name = \"athletes\"\r\n\r\n        # Ensure a unique index on athlete_id for fast upsert lookups.\r\n        # Idempotent \u2014 skips creation if it already exists.\r\n        self.db_service.ensure_index(self.collection_name, \"athlete_id\", unique=True)\r\n        logger.info(\"Ensured unique index on athletes.athlete_id\")",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\database\\tffrs\\tffrs_repo.py",
    "function_name": "__init__",
    "start_line": 17,
    "end_line": 24,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "def upsert_athletes(self, athletes: dict[str, dict]) -> Dict[str, int]:\r\n        \"\"\"\r\n        Bulk upsert athletes into the athletes collection.\r\n        Match key is athlete_id.\r\n\r\n        Scalar fields are overwritten. Performances are merged by (event, season):\r\n          - If an incoming performance matches an existing one on (event, season),\r\n            the existing entry is replaced with the incoming one.\r\n          - If no match exists, the incoming performance is appended.\r\n\r\n        Args:\r\n            athletes: {athlete_id: athlete_dict} as produced by process_teams_to_athletes.\r\n\r\n        Returns:\r\n            Dict with 'inserted', 'updated', and 'matched' counts.\r\n        \"\"\"\r\n        log_info(f\"Upserting {len(athletes)} athletes into the database\", module=\"TffrsAthletesRepo\", data={})\r\n        if not athletes:\r\n            return {'inserted': 0, 'updated': 0, 'matched': 0}\r\n\r\n        now = datetime.now().isoformat()\r\n        operations: List[UpdateOne] = []\r\n\r\n        for athlete_id, athlete in athletes.items():\r\n            match_filter = {'athlete_id': athlete_id}\r\n            incoming_performances = athlete.get('performances', [])\r\n\r\n            # Build the set of (event, season) keys from the incoming batch\r\n            # so we can filter out stale entries from the existing array.\r\n            incoming_keys = [\r\n                {\"event\": p.get(\"event\"), \"season\": p.get(\"season\")}\r\n                for p in incoming_performances\r\n            ]\r\n\r\n            # Aggregation-pipeline update (MongoDB 4.2+):\r\n            #   1. Set all scalar fields unconditionally.\r\n            #   2. For performances:\r\n            #      a. Filter out any existing performance whose (event, season)\r\n            #         matches an incoming one (those get replaced).\r\n            #      b. Concatenate the filtered existing array with all incoming\r\n            #         performances.\r\n            #      If the document is new ($ifNull guards against missing field),\r\n            #      performances is simply set to the incoming array.\r\n            pipeline = [\r\n                {\r\n                    \"$set\": {\r\n                        \"source_system\": SOURCE_SYSTEM,\r\n                        \"athlete_id\": athlete_id,\r\n                        \"athlete_name\": athlete.get(\"athlete_name\"),\r\n                        \"athlete_url\": athlete.get(\"athlete_url\"),\r\n                        \"year\": athlete.get(\"year\"),\r\n                        \"gender\": athlete.get(\"gender\"),\r\n                        \"team_name\": athlete.get(\"team_name\"),\r\n                        \"team_url\": athlete.get(\"team_url\"),\r\n                        \"updated_at\": now,\r\n                        \"performances\": {\r\n                            \"$concatArrays\": [\r\n                                # Keep existing performances whose (event, season)\r\n                                # is NOT in the incoming batch.\r\n                                {\r\n                                    \"$filter\": {\r\n                                        \"input\": {\"$ifNull\": [\"$performances\", []]},\r\n                                        \"as\": \"existing\",\r\n                                        \"cond\": {\r\n                                            \"$not\": {\r\n                                                \"$in\": [\r\n                                                    {\r\n                                                        \"event\": \"$$existing.event\",\r\n                                                        \"season\": \"$$existing.season\",\r\n                                                    },\r\n                                                    incoming_keys,\r\n                                                ]\r\n                                            }\r\n                                        },\r\n                                    }\r\n                                },\r\n                                # Append all incoming performances.\r\n                                incoming_performances,\r\n                            ]\r\n                        },\r\n                    }\r\n                }\r\n            ]\r\n\r\n            operations.append(UpdateOne(match_filter, pipeline, upsert=True))\r\n\r\n        result = self.db_service.bulk_write_operations(self.collection_name, operations)\r\n        logger.info(\r\n            f\"Athletes upsert: {result.get('inserted', 0)} inserted, \"\r\n            f\"{result.get('updated', 0)} updated, {result.get('matched', 0)} matched\"\r\n        )\r\n        return result",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\database\\tffrs\\tffrs_repo.py",
    "function_name": "upsert_athletes",
    "start_line": 26,
    "end_line": 117,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "class TffrsTeamsRepo:\r\n    def __init__(self, config_vars: ConfigVars):\r\n        self.db_service = DatabaseRepo(config_vars=config_vars)\r\n        self.collection_name = \"teams\"\r\n\r\n        # Ensure a unique index on team_url for fast upsert lookups.\r\n        self.db_service.ensure_index(self.collection_name, \"team_url\", unique=True)\r\n        logger.info(\"Ensured unique index on teams.team_url\")\r\n\r\n    def bulk_upsert_teams(self, teams: dict[str, dict]) -> Dict[str, int]:\r\n        \"\"\"\r\n        Bulk upsert teams into the teams collection.\r\n        Match key is team_url.\r\n\r\n        Args:\r\n            teams: {team_url: team_dict} keyed by team_url.\r\n\r\n        Returns:\r\n            Dict with 'inserted', 'updated', and 'matched' counts.\r\n        \"\"\"\r\n        if not teams:\r\n            logger.warning(\"No teams to upsert\")\r\n            return {'inserted': 0, 'updated': 0, 'matched': 0}\r\n\r\n        now = datetime.now().isoformat()\r\n        operations: List[Dict[str, Any]] = []\r\n\r\n        for team_url, team in teams.items():\r\n            match_filter = {\r\n                'team_url': team_url,\r\n            }\r\n\r\n            doc = {\r\n                'source_system': SOURCE_SYSTEM,\r\n                'team_name': team.get('team_name'),\r\n                'team_url': team_url,\r\n                'conference_name': team.get('conference_name'),\r\n                'division_code': team.get('division_code'),\r\n                'season': team.get('season'),\r\n                'updated_at': now,\r\n            }\r\n\r\n            operations.append({'filter': match_filter, 'document': doc})\r\n\r\n        logger.debug(f\"Prepared {len(operations)} team upsert operations\")\r\n        result = self.db_service.bulk_upsert(self.collection_name, operations)\r\n        logger.info(\r\n            f\"Teams upsert: {result.get('inserted', 0)} inserted, \"\r\n            f\"{result.get('updated', 0)} updated, {result.get('matched', 0)} matched\"\r\n        )\r\n        return result",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\database\\tffrs\\tffrs_teams_repo.py",
    "function_name": "TffrsTeamsRepo",
    "start_line": 13,
    "end_line": 63,
    "language": "python",
    "chunk_type": "class"
  },
  {
    "content": "def __init__(self, config_vars: ConfigVars):\r\n        self.db_service = DatabaseRepo(config_vars=config_vars)\r\n        self.collection_name = \"teams\"\r\n\r\n        # Ensure a unique index on team_url for fast upsert lookups.\r\n        self.db_service.ensure_index(self.collection_name, \"team_url\", unique=True)\r\n        logger.info(\"Ensured unique index on teams.team_url\")",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\database\\tffrs\\tffrs_teams_repo.py",
    "function_name": "__init__",
    "start_line": 14,
    "end_line": 20,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "def bulk_upsert_teams(self, teams: dict[str, dict]) -> Dict[str, int]:\r\n        \"\"\"\r\n        Bulk upsert teams into the teams collection.\r\n        Match key is team_url.\r\n\r\n        Args:\r\n            teams: {team_url: team_dict} keyed by team_url.\r\n\r\n        Returns:\r\n            Dict with 'inserted', 'updated', and 'matched' counts.\r\n        \"\"\"\r\n        if not teams:\r\n            logger.warning(\"No teams to upsert\")\r\n            return {'inserted': 0, 'updated': 0, 'matched': 0}\r\n\r\n        now = datetime.now().isoformat()\r\n        operations: List[Dict[str, Any]] = []\r\n\r\n        for team_url, team in teams.items():\r\n            match_filter = {\r\n                'team_url': team_url,\r\n            }\r\n\r\n            doc = {\r\n                'source_system': SOURCE_SYSTEM,\r\n                'team_name': team.get('team_name'),\r\n                'team_url': team_url,\r\n                'conference_name': team.get('conference_name'),\r\n                'division_code': team.get('division_code'),\r\n                'season': team.get('season'),\r\n                'updated_at': now,\r\n            }\r\n\r\n            operations.append({'filter': match_filter, 'document': doc})\r\n\r\n        logger.debug(f\"Prepared {len(operations)} team upsert operations\")\r\n        result = self.db_service.bulk_upsert(self.collection_name, operations)\r\n        logger.info(\r\n            f\"Teams upsert: {result.get('inserted', 0)} inserted, \"\r\n            f\"{result.get('updated', 0)} updated, {result.get('matched', 0)} matched\"\r\n        )\r\n        return result",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\database\\tffrs\\tffrs_teams_repo.py",
    "function_name": "bulk_upsert_teams",
    "start_line": 22,
    "end_line": 63,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "class ScrapingStrategy:\r\n    def __init__ (self, config_vars: ConfigVars,  strategy_name: str, log_module):\r\n        self.config_vars = config_vars\r\n        self.strategy_name = strategy_name\r\n        self.log_module = log_module\r\n        \r\n        self.use_bridge = config_vars.use_bridge\r\n        self.east_bridge_url = config_vars.east_bridge_url\r\n        self.west_bridge_url = config_vars.west_bridge_url\r\n        \r\n        self.time_start = None\r\n        self.time_end = None\r\n        \r\n    def run_scrape(self):\r\n        raise NotImplementedError(\"Subclasses must implement this method.\")\r\n    \r\n    def close_strategy(self):\r\n        raise NotImplementedError(\"Subclasses must implement this method.\")\r\n    \r\n    def save_json_file(self, file_name, data):\r\n        with open(f'./tmp/{self.strategy_name}/{file_name}', 'w', encoding='utf-8') as f:\r\n            json.dump(data, f, ensure_ascii=False, indent=4)\r\n    \r\n    def save_csv_file(self, file_name, dataframe):\r\n        \"\"\"Save a pandas DataFrame to CSV file.\"\"\"\r\n        dataframe.to_csv(f'./tmp/{self.strategy_name}/{file_name}', index=False, encoding='utf-8')\r\n            \r\n    def set_time_start(self):\r\n        self.time_start = datetime.now()\r\n    \r\n    def set_time_end(self):\r\n        self.time_end = datetime.now()",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\scrapers\\scraping_strategy.py",
    "function_name": "ScrapingStrategy",
    "start_line": 8,
    "end_line": 39,
    "language": "python",
    "chunk_type": "class"
  },
  {
    "content": "def __init__ (self, config_vars: ConfigVars,  strategy_name: str, log_module):\r\n        self.config_vars = config_vars\r\n        self.strategy_name = strategy_name\r\n        self.log_module = log_module\r\n        \r\n        self.use_bridge = config_vars.use_bridge\r\n        self.east_bridge_url = config_vars.east_bridge_url\r\n        self.west_bridge_url = config_vars.west_bridge_url\r\n        \r\n        self.time_start = None\r\n        self.time_end = None",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\scrapers\\scraping_strategy.py",
    "function_name": "__init__",
    "start_line": 9,
    "end_line": 19,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "def run_scrape(self):\r\n        raise NotImplementedError(\"Subclasses must implement this method.\")",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\scrapers\\scraping_strategy.py",
    "function_name": "run_scrape",
    "start_line": 21,
    "end_line": 22,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "def close_strategy(self):\r\n        raise NotImplementedError(\"Subclasses must implement this method.\")",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\scrapers\\scraping_strategy.py",
    "function_name": "close_strategy",
    "start_line": 24,
    "end_line": 25,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "def save_json_file(self, file_name, data):\r\n        with open(f'./tmp/{self.strategy_name}/{file_name}', 'w', encoding='utf-8') as f:\r\n            json.dump(data, f, ensure_ascii=False, indent=4)",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\scrapers\\scraping_strategy.py",
    "function_name": "save_json_file",
    "start_line": 27,
    "end_line": 29,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "def save_csv_file(self, file_name, dataframe):\r\n        \"\"\"Save a pandas DataFrame to CSV file.\"\"\"\r\n        dataframe.to_csv(f'./tmp/{self.strategy_name}/{file_name}', index=False, encoding='utf-8')",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\scrapers\\scraping_strategy.py",
    "function_name": "save_csv_file",
    "start_line": 31,
    "end_line": 33,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "def set_time_start(self):\r\n        self.time_start = datetime.now()",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\scrapers\\scraping_strategy.py",
    "function_name": "set_time_start",
    "start_line": 35,
    "end_line": 36,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "def set_time_end(self):\r\n        self.time_end = datetime.now()",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\scrapers\\scraping_strategy.py",
    "function_name": "set_time_end",
    "start_line": 38,
    "end_line": 39,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "class TffrsStrategy(ScrapingStrategy):\r\n    def __init__(self, config_vars: ConfigVars):\r\n        super().__init__(config_vars, strategy_name=\"tffrs\", log_module=\"Tffrs-Strategy\")\r\n        \r\n        self.tffrs_catalog_usecase = TffrsCatalogUseCase()\r\n        self.tffs_teams_catalog_usecase = TffrsTeamsCatalogUseCase()\r\n        self.tffrs_athletes_usecase = TffrsAthleteUseCase()\r\n        \r\n        self.tffrs_athletes_repo = TffrsAthletesRepo(config_vars=self.config_vars)\r\n        self.tffrs_teams_repo = TffrsTeamsRepo(config_vars=self.config_vars)\r\n        \r\n        self.athlete_file_chunk_size = 30000\r\n        self.db_chunk_size = 2000\r\n        \r\n\r\n    def scrape(self):\r\n        self.set_time_start()\r\n        log_info(f\"Starting TFFRS scraping strategy at {self.time_start}\", module=self.log_module, data={})\r\n        \r\n        # Catalog the divisions, conferences, and teams available on TFFRS\r\n        conferences_dict = cast(dict[str, list[dict]], self.tffrs_catalog_usecase.execute())\r\n        indoor_length = len(conferences_dict.get('indoor', []))\r\n        outdoor_length = len(conferences_dict.get('outdoor', []))\r\n        log_info(f\"Found {len(conferences_dict)} total seasons ({indoor_length} indoor, {outdoor_length} outdoor)\", module=self.log_module, data={})\r\n        \r\n        # Scrape team/athlete performances from conference pages.\r\n        # Also collects unique teams keyed by team_url.\r\n        athlete_performances_df, teams_dict = self.tffs_teams_catalog_usecase.execute(conferences_dict)\r\n        log_info(f\"Collected {len(athlete_performances_df)} athlete performances and {len(teams_dict)} teams\", \r\n                 module=self.log_module, data={})\r\n        \r\n        athletes_dict = self.tffrs_athletes_usecase.execute(athlete_performances_df)\r\n        log_info(f\"Processed {len(athletes_dict)} unique athletes\", module=self.log_module, data={})\r\n\r\n        # Upsert teams into database\r\n        start_time = datetime.now()\r\n        self.tffrs_teams_repo.bulk_upsert_teams(teams_dict)\r\n        end_time = datetime.now()\r\n        log_info(f\"Completed upserting teams into database. Duration: {end_time - start_time}\", module=self.log_module, data={})\r\n            \r\n        # Upsert athletes into database. Split into chunks\r\n        start_time = datetime.now()\r\n        athlete_items = list(athletes_dict.items())\r\n        for i in range(0, len(athlete_items), self.db_chunk_size):\r\n            chunk_dict = dict(athlete_items[i:i+self.db_chunk_size])\r\n            self.tffrs_athletes_repo.upsert_athletes(chunk_dict)\r\n            \r\n        end_time = datetime.now()\r\n        log_info(f\"Completed upserting athletes into database. Duration: {end_time - start_time}\", module=self.log_module, data={})\r\n\r\n\r\n    def close_strategy(self):\r\n        self.set_time_end()\r\n        time_to_complete = self.time_end - self.time_start if self.time_end and self.time_start else None\r\n        log_info(f\"Completed TFFRS scraping strategy at {self.time_end}. Duration: {time_to_complete}\", module=self.log_module, data={})",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\scrapers\\tffrrs_strategy.py",
    "function_name": "TffrsStrategy",
    "start_line": 16,
    "end_line": 70,
    "language": "python",
    "chunk_type": "class"
  },
  {
    "content": "def __init__(self, config_vars: ConfigVars):\r\n        super().__init__(config_vars, strategy_name=\"tffrs\", log_module=\"Tffrs-Strategy\")\r\n        \r\n        self.tffrs_catalog_usecase = TffrsCatalogUseCase()\r\n        self.tffs_teams_catalog_usecase = TffrsTeamsCatalogUseCase()\r\n        self.tffrs_athletes_usecase = TffrsAthleteUseCase()\r\n        \r\n        self.tffrs_athletes_repo = TffrsAthletesRepo(config_vars=self.config_vars)\r\n        self.tffrs_teams_repo = TffrsTeamsRepo(config_vars=self.config_vars)\r\n        \r\n        self.athlete_file_chunk_size = 30000\r\n        self.db_chunk_size = 2000",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\scrapers\\tffrrs_strategy.py",
    "function_name": "__init__",
    "start_line": 17,
    "end_line": 28,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "def scrape(self):\r\n        self.set_time_start()\r\n        log_info(f\"Starting TFFRS scraping strategy at {self.time_start}\", module=self.log_module, data={})\r\n        \r\n        # Catalog the divisions, conferences, and teams available on TFFRS\r\n        conferences_dict = cast(dict[str, list[dict]], self.tffrs_catalog_usecase.execute())\r\n        indoor_length = len(conferences_dict.get('indoor', []))\r\n        outdoor_length = len(conferences_dict.get('outdoor', []))\r\n        log_info(f\"Found {len(conferences_dict)} total seasons ({indoor_length} indoor, {outdoor_length} outdoor)\", module=self.log_module, data={})\r\n        \r\n        # Scrape team/athlete performances from conference pages.\r\n        # Also collects unique teams keyed by team_url.\r\n        athlete_performances_df, teams_dict = self.tffs_teams_catalog_usecase.execute(conferences_dict)\r\n        log_info(f\"Collected {len(athlete_performances_df)} athlete performances and {len(teams_dict)} teams\", \r\n                 module=self.log_module, data={})\r\n        \r\n        athletes_dict = self.tffrs_athletes_usecase.execute(athlete_performances_df)\r\n        log_info(f\"Processed {len(athletes_dict)} unique athletes\", module=self.log_module, data={})\r\n\r\n        # Upsert teams into database\r\n        start_time = datetime.now()\r\n        self.tffrs_teams_repo.bulk_upsert_teams(teams_dict)\r\n        end_time = datetime.now()\r\n        log_info(f\"Completed upserting teams into database. Duration: {end_time - start_time}\", module=self.log_module, data={})\r\n            \r\n        # Upsert athletes into database. Split into chunks\r\n        start_time = datetime.now()\r\n        athlete_items = list(athletes_dict.items())\r\n        for i in range(0, len(athlete_items), self.db_chunk_size):\r\n            chunk_dict = dict(athlete_items[i:i+self.db_chunk_size])\r\n            self.tffrs_athletes_repo.upsert_athletes(chunk_dict)\r\n            \r\n        end_time = datetime.now()\r\n        log_info(f\"Completed upserting athletes into database. Duration: {end_time - start_time}\", module=self.log_module, data={})",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\scrapers\\tffrrs_strategy.py",
    "function_name": "scrape",
    "start_line": 31,
    "end_line": 64,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "def close_strategy(self):\r\n        self.set_time_end()\r\n        time_to_complete = self.time_end - self.time_start if self.time_end and self.time_start else None\r\n        log_info(f\"Completed TFFRS scraping strategy at {self.time_end}. Duration: {time_to_complete}\", module=self.log_module, data={})",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\scrapers\\tffrrs_strategy.py",
    "function_name": "close_strategy",
    "start_line": 67,
    "end_line": 70,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "class ScrapingUseCase:\r\n    def __init__(self, usecase_name:str, module_name:str):\r\n        if not usecase_name or usecase_name.strip() == \"\":\r\n            raise ValueError(\"usecase_name must be a non-empty string\")\r\n        \r\n        if not module_name or module_name.strip() == \"\":\r\n            raise ValueError(\"module_name must be a non-empty string\") \r\n        \r\n        \r\n        self.usecase_name = usecase_name\r\n        self.module_name = module_name\r\n\r\n        self.__wait_time_secs = 45\r\n        self.__should_use_bridge = False\r\n        self.__east_bridge_url = \"\"\r\n        \r\n    \r\n    def execute(self, *args, **kwargs):\r\n        raise NotImplementedError(\"Subclasses must implement this method.\")\r\n    \r\n    def scrape_url(self, url: str) -> str:\r\n        \"\"\"Scrape the given URL and return the response text\"\"\"\r\n        request = {\r\n            \"method\": 'GET',\r\n            \"url\": url,\r\n            \"headers\": {\r\n                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'\r\n            }\r\n        }\r\n\r\n        if self.__should_use_bridge:\r\n            request['url'] = self.__east_bridge_url\r\n            request['headers']['X-Target-URL'] = url\r\n\r\n        return self.__perform_scrape(request)\r\n    \r\n    async def scrape_url_async(self, session: aiohttp.ClientSession, url: str) -> str:\r\n        \"\"\"Async version of scrape_url\"\"\"\r\n        headers = {\r\n            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'\r\n        }\r\n        \r\n        request_url = self.__east_bridge_url if self.__should_use_bridge else url\r\n        if self.__should_use_bridge:\r\n            headers['X-Target-URL'] = url\r\n        \r\n        try:\r\n            async with session.get(request_url, headers=headers, timeout=self.__wait_time_secs) as response:\r\n                response.raise_for_status()\r\n                return await response.text()\r\n        except Exception as e:\r\n            error_msg = f\"Scraping error for {url}: {type(e).__name__}\"\r\n            log_error(message=error_msg, module=self.module_name, data={\"url\": url})\r\n            raise Exception(error_msg) from e\r\n\r\n    def text_to_bs4(self, html_text: str):\r\n        \"\"\"Convert raw HTML text to a BeautifulSoup object\"\"\"\r\n        try:\r\n            soup = BeautifulSoup(html_text, 'html.parser')\r\n            return soup\r\n        except Exception as e:\r\n            print(f\"Error converting text to BeautifulSoup object: {e}\")\r\n            raise e\r\n    \r\n    def __perform_scrape(self, request) -> str:\r\n        try:\r\n            response = requests.get(\r\n                url=request['url'],\r\n                headers=request['headers'],\r\n                timeout=self.__wait_time_secs\r\n            )\r\n            response.raise_for_status()\r\n            status_code = response.status_code\r\n\r\n            if status_code == 200:\r\n                return response.text\r\n            else:\r\n                raise Exception(f\"Unexpected status code: {status_code}\")\r\n        except requests.exceptions.RequestException as e:\r\n            error_msg = f\"HTTP client error for {request['url']}: {type(e).__name__} - {str(e) or 'No details'}\"\r\n            log_error(message=error_msg, module=self.module_name, data={\"request\": request})\r\n            raise Exception(error_msg) from e\r\n        except Exception as e:\r\n            error_msg = f\"Scraping error for {request['url']}: {type(e).__name__} - {str(e) or 'Unknown error'}\"\r\n            log_error(message=error_msg, module=self.module_name, data={\"request\": request})\r\n            raise Exception(error_msg) from e",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\usecase\\scraping_usecase.py",
    "function_name": "ScrapingUseCase",
    "start_line": 8,
    "end_line": 93,
    "language": "python",
    "chunk_type": "class"
  },
  {
    "content": "def __init__(self, usecase_name:str, module_name:str):\r\n        if not usecase_name or usecase_name.strip() == \"\":\r\n            raise ValueError(\"usecase_name must be a non-empty string\")\r\n        \r\n        if not module_name or module_name.strip() == \"\":\r\n            raise ValueError(\"module_name must be a non-empty string\") \r\n        \r\n        \r\n        self.usecase_name = usecase_name\r\n        self.module_name = module_name\r\n\r\n        self.__wait_time_secs = 45\r\n        self.__should_use_bridge = False\r\n        self.__east_bridge_url = \"\"",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\usecase\\scraping_usecase.py",
    "function_name": "__init__",
    "start_line": 9,
    "end_line": 22,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "def execute(self, *args, **kwargs):\r\n        raise NotImplementedError(\"Subclasses must implement this method.\")",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\usecase\\scraping_usecase.py",
    "function_name": "execute",
    "start_line": 25,
    "end_line": 26,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "def scrape_url(self, url: str) -> str:\r\n        \"\"\"Scrape the given URL and return the response text\"\"\"\r\n        request = {\r\n            \"method\": 'GET',\r\n            \"url\": url,\r\n            \"headers\": {\r\n                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'\r\n            }\r\n        }\r\n\r\n        if self.__should_use_bridge:\r\n            request['url'] = self.__east_bridge_url\r\n            request['headers']['X-Target-URL'] = url\r\n\r\n        return self.__perform_scrape(request)",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\usecase\\scraping_usecase.py",
    "function_name": "scrape_url",
    "start_line": 28,
    "end_line": 42,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "async def scrape_url_async(self, session: aiohttp.ClientSession, url: str) -> str:\r\n        \"\"\"Async version of scrape_url\"\"\"\r\n        headers = {\r\n            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'\r\n        }\r\n        \r\n        request_url = self.__east_bridge_url if self.__should_use_bridge else url\r\n        if self.__should_use_bridge:\r\n            headers['X-Target-URL'] = url\r\n        \r\n        try:\r\n            async with session.get(request_url, headers=headers, timeout=self.__wait_time_secs) as response:\r\n                response.raise_for_status()\r\n                return await response.text()\r\n        except Exception as e:\r\n            error_msg = f\"Scraping error for {url}: {type(e).__name__}\"\r\n            log_error(message=error_msg, module=self.module_name, data={\"url\": url})\r\n            raise Exception(error_msg) from e",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\usecase\\scraping_usecase.py",
    "function_name": "scrape_url_async",
    "start_line": 44,
    "end_line": 61,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "def text_to_bs4(self, html_text: str):\r\n        \"\"\"Convert raw HTML text to a BeautifulSoup object\"\"\"\r\n        try:\r\n            soup = BeautifulSoup(html_text, 'html.parser')\r\n            return soup\r\n        except Exception as e:\r\n            print(f\"Error converting text to BeautifulSoup object: {e}\")\r\n            raise e",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\usecase\\scraping_usecase.py",
    "function_name": "text_to_bs4",
    "start_line": 63,
    "end_line": 70,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "def __perform_scrape(self, request) -> str:\r\n        try:\r\n            response = requests.get(\r\n                url=request['url'],\r\n                headers=request['headers'],\r\n                timeout=self.__wait_time_secs\r\n            )\r\n            response.raise_for_status()\r\n            status_code = response.status_code\r\n\r\n            if status_code == 200:\r\n                return response.text\r\n            else:\r\n                raise Exception(f\"Unexpected status code: {status_code}\")\r\n        except requests.exceptions.RequestException as e:\r\n            error_msg = f\"HTTP client error for {request['url']}: {type(e).__name__} - {str(e) or 'No details'}\"\r\n            log_error(message=error_msg, module=self.module_name, data={\"request\": request})\r\n            raise Exception(error_msg) from e\r\n        except Exception as e:\r\n            error_msg = f\"Scraping error for {request['url']}: {type(e).__name__} - {str(e) or 'Unknown error'}\"\r\n            log_error(message=error_msg, module=self.module_name, data={\"request\": request})\r\n            raise Exception(error_msg) from e",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\usecase\\scraping_usecase.py",
    "function_name": "__perform_scrape",
    "start_line": 72,
    "end_line": 93,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "class TffrsAthleteUseCase(ScrapingUseCase):\r\n    def __init__(self):\r\n        super().__init__(usecase_name=\"TFFRS Athlete UseCase\", module_name=\"Tffrs-Athlete-UseCase\")\r\n\r\n    def execute(self, df: pd.DataFrame) -> dict[str, dict]:\r\n        \"\"\"\r\n        Aggregate athletes from performance DataFrame.\r\n\r\n        Args:\r\n            df: DataFrame with columns including:\r\n                - season, conference_name, conference_url\r\n                - event, gender, place, athlete_name, athlete_url, year\r\n                - team_name, team_url, mark, mark_url\r\n                - meet_name, meet_url, meet_date\r\n\r\n        Returns:\r\n            dict: {athlete_id: athlete_dict} with all performances merged.\r\n        \"\"\"\r\n        aggregated_athletes: dict[str, dict] = {}\r\n\r\n        # Process each row in the DataFrame\r\n        for _, row in df.iterrows():\r\n            athlete_url = row.get('athlete_url')\r\n            if not athlete_url or pd.isna(athlete_url):\r\n                continue\r\n\r\n            # Extract athlete_id from URL\r\n            match = re.search(r'/athletes/(\\d+)/', str(athlete_url))\r\n            athlete_id = match.group(1) if match else None\r\n            if not athlete_id:\r\n                continue\r\n\r\n            # Create performance dict\r\n            # Check if mark is missing or null, use points instead if available\r\n            mark_value = row.get('mark')\r\n            if pd.isna(mark_value) or not mark_value:\r\n                points_value = row.get('points')\r\n                if not pd.isna(points_value) and points_value:\r\n                    mark_value = points_value\r\n\r\n            performance = {\r\n                'event': self._to_none_if_nan(row.get('event')),\r\n                'gender': self._to_none_if_nan(row.get('gender')),\r\n                'place': self._to_none_if_nan(row.get('place')),\r\n                'mark': self._to_none_if_nan(mark_value),\r\n                'mark_url': self._to_none_if_nan(row.get('mark_url')),\r\n                'meet_name': self._to_none_if_nan(row.get('meet_name')),\r\n                'meet_url': self._to_none_if_nan(row.get('meet_url')),\r\n                'meet_date': self._to_none_if_nan(row.get('meet_date')),\r\n                'season': self._to_none_if_nan(row.get('season')),\r\n            }\r\n\r\n            # Merge athlete data\r\n            if athlete_id in aggregated_athletes:\r\n                existing = aggregated_athletes[athlete_id]\r\n                self.__check_for_mismatches(existing, row, athlete_id)\r\n                existing['performances'].append(performance)\r\n            else:\r\n                aggregated_athletes[athlete_id] = {\r\n                    'athlete_id': athlete_id,\r\n                    'athlete_name': self._to_none_if_nan(row.get('athlete_name')),\r\n                    'athlete_url': self._to_none_if_nan(athlete_url),\r\n                    'year': self._to_none_if_nan(row.get('year')),\r\n                    'gender': self._to_none_if_nan(row.get('gender')),\r\n                    'team_name': self._to_none_if_nan(row.get('team_name')),\r\n                    'team_url': self._to_none_if_nan(row.get('team_url')),\r\n                    'performances': [performance],\r\n                }\r\n\r\n        log_info(\r\n            message=f\"Aggregated {len(aggregated_athletes)} unique athletes from {len(df)} performance records\",\r\n            module=self.module_name,\r\n        )\r\n\r\n        return aggregated_athletes\r\n\r\n    def __check_for_mismatches(self, existing: dict, row: pd.Series, athlete_id: str):\r\n        \"\"\"Log a warning if the same athlete ID maps to different names or teams.\"\"\"\r\n        new_name = row.get('athlete_name')\r\n        new_team = row.get('team_name')\r\n\r\n        # Commenting out for now as its pretty common for complex athlete names to be spelled wrong or inconsistently across different performance records, which is likely why we see so many mismatches when we run this check. We can revisit later if we want to try to clean up some of the athlete names in the source data and then re-enable this check to catch any remaining mismatches.\r\n        # Keep code for now\r\n        # if existing['athlete_name'] != new_name:\r\n        #     log_warning(\r\n        #         message=f\"Athlete name mismatch for ID {athlete_id}: '{existing['athlete_name']}' vs '{new_name}'\",\r\n        #         module=self.module_name,\r\n        #         data={'athlete_url': existing['athlete_url']},\r\n        #     )\r\n\r\n        if existing['team_name'] != new_team:\r\n            log_warning(\r\n                message=f\"Athlete team mismatch for ID {athlete_id}: '{existing['team_name']}' vs '{new_team}'\",\r\n                module=self.module_name,\r\n                data={'athlete_name': existing['athlete_name'], 'athlete_url': existing['athlete_url']},\r\n            )\r\n\r\n    def _to_none_if_nan(self, value):\r\n        \"\"\"Convert pandas NaN values to None for JSON serialization.\"\"\"\r\n        if pd.isna(value):\r\n            return None\r\n        return value",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\usecase\\tffrs\\tffrs_athlete_usecase.py",
    "function_name": "TffrsAthleteUseCase",
    "start_line": 8,
    "end_line": 109,
    "language": "python",
    "chunk_type": "class"
  },
  {
    "content": "def __init__(self):\r\n        super().__init__(usecase_name=\"TFFRS Athlete UseCase\", module_name=\"Tffrs-Athlete-UseCase\")",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\usecase\\tffrs\\tffrs_athlete_usecase.py",
    "function_name": "__init__",
    "start_line": 9,
    "end_line": 10,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "def execute(self, df: pd.DataFrame) -> dict[str, dict]:\r\n        \"\"\"\r\n        Aggregate athletes from performance DataFrame.\r\n\r\n        Args:\r\n            df: DataFrame with columns including:\r\n                - season, conference_name, conference_url\r\n                - event, gender, place, athlete_name, athlete_url, year\r\n                - team_name, team_url, mark, mark_url\r\n                - meet_name, meet_url, meet_date\r\n\r\n        Returns:\r\n            dict: {athlete_id: athlete_dict} with all performances merged.\r\n        \"\"\"\r\n        aggregated_athletes: dict[str, dict] = {}\r\n\r\n        # Process each row in the DataFrame\r\n        for _, row in df.iterrows():\r\n            athlete_url = row.get('athlete_url')\r\n            if not athlete_url or pd.isna(athlete_url):\r\n                continue\r\n\r\n            # Extract athlete_id from URL\r\n            match = re.search(r'/athletes/(\\d+)/', str(athlete_url))\r\n            athlete_id = match.group(1) if match else None\r\n            if not athlete_id:\r\n                continue\r\n\r\n            # Create performance dict\r\n            # Check if mark is missing or null, use points instead if available\r\n            mark_value = row.get('mark')\r\n            if pd.isna(mark_value) or not mark_value:\r\n                points_value = row.get('points')\r\n                if not pd.isna(points_value) and points_value:\r\n                    mark_value = points_value\r\n\r\n            performance = {\r\n                'event': self._to_none_if_nan(row.get('event')),\r\n                'gender': self._to_none_if_nan(row.get('gender')),\r\n                'place': self._to_none_if_nan(row.get('place')),\r\n                'mark': self._to_none_if_nan(mark_value),\r\n                'mark_url': self._to_none_if_nan(row.get('mark_url')),\r\n                'meet_name': self._to_none_if_nan(row.get('meet_name')),\r\n                'meet_url': self._to_none_if_nan(row.get('meet_url')),\r\n                'meet_date': self._to_none_if_nan(row.get('meet_date')),\r\n                'season': self._to_none_if_nan(row.get('season')),\r\n            }\r\n\r\n            # Merge athlete data\r\n            if athlete_id in aggregated_athletes:\r\n                existing = aggregated_athletes[athlete_id]\r\n                self.__check_for_mismatches(existing, row, athlete_id)\r\n                existing['performances'].append(performance)\r\n            else:\r\n                aggregated_athletes[athlete_id] = {\r\n                    'athlete_id': athlete_id,\r\n                    'athlete_name': self._to_none_if_nan(row.get('athlete_name')),\r\n                    'athlete_url': self._to_none_if_nan(athlete_url),\r\n                    'year': self._to_none_if_nan(row.get('year')),\r\n                    'gender': self._to_none_if_nan(row.get('gender')),\r\n                    'team_name': self._to_none_if_nan(row.get('team_name')),\r\n                    'team_url': self._to_none_if_nan(row.get('team_url')),\r\n                    'performances': [performance],\r\n                }\r\n\r\n        log_info(\r\n            message=f\"Aggregated {len(aggregated_athletes)} unique athletes from {len(df)} performance records\",\r\n            module=self.module_name,\r\n        )\r\n\r\n        return aggregated_athletes",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\usecase\\tffrs\\tffrs_athlete_usecase.py",
    "function_name": "execute",
    "start_line": 12,
    "end_line": 82,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "def __check_for_mismatches(self, existing: dict, row: pd.Series, athlete_id: str):\r\n        \"\"\"Log a warning if the same athlete ID maps to different names or teams.\"\"\"\r\n        new_name = row.get('athlete_name')\r\n        new_team = row.get('team_name')\r\n\r\n        # Commenting out for now as its pretty common for complex athlete names to be spelled wrong or inconsistently across different performance records, which is likely why we see so many mismatches when we run this check. We can revisit later if we want to try to clean up some of the athlete names in the source data and then re-enable this check to catch any remaining mismatches.\r\n        # Keep code for now\r\n        # if existing['athlete_name'] != new_name:\r\n        #     log_warning(\r\n        #         message=f\"Athlete name mismatch for ID {athlete_id}: '{existing['athlete_name']}' vs '{new_name}'\",\r\n        #         module=self.module_name,\r\n        #         data={'athlete_url': existing['athlete_url']},\r\n        #     )\r\n\r\n        if existing['team_name'] != new_team:\r\n            log_warning(\r\n                message=f\"Athlete team mismatch for ID {athlete_id}: '{existing['team_name']}' vs '{new_team}'\",\r\n                module=self.module_name,\r\n                data={'athlete_name': existing['athlete_name'], 'athlete_url': existing['athlete_url']},\r\n            )",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\usecase\\tffrs\\tffrs_athlete_usecase.py",
    "function_name": "__check_for_mismatches",
    "start_line": 84,
    "end_line": 103,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "def _to_none_if_nan(self, value):\r\n        \"\"\"Convert pandas NaN values to None for JSON serialization.\"\"\"\r\n        if pd.isna(value):\r\n            return None\r\n        return value",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\usecase\\tffrs\\tffrs_athlete_usecase.py",
    "function_name": "_to_none_if_nan",
    "start_line": 105,
    "end_line": 109,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "class TffrsCatalogUseCase(ScrapingUseCase):\r\n    def __init__(self):\r\n        super().__init__(usecase_name=\"TFFRS Catalog Use Case\", module_name=\"Tffrs-Catalog-UseCase\")\r\n\r\n        self.__indoor_divisions_url = \"https://tf.tfrrs.org/indoor_lists.html\"\r\n        self.__outdoor_divisions_url = \"https://tf.tfrrs.org/outdoor_lists.html\"\r\n        \r\n        self.__allowed_divisions = ['d1', 'd2', 'd3', 'naia']\r\n\r\n        self.__divisional_lists_to_ignore = [\r\n            \"indoor qualifying list\",\r\n            \"di great lakes region\",\r\n            \"di mid-atlantic region\",\r\n            \"di midwest region\",\r\n            \"di mountain region\",\r\n            \"di northeast region\",\r\n            \"di south central region\",\r\n            \"di south region\",\r\n            \"di southeast region\",\r\n            \"di west region\",\r\n            \"dii atlantic region\",\r\n            \"dii central region\",\r\n            \"dii east region\",\r\n            \"dii midwest region\",\r\n            \"dii south central region\",\r\n            \"dii south region\",\r\n            \"dii southeast region\",\r\n            \"dii west region\",\r\n            \"diii east region\",\r\n            \"diii great lakes region\",\r\n            \"diii metro region\",\r\n            \"diii mid-atlantic region\",\r\n            \"diii mideast region\",\r\n            \"diii midwest region\",\r\n            \"diii niagara region\",\r\n            \"diii north region\",\r\n            \"diii south region\",\r\n            \"diii west region\",\r\n            # specifc to outdoor lists\r\n            \"combined list\",\r\n            \"east qualifying list\",\r\n            \"west qualifying list\",\r\n            \"outdoor qualifying list\",\r\n            # non-conference aggregates and regional bodies\r\n            \"ic4a/ecac\",\r\n            \"neicaaa\",\r\n            \"hbcu\",\r\n            \"diii all-ohio\",\r\n            \"diii new england\",\r\n            \"aartfc\",\r\n            \"ecac diii\",\r\n            \"mets\",\r\n            \"frozen 8\"\r\n        ]\r\n\r\n    def execute(self):\r\n        divisions_list = self.__catalog_national_divisions()\r\n        return self.__get_divisions_perf_lists(divisions_list)\r\n\r\n    # ------------------------ Private Scraping Methods ----------------------- #\r\n    \r\n    def __catalog_national_divisions(self) -> dict:\r\n        \"\"\"Discover TFFRS lists by scraping the relevant page and extracting list URLs\"\"\"\r\n        try:\r\n            indoor_page_content = self.scrape_url(self.__indoor_divisions_url)\r\n            outdoor_page_content = self.scrape_url(self.__outdoor_divisions_url)\r\n\r\n            # Parse page content to bs4 and extract list Urls\r\n            indoor_bs4 = self.text_to_bs4(indoor_page_content)\r\n            outdoor_bs4 = self.text_to_bs4(outdoor_page_content)\r\n            \r\n            discovered_divisions = {\r\n                'indoor': self.__parse_national_list(indoor_bs4),\r\n                'outdoor': self.__parse_national_list(outdoor_bs4)\r\n            }\r\n            \r\n            log_info(f\"Discovered national divisions: {discovered_divisions}\", module=self.module_name, \r\n                data={\r\n                'indoor_divisions_count': len(discovered_divisions['indoor']),\r\n                'outdoor_divisions_count': len(discovered_divisions['outdoor']),\r\n                }\r\n            )\r\n            \r\n            return discovered_divisions\r\n        except Exception as e:\r\n            log_error(message=f\"Error obtaining national divisions: {e}\", module=self.module_name, data={})\r\n            raise e\r\n        \r\n    def __parse_national_list(self, page_bs4):\r\n        \"\"\"Parse the national lists page to extract list URLs and metadata\"\"\"\r\n        try:\r\n            lists = []\r\n            \r\n            # Find all turbo-frame elements that contain division-specific list data\r\n            turbo_frames = page_bs4.find_all('turbo-frame', id=lambda x: x and x.startswith('directory_tab_'))\r\n            \r\n            for frame in turbo_frames:\r\n                src = frame.get('src')\r\n                frame_id = frame.get('id')\r\n                \r\n                if src:\r\n                    # Extract division/tab name from frame_id (e.g., 'directory_tab_d1' -> 'd1')\r\n                    division = frame_id.replace('directory_tab_', '') if frame_id else 'unknown'\r\n                    \r\n                    # Map division codes to readable names\r\n                    division_names = {\r\n                        'd1': 'NCAA Division I',\r\n                        'd2': 'NCAA Division II',\r\n                        'd3': 'NCAA Division III',\r\n                        'naia': 'NAIA',\r\n                        'njcaa': 'NJCAA',\r\n                        'nccaa': 'NCCAA'\r\n                    }\r\n                    \r\n                    # Build full URL (base URL is https://tf.tfrrs.org)\r\n                    full_url = f\"https://tf.tfrrs.org{src}\"\r\n                    \r\n                    # Only include allowed divisions\r\n                    if division not in self.__allowed_divisions:\r\n                        continue\r\n\r\n                    lists.append({\r\n                        'division_code': division,\r\n                        'division_name': division_names.get(division, division.upper()),\r\n                        'url': full_url,\r\n                        'relative_url': src\r\n                    })\r\n            \r\n            return lists\r\n        except Exception as e:\r\n            print(f\"Error parsing national lists page: {e}\")\r\n            raise e\r\n\r\n    def __get_divisions_perf_lists(self, divisions_list):\r\n        \"\"\"For each discovered division, scrape the division page to extract individual performance list URLs\"\"\"\r\n        try:\r\n            perf_lists = {\r\n                'indoor': [],\r\n                'outdoor': []\r\n            }\r\n            for season in ['indoor', 'outdoor']:\r\n                for division in divisions_list[season]:\r\n                    division_url = division['url']\r\n                    division_page_content = self.scrape_url(division_url)\r\n\r\n                    # Parse page content to bs4 and extract performance list Urls\r\n                    division_bs4 = self.text_to_bs4(division_page_content)\r\n                    division_perf_lists = self.__parse_division_perf_lists(division_bs4, season, division['division_code'])\r\n                    \r\n                    # Add to discovered performance lists\r\n                    perf_lists[season].extend(division_perf_lists)\r\n\r\n            # Filter out divisional lists from performance lists\r\n            perf_lists['indoor'] = self.__filter_unwanted_divisions(perf_lists['indoor'])\r\n            perf_lists['outdoor'] = self.__filter_unwanted_divisions(perf_lists['outdoor'])\r\n\r\n            return perf_lists\r\n        except Exception as e:\r\n            print(f\"Error discovering performance lists for divisions: {e}\")\r\n            raise e\r\n        \r\n    def __filter_unwanted_divisions(self, perf_lists):\r\n        \"\"\"Filter out divisional performance lists based on predefined ignore list\"\"\"\r\n        try:\r\n            filtered_lists = []\r\n            for perf_list in perf_lists:\r\n                name = perf_list['name'].lower()\r\n                if not any(ignore in name for ignore in self.__divisional_lists_to_ignore):\r\n                    filtered_lists.append(perf_list)\r\n            return filtered_lists\r\n        except Exception as e:\r\n            print(f\"Error filtering divisional performance lists: {e}\")\r\n            raise e\r\n    \r\n    def __parse_division_perf_lists(self, page_bs4, season: str, division_code: str):\r\n        \"\"\"Parse division page to extract individual performance list URLs\"\"\"\r\n        try:\r\n            perf_lists = []\r\n            \r\n            # Find the turbo-frame that contains the division data\r\n            turbo_frame = page_bs4.find('turbo-frame', id=f'directory_tab_{division_code}')\r\n            \r\n            if not turbo_frame:\r\n                print(f\"Warning: No turbo-frame found for division {division_code}\")\r\n                return perf_lists\r\n            \r\n            # Find all list items containing performance lists\r\n            list_items = turbo_frame.find_all('li')\r\n            \r\n            for li in list_items:\r\n                # Find the first anchor tag (main conference/list link)\r\n                main_link = li.find('a', attrs={'data-turbo-frame': '_top'})\r\n                \r\n                if main_link and main_link.get('href'):\r\n                    name = main_link.get_text(strip=True)\r\n                    list_url = main_link.get('href')\r\n                    \r\n                    # Find gender-specific links\r\n                    women_link = li.find('a', href=lambda x: x and 'gender=f' in x)\r\n                    men_link = li.find('a', href=lambda x: x and 'gender=m' in x)\r\n                    \r\n                    perf_list_data = {\r\n                        'name': name,\r\n                        'season': season,\r\n                        'division_code': division_code,\r\n                        'url': list_url,\r\n                        'women_url': women_link.get('href') if women_link else None,\r\n                        'men_url': men_link.get('href') if men_link else None\r\n                    }\r\n                    \r\n                    perf_lists.append(perf_list_data)\r\n            \r\n            return perf_lists\r\n        except Exception as e:\r\n            print(f\"Error parsing division performance lists: {e}\")\r\n            raise e",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\usecase\\tffrs\\tffrs_catalog_usecase.py",
    "function_name": "TffrsCatalogUseCase",
    "start_line": 5,
    "end_line": 220,
    "language": "python",
    "chunk_type": "class"
  },
  {
    "content": "def __init__(self):\r\n        super().__init__(usecase_name=\"TFFRS Catalog Use Case\", module_name=\"Tffrs-Catalog-UseCase\")\r\n\r\n        self.__indoor_divisions_url = \"https://tf.tfrrs.org/indoor_lists.html\"\r\n        self.__outdoor_divisions_url = \"https://tf.tfrrs.org/outdoor_lists.html\"\r\n        \r\n        self.__allowed_divisions = ['d1', 'd2', 'd3', 'naia']\r\n\r\n        self.__divisional_lists_to_ignore = [\r\n            \"indoor qualifying list\",\r\n            \"di great lakes region\",\r\n            \"di mid-atlantic region\",\r\n            \"di midwest region\",\r\n            \"di mountain region\",\r\n            \"di northeast region\",\r\n            \"di south central region\",\r\n            \"di south region\",\r\n            \"di southeast region\",\r\n            \"di west region\",\r\n            \"dii atlantic region\",\r\n            \"dii central region\",\r\n            \"dii east region\",\r\n            \"dii midwest region\",\r\n            \"dii south central region\",\r\n            \"dii south region\",\r\n            \"dii southeast region\",\r\n            \"dii west region\",\r\n            \"diii east region\",\r\n            \"diii great lakes region\",\r\n            \"diii metro region\",\r\n            \"diii mid-atlantic region\",\r\n            \"diii mideast region\",\r\n            \"diii midwest region\",\r\n            \"diii niagara region\",\r\n            \"diii north region\",\r\n            \"diii south region\",\r\n            \"diii west region\",\r\n            # specifc to outdoor lists\r\n            \"combined list\",\r\n            \"east qualifying list\",\r\n            \"west qualifying list\",\r\n            \"outdoor qualifying list\",\r\n            # non-conference aggregates and regional bodies\r\n            \"ic4a/ecac\",\r\n            \"neicaaa\",\r\n            \"hbcu\",\r\n            \"diii all-ohio\",\r\n            \"diii new england\",\r\n            \"aartfc\",\r\n            \"ecac diii\",\r\n            \"mets\",\r\n            \"frozen 8\"\r\n        ]",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\usecase\\tffrs\\tffrs_catalog_usecase.py",
    "function_name": "__init__",
    "start_line": 6,
    "end_line": 58,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "def execute(self):\r\n        divisions_list = self.__catalog_national_divisions()\r\n        return self.__get_divisions_perf_lists(divisions_list)",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\usecase\\tffrs\\tffrs_catalog_usecase.py",
    "function_name": "execute",
    "start_line": 60,
    "end_line": 62,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "def __catalog_national_divisions(self) -> dict:\r\n        \"\"\"Discover TFFRS lists by scraping the relevant page and extracting list URLs\"\"\"\r\n        try:\r\n            indoor_page_content = self.scrape_url(self.__indoor_divisions_url)\r\n            outdoor_page_content = self.scrape_url(self.__outdoor_divisions_url)\r\n\r\n            # Parse page content to bs4 and extract list Urls\r\n            indoor_bs4 = self.text_to_bs4(indoor_page_content)\r\n            outdoor_bs4 = self.text_to_bs4(outdoor_page_content)\r\n            \r\n            discovered_divisions = {\r\n                'indoor': self.__parse_national_list(indoor_bs4),\r\n                'outdoor': self.__parse_national_list(outdoor_bs4)\r\n            }\r\n            \r\n            log_info(f\"Discovered national divisions: {discovered_divisions}\", module=self.module_name, \r\n                data={\r\n                'indoor_divisions_count': len(discovered_divisions['indoor']),\r\n                'outdoor_divisions_count': len(discovered_divisions['outdoor']),\r\n                }\r\n            )\r\n            \r\n            return discovered_divisions\r\n        except Exception as e:\r\n            log_error(message=f\"Error obtaining national divisions: {e}\", module=self.module_name, data={})\r\n            raise e",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\usecase\\tffrs\\tffrs_catalog_usecase.py",
    "function_name": "__catalog_national_divisions",
    "start_line": 66,
    "end_line": 91,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "def __parse_national_list(self, page_bs4):\r\n        \"\"\"Parse the national lists page to extract list URLs and metadata\"\"\"\r\n        try:\r\n            lists = []\r\n            \r\n            # Find all turbo-frame elements that contain division-specific list data\r\n            turbo_frames = page_bs4.find_all('turbo-frame', id=lambda x: x and x.startswith('directory_tab_'))\r\n            \r\n            for frame in turbo_frames:\r\n                src = frame.get('src')\r\n                frame_id = frame.get('id')\r\n                \r\n                if src:\r\n                    # Extract division/tab name from frame_id (e.g., 'directory_tab_d1' -> 'd1')\r\n                    division = frame_id.replace('directory_tab_', '') if frame_id else 'unknown'\r\n                    \r\n                    # Map division codes to readable names\r\n                    division_names = {\r\n                        'd1': 'NCAA Division I',\r\n                        'd2': 'NCAA Division II',\r\n                        'd3': 'NCAA Division III',\r\n                        'naia': 'NAIA',\r\n                        'njcaa': 'NJCAA',\r\n                        'nccaa': 'NCCAA'\r\n                    }\r\n                    \r\n                    # Build full URL (base URL is https://tf.tfrrs.org)\r\n                    full_url = f\"https://tf.tfrrs.org{src}\"\r\n                    \r\n                    # Only include allowed divisions\r\n                    if division not in self.__allowed_divisions:\r\n                        continue\r\n\r\n                    lists.append({\r\n                        'division_code': division,\r\n                        'division_name': division_names.get(division, division.upper()),\r\n                        'url': full_url,\r\n                        'relative_url': src\r\n                    })\r\n            \r\n            return lists\r\n        except Exception as e:\r\n            print(f\"Error parsing national lists page: {e}\")\r\n            raise e",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\usecase\\tffrs\\tffrs_catalog_usecase.py",
    "function_name": "__parse_national_list",
    "start_line": 93,
    "end_line": 136,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "def __get_divisions_perf_lists(self, divisions_list):\r\n        \"\"\"For each discovered division, scrape the division page to extract individual performance list URLs\"\"\"\r\n        try:\r\n            perf_lists = {\r\n                'indoor': [],\r\n                'outdoor': []\r\n            }\r\n            for season in ['indoor', 'outdoor']:\r\n                for division in divisions_list[season]:\r\n                    division_url = division['url']\r\n                    division_page_content = self.scrape_url(division_url)\r\n\r\n                    # Parse page content to bs4 and extract performance list Urls\r\n                    division_bs4 = self.text_to_bs4(division_page_content)\r\n                    division_perf_lists = self.__parse_division_perf_lists(division_bs4, season, division['division_code'])\r\n                    \r\n                    # Add to discovered performance lists\r\n                    perf_lists[season].extend(division_perf_lists)\r\n\r\n            # Filter out divisional lists from performance lists\r\n            perf_lists['indoor'] = self.__filter_unwanted_divisions(perf_lists['indoor'])\r\n            perf_lists['outdoor'] = self.__filter_unwanted_divisions(perf_lists['outdoor'])\r\n\r\n            return perf_lists\r\n        except Exception as e:\r\n            print(f\"Error discovering performance lists for divisions: {e}\")\r\n            raise e",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\usecase\\tffrs\\tffrs_catalog_usecase.py",
    "function_name": "__get_divisions_perf_lists",
    "start_line": 138,
    "end_line": 164,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "def __filter_unwanted_divisions(self, perf_lists):\r\n        \"\"\"Filter out divisional performance lists based on predefined ignore list\"\"\"\r\n        try:\r\n            filtered_lists = []\r\n            for perf_list in perf_lists:\r\n                name = perf_list['name'].lower()\r\n                if not any(ignore in name for ignore in self.__divisional_lists_to_ignore):\r\n                    filtered_lists.append(perf_list)\r\n            return filtered_lists\r\n        except Exception as e:\r\n            print(f\"Error filtering divisional performance lists: {e}\")\r\n            raise e",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\usecase\\tffrs\\tffrs_catalog_usecase.py",
    "function_name": "__filter_unwanted_divisions",
    "start_line": 166,
    "end_line": 177,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "def __parse_division_perf_lists(self, page_bs4, season: str, division_code: str):\r\n        \"\"\"Parse division page to extract individual performance list URLs\"\"\"\r\n        try:\r\n            perf_lists = []\r\n            \r\n            # Find the turbo-frame that contains the division data\r\n            turbo_frame = page_bs4.find('turbo-frame', id=f'directory_tab_{division_code}')\r\n            \r\n            if not turbo_frame:\r\n                print(f\"Warning: No turbo-frame found for division {division_code}\")\r\n                return perf_lists\r\n            \r\n            # Find all list items containing performance lists\r\n            list_items = turbo_frame.find_all('li')\r\n            \r\n            for li in list_items:\r\n                # Find the first anchor tag (main conference/list link)\r\n                main_link = li.find('a', attrs={'data-turbo-frame': '_top'})\r\n                \r\n                if main_link and main_link.get('href'):\r\n                    name = main_link.get_text(strip=True)\r\n                    list_url = main_link.get('href')\r\n                    \r\n                    # Find gender-specific links\r\n                    women_link = li.find('a', href=lambda x: x and 'gender=f' in x)\r\n                    men_link = li.find('a', href=lambda x: x and 'gender=m' in x)\r\n                    \r\n                    perf_list_data = {\r\n                        'name': name,\r\n                        'season': season,\r\n                        'division_code': division_code,\r\n                        'url': list_url,\r\n                        'women_url': women_link.get('href') if women_link else None,\r\n                        'men_url': men_link.get('href') if men_link else None\r\n                    }\r\n                    \r\n                    perf_lists.append(perf_list_data)\r\n            \r\n            return perf_lists\r\n        except Exception as e:\r\n            print(f\"Error parsing division performance lists: {e}\")\r\n            raise e",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\usecase\\tffrs\\tffrs_catalog_usecase.py",
    "function_name": "__parse_division_perf_lists",
    "start_line": 179,
    "end_line": 220,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "class TffrsTeamsCatalogUseCase(ScrapingUseCase):\r\n    def __init__(self):\r\n        super().__init__(usecase_name=\"TFFRS Teams Catalog Use Case\", module_name=\"Tffrs-Teams-Catalog-UseCase\")\r\n        \r\n        max_concurrent_requests = 20\r\n        self.semaphore = asyncio.Semaphore(max_concurrent_requests)\r\n    \r\n    def execute(self, conferences: dict[str, list[dict]]) -> tuple[pd.DataFrame, dict]:\r\n        \"\"\"Execute the team catalog scraping.\r\n\r\n        Returns:\r\n            Tuple of (performances_df, teams_dict) where teams_dict is\r\n            keyed by team_url with team metadata.\r\n        \"\"\"\r\n        return asyncio.run(self.__execute_async(conferences))\r\n    \r\n    async def __execute_async(self, conferences: dict[str, list[dict]]) -> tuple[pd.DataFrame, dict]:\r\n        flattened_data = []\r\n        teams_dict: dict[str, dict] = {}  # keyed by team_url\r\n        current_month = datetime.now().month\r\n        \r\n        async with aiohttp.ClientSession() as session:\r\n            for season, confs in conferences.items():\r\n                \r\n                # Determine if season needs to be scraped. \r\n                # For outdoor: only scrape when month >= March && month <= June\r\n                # For indoor: only scrape when month >= December || month <= March\r\n                should_scrape = self._should_scrape_season(season, current_month)\r\n                \r\n                if not should_scrape:\r\n                    log_info(\r\n                        message=f\"Skipping season '{season}' - not in valid scraping period (current month: {current_month})\",\r\n                        module=self.module_name,\r\n                        data={}\r\n                    )\r\n                    continue\r\n                \r\n                log_info(\r\n                    message=f\"Starting scraping for season '{season}' ({len(confs)} conferences, current month: {current_month})\",\r\n                    module=self.module_name,\r\n                    data={}\r\n                )\r\n                \r\n                async def scrape_with_limit(conf):\r\n                    async with self.semaphore:\r\n                        return await self.__scrape_conference_async(session, conf)\r\n                \r\n                # Gather all results for this season\r\n                tasks = [scrape_with_limit(conf) for conf in confs]\r\n                results = await asyncio.gather(*tasks, return_exceptions=True)\r\n                \r\n                # Process results and flatten into DataFrame rows\r\n                for conf, result in zip(confs, results):\r\n                    conf_start_time = asyncio.get_event_loop().time()\r\n                    conference_name = conf.get('name', '')\r\n                    \r\n                    if isinstance(result, Exception):\r\n                        print(f\"Error for {conf['name']}: {result}\")\r\n                        continue\r\n                    \r\n                    if not isinstance(result, dict):\r\n                        continue\r\n                    \r\n                    conference_url = conf.get('url', '')\r\n                    division_code = conf.get('division_code', '')\r\n                    team_count = len(result)\r\n                    total_performances = 0\r\n                    \r\n                    # Flatten the nested structure\r\n                    for team_name, performances in result.items():\r\n                        for performance in performances:\r\n                            team_url = performance.get('team_url')\r\n                            flat_record = {\r\n                                'season': season,\r\n                                'conference_name': conference_name,\r\n                                'conference_url': conference_url,\r\n                                'division_code': division_code,\r\n                                **performance\r\n                            }\r\n                            flattened_data.append(flat_record)\r\n                            \r\n                            # Collect unique teams keyed by team_url\r\n                            if team_url and team_url not in teams_dict:\r\n                                teams_dict[team_url] = {\r\n                                    'team_name': team_name,\r\n                                    'team_url': team_url,\r\n                                    'conference_name': conference_name,\r\n                                    'division_code': division_code,\r\n                                    'season': season,\r\n                                }\r\n                        total_performances += len(performances)\r\n                        \r\n                    \r\n                    conf_end_time = asyncio.get_event_loop().time()\r\n                    log_info(\r\n                        message=f\"Finished processing conference: {conference_name}. Teams: {team_count}, Performances: {total_performances}, Processing Time: {conf_end_time - conf_start_time:.4f} seconds\",\r\n                        module=self.module_name,\r\n                        data={}\r\n                    )\r\n                    \r\n        df = pd.DataFrame(flattened_data)\r\n        \r\n        # sort by season =>, confernce_name =>, event, gender,  place\r\n        df.sort_values(by=['season', 'conference_name', 'event', 'gender', 'place'], inplace=True)\r\n        \r\n        log_info(\r\n            message=f\"Collected {len(teams_dict)} unique teams across all conferences\",\r\n            module=self.module_name,\r\n            data={}\r\n        )\r\n        \r\n        return df, teams_dict\r\n    \r\n    def _should_scrape_season(self, season: str, current_month: int) -> bool:\r\n        \"\"\"\r\n        Determine if a season should be scraped based on the current month.\r\n        \r\n        Args:\r\n            season: Season string (e.g., \"Indoor 2026\", \"Outdoor 2026\")\r\n            current_month: Current month (1-12)\r\n            \r\n        Returns:\r\n            bool: True if season should be scraped, False otherwise\r\n        \"\"\"\r\n        season_lower = season.lower()\r\n        \r\n        # Check for outdoor season (March-June: months 3-6)\r\n        if 'outdoor' in season_lower:\r\n            return 3 <= current_month <= 6\r\n        \r\n        # Check for indoor season (December-February: months 12, 1, 2, 3)\r\n        if 'indoor' in season_lower:\r\n            return current_month == 12 or current_month <= 3\r\n        \r\n        # If season type cannot be determined, log warning and skip\r\n        log_error(\r\n            message=f\"Unknown season type: '{season}'. Cannot determine scraping period. Skipping.\",\r\n            module=self.module_name,\r\n            data={}\r\n        )\r\n        return False\r\n    \r\n    async def __scrape_conference_async(self, session: aiohttp.ClientSession, conference: dict) -> dict:\r\n        \"\"\"Async version of __scrape_conference\"\"\"\r\n        url = conference['url']\r\n        list_id = url.split('/lists/')[1].split('/')[0]\r\n        url_encoded = quote(url, safe='')\r\n        crafted_url = f\"https://tf.tfrrs.org/list_data/{list_id}?other_lists={url_encoded}&limit=500&event_type=&year=&gender=\"\r\n        \r\n        page_content = await self.scrape_url_async(session, crafted_url)\r\n        conference_data_bs4 = self.text_to_bs4(page_content)\r\n        \r\n        return self.__parse_data_from_conference_perf_page(conference_data_bs4)\r\n                        \r\n    def __parse_data_from_conference_perf_page(self, conference_data_bs4):\r\n        \"\"\"\r\n        Parse conference performance page and extract athlete performances grouped by team.\r\n        \r\n        Args:\r\n            conference_data_bs4: BeautifulSoup object of the conference performance page\r\n            \r\n        Returns:\r\n            dict: {team_name: [list of performance dicts]}\r\n        \"\"\"\r\n        teams_data = {}\r\n        \r\n        # Find all event blocks (divs with class containing 'standard_event_hnd')\r\n        event_divs = conference_data_bs4.find_all('div', class_=lambda x: x and 'standard_event_hnd' in x)\r\n        \r\n        for event_div in event_divs:\r\n            # Extract event name and gender from the header\r\n            event_header = event_div.find('h3', class_='font-weight-500')\r\n            if not event_header:\r\n                continue\r\n                \r\n            event_text = event_header.get_text(strip=True)\r\n            # Parse \"60 Meters (Men)\" -> event=\"60 Meters\", gender=\"Men\"\r\n            if '(' in event_text:\r\n                event_name = event_text.split('(')[0].strip()\r\n                gender = event_text.split('(')[1].replace(')', '').strip()\r\n            else:\r\n                event_name = event_text\r\n                # Fallback: check class for gender\r\n                classes = event_div.get('class', [])\r\n                gender = 'Men' if 'gender_m' in classes else 'Women'\r\n            \r\n            # Find the performance list body containing all rows for this event\r\n            perf_list_body = event_div.find('div', class_='performance-list-body')\r\n            if not perf_list_body:\r\n                continue\r\n            \r\n            # Find all performance rows\r\n            perf_rows = perf_list_body.find_all('div', class_='performance-list-row')\r\n            \r\n            for row in perf_rows:\r\n                # Extract place\r\n                place_div = row.find('div', class_='col-place')\r\n                place_link = place_div.find('a') if place_div else None\r\n                place = place_link.get_text(strip=True) if place_link else (place_div.get_text(strip=True) if place_div else None)\r\n                \r\n                # Extract athlete name and URL\r\n                athlete_div = row.find('div', class_='col-athlete')\r\n                athlete_link = athlete_div.find('a') if athlete_div else None\r\n                athlete_name = athlete_link.get_text(strip=True) if athlete_link else None\r\n                athlete_url = athlete_link.get('href') if athlete_link else None\r\n                \r\n                # Extract year\r\n                year_div = row.find('div', attrs={'data-label': 'Year'})\r\n                year = year_div.get_text(strip=True) if year_div else None\r\n                \r\n                # Extract team name and URL\r\n                team_div = row.find('div', class_='col-team')\r\n                team_link = team_div.find('a') if team_div else None\r\n                team_name = team_link.get_text(strip=True) if team_link else None\r\n                team_url = team_link.get('href') if team_link else None\r\n                \r\n                if not team_name:\r\n                    continue  # Skip rows without team info\r\n                \r\n                # Extract mark/time and URL (running events use \"Time\", field events use \"Mark\")\r\n                mark_div = row.find('div', attrs={'data-label': 'Time'})\r\n                if not mark_div:\r\n                    mark_div = row.find('div', attrs={'data-label': 'Mark'})\r\n                mark_link = mark_div.find('a') if mark_div else None\r\n                mark = mark_link.get_text(strip=True) if mark_link else (mark_div.get_text(strip=True) if mark_div else None)\r\n                mark_url = mark_link.get('href') if mark_link else None\r\n                \r\n                # If no mark, check for points (e.g., multi-events)\r\n                if not mark:\r\n                    points_div = row.find('div', attrs={'data-label': 'Points'})\r\n                    if points_div:\r\n                        points_link = points_div.find('a')\r\n                        mark = points_link.get_text(strip=True) if points_link else points_div.get_text(strip=True)\r\n                        if not mark_url:\r\n                            mark_url = points_link.get('href') if points_link else None\r\n                \r\n                # Extract meet name and URL\r\n                meet_div = row.find('div', class_='col-meet')\r\n                meet_link = meet_div.find('a') if meet_div else None\r\n                meet_name = meet_link.get_text(strip=True) if meet_link else None\r\n                meet_url = meet_link.get('href') if meet_link else None\r\n                \r\n                # Extract meet date\r\n                date_div = row.find('div', attrs={'data-label': 'Meet Date'})\r\n                meet_date = date_div.get_text(strip=True) if date_div else None\r\n                \r\n                # Create performance dict\r\n                performance = {\r\n                    'event': event_name,\r\n                    'gender': gender,\r\n                    'place': place,\r\n                    'athlete_name': athlete_name,\r\n                    'athlete_url': athlete_url,\r\n                    'year': year,\r\n                    'team_name': team_name,\r\n                    'team_url': team_url,\r\n                    'mark': mark,\r\n                    'mark_url': mark_url,\r\n                    'meet_name': meet_name,\r\n                    'meet_url': meet_url,\r\n                    'meet_date': meet_date\r\n                }\r\n                \r\n                # Group by team\r\n                if team_name not in teams_data:\r\n                    teams_data[team_name] = []\r\n                teams_data[team_name].append(performance)\r\n        \r\n        return teams_data",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\usecase\\tffrs\\tffs_team_catalog_usecase.py",
    "function_name": "TffrsTeamsCatalogUseCase",
    "start_line": 10,
    "end_line": 278,
    "language": "python",
    "chunk_type": "class"
  },
  {
    "content": "def __init__(self):\r\n        super().__init__(usecase_name=\"TFFRS Teams Catalog Use Case\", module_name=\"Tffrs-Teams-Catalog-UseCase\")\r\n        \r\n        max_concurrent_requests = 20\r\n        self.semaphore = asyncio.Semaphore(max_concurrent_requests)",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\usecase\\tffrs\\tffs_team_catalog_usecase.py",
    "function_name": "__init__",
    "start_line": 11,
    "end_line": 15,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "def execute(self, conferences: dict[str, list[dict]]) -> tuple[pd.DataFrame, dict]:\r\n        \"\"\"Execute the team catalog scraping.\r\n\r\n        Returns:\r\n            Tuple of (performances_df, teams_dict) where teams_dict is\r\n            keyed by team_url with team metadata.\r\n        \"\"\"\r\n        return asyncio.run(self.__execute_async(conferences))",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\usecase\\tffrs\\tffs_team_catalog_usecase.py",
    "function_name": "execute",
    "start_line": 17,
    "end_line": 24,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "async def __execute_async(self, conferences: dict[str, list[dict]]) -> tuple[pd.DataFrame, dict]:\r\n        flattened_data = []\r\n        teams_dict: dict[str, dict] = {}  # keyed by team_url\r\n        current_month = datetime.now().month\r\n        \r\n        async with aiohttp.ClientSession() as session:\r\n            for season, confs in conferences.items():\r\n                \r\n                # Determine if season needs to be scraped. \r\n                # For outdoor: only scrape when month >= March && month <= June\r\n                # For indoor: only scrape when month >= December || month <= March\r\n                should_scrape = self._should_scrape_season(season, current_month)\r\n                \r\n                if not should_scrape:\r\n                    log_info(\r\n                        message=f\"Skipping season '{season}' - not in valid scraping period (current month: {current_month})\",\r\n                        module=self.module_name,\r\n                        data={}\r\n                    )\r\n                    continue\r\n                \r\n                log_info(\r\n                    message=f\"Starting scraping for season '{season}' ({len(confs)} conferences, current month: {current_month})\",\r\n                    module=self.module_name,\r\n                    data={}\r\n                )\r\n                \r\n                async def scrape_with_limit(conf):\r\n                    async with self.semaphore:\r\n                        return await self.__scrape_conference_async(session, conf)\r\n                \r\n                # Gather all results for this season\r\n                tasks = [scrape_with_limit(conf) for conf in confs]\r\n                results = await asyncio.gather(*tasks, return_exceptions=True)\r\n                \r\n                # Process results and flatten into DataFrame rows\r\n                for conf, result in zip(confs, results):\r\n                    conf_start_time = asyncio.get_event_loop().time()\r\n                    conference_name = conf.get('name', '')\r\n                    \r\n                    if isinstance(result, Exception):\r\n                        print(f\"Error for {conf['name']}: {result}\")\r\n                        continue\r\n                    \r\n                    if not isinstance(result, dict):\r\n                        continue\r\n                    \r\n                    conference_url = conf.get('url', '')\r\n                    division_code = conf.get('division_code', '')\r\n                    team_count = len(result)\r\n                    total_performances = 0\r\n                    \r\n                    # Flatten the nested structure\r\n                    for team_name, performances in result.items():\r\n                        for performance in performances:\r\n                            team_url = performance.get('team_url')\r\n                            flat_record = {\r\n                                'season': season,\r\n                                'conference_name': conference_name,\r\n                                'conference_url': conference_url,\r\n                                'division_code': division_code,\r\n                                **performance\r\n                            }\r\n                            flattened_data.append(flat_record)\r\n                            \r\n                            # Collect unique teams keyed by team_url\r\n                            if team_url and team_url not in teams_dict:\r\n                                teams_dict[team_url] = {\r\n                                    'team_name': team_name,\r\n                                    'team_url': team_url,\r\n                                    'conference_name': conference_name,\r\n                                    'division_code': division_code,\r\n                                    'season': season,\r\n                                }\r\n                        total_performances += len(performances)\r\n                        \r\n                    \r\n                    conf_end_time = asyncio.get_event_loop().time()\r\n                    log_info(\r\n                        message=f\"Finished processing conference: {conference_name}. Teams: {team_count}, Performances: {total_performances}, Processing Time: {conf_end_time - conf_start_time:.4f} seconds\",\r\n                        module=self.module_name,\r\n                        data={}\r\n                    )\r\n                    \r\n        df = pd.DataFrame(flattened_data)\r\n        \r\n        # sort by season =>, confernce_name =>, event, gender,  place\r\n        df.sort_values(by=['season', 'conference_name', 'event', 'gender', 'place'], inplace=True)\r\n        \r\n        log_info(\r\n            message=f\"Collected {len(teams_dict)} unique teams across all conferences\",\r\n            module=self.module_name,\r\n            data={}\r\n        )\r\n        \r\n        return df, teams_dict",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\usecase\\tffrs\\tffs_team_catalog_usecase.py",
    "function_name": "__execute_async",
    "start_line": 26,
    "end_line": 121,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "async def scrape_with_limit(conf):\r\n                    async with self.semaphore:\r\n                        return await self.__scrape_conference_async(session, conf)",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\usecase\\tffrs\\tffs_team_catalog_usecase.py",
    "function_name": "scrape_with_limit",
    "start_line": 53,
    "end_line": 55,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "def _should_scrape_season(self, season: str, current_month: int) -> bool:\r\n        \"\"\"\r\n        Determine if a season should be scraped based on the current month.\r\n        \r\n        Args:\r\n            season: Season string (e.g., \"Indoor 2026\", \"Outdoor 2026\")\r\n            current_month: Current month (1-12)\r\n            \r\n        Returns:\r\n            bool: True if season should be scraped, False otherwise\r\n        \"\"\"\r\n        season_lower = season.lower()\r\n        \r\n        # Check for outdoor season (March-June: months 3-6)\r\n        if 'outdoor' in season_lower:\r\n            return 3 <= current_month <= 6\r\n        \r\n        # Check for indoor season (December-February: months 12, 1, 2, 3)\r\n        if 'indoor' in season_lower:\r\n            return current_month == 12 or current_month <= 3\r\n        \r\n        # If season type cannot be determined, log warning and skip\r\n        log_error(\r\n            message=f\"Unknown season type: '{season}'. Cannot determine scraping period. Skipping.\",\r\n            module=self.module_name,\r\n            data={}\r\n        )\r\n        return False",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\usecase\\tffrs\\tffs_team_catalog_usecase.py",
    "function_name": "_should_scrape_season",
    "start_line": 123,
    "end_line": 150,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "async def __scrape_conference_async(self, session: aiohttp.ClientSession, conference: dict) -> dict:\r\n        \"\"\"Async version of __scrape_conference\"\"\"\r\n        url = conference['url']\r\n        list_id = url.split('/lists/')[1].split('/')[0]\r\n        url_encoded = quote(url, safe='')\r\n        crafted_url = f\"https://tf.tfrrs.org/list_data/{list_id}?other_lists={url_encoded}&limit=500&event_type=&year=&gender=\"\r\n        \r\n        page_content = await self.scrape_url_async(session, crafted_url)\r\n        conference_data_bs4 = self.text_to_bs4(page_content)\r\n        \r\n        return self.__parse_data_from_conference_perf_page(conference_data_bs4)",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\usecase\\tffrs\\tffs_team_catalog_usecase.py",
    "function_name": "__scrape_conference_async",
    "start_line": 152,
    "end_line": 162,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "def __parse_data_from_conference_perf_page(self, conference_data_bs4):\r\n        \"\"\"\r\n        Parse conference performance page and extract athlete performances grouped by team.\r\n        \r\n        Args:\r\n            conference_data_bs4: BeautifulSoup object of the conference performance page\r\n            \r\n        Returns:\r\n            dict: {team_name: [list of performance dicts]}\r\n        \"\"\"\r\n        teams_data = {}\r\n        \r\n        # Find all event blocks (divs with class containing 'standard_event_hnd')\r\n        event_divs = conference_data_bs4.find_all('div', class_=lambda x: x and 'standard_event_hnd' in x)\r\n        \r\n        for event_div in event_divs:\r\n            # Extract event name and gender from the header\r\n            event_header = event_div.find('h3', class_='font-weight-500')\r\n            if not event_header:\r\n                continue\r\n                \r\n            event_text = event_header.get_text(strip=True)\r\n            # Parse \"60 Meters (Men)\" -> event=\"60 Meters\", gender=\"Men\"\r\n            if '(' in event_text:\r\n                event_name = event_text.split('(')[0].strip()\r\n                gender = event_text.split('(')[1].replace(')', '').strip()\r\n            else:\r\n                event_name = event_text\r\n                # Fallback: check class for gender\r\n                classes = event_div.get('class', [])\r\n                gender = 'Men' if 'gender_m' in classes else 'Women'\r\n            \r\n            # Find the performance list body containing all rows for this event\r\n            perf_list_body = event_div.find('div', class_='performance-list-body')\r\n            if not perf_list_body:\r\n                continue\r\n            \r\n            # Find all performance rows\r\n            perf_rows = perf_list_body.find_all('div', class_='performance-list-row')\r\n            \r\n            for row in perf_rows:\r\n                # Extract place\r\n                place_div = row.find('div', class_='col-place')\r\n                place_link = place_div.find('a') if place_div else None\r\n                place = place_link.get_text(strip=True) if place_link else (place_div.get_text(strip=True) if place_div else None)\r\n                \r\n                # Extract athlete name and URL\r\n                athlete_div = row.find('div', class_='col-athlete')\r\n                athlete_link = athlete_div.find('a') if athlete_div else None\r\n                athlete_name = athlete_link.get_text(strip=True) if athlete_link else None\r\n                athlete_url = athlete_link.get('href') if athlete_link else None\r\n                \r\n                # Extract year\r\n                year_div = row.find('div', attrs={'data-label': 'Year'})\r\n                year = year_div.get_text(strip=True) if year_div else None\r\n                \r\n                # Extract team name and URL\r\n                team_div = row.find('div', class_='col-team')\r\n                team_link = team_div.find('a') if team_div else None\r\n                team_name = team_link.get_text(strip=True) if team_link else None\r\n                team_url = team_link.get('href') if team_link else None\r\n                \r\n                if not team_name:\r\n                    continue  # Skip rows without team info\r\n                \r\n                # Extract mark/time and URL (running events use \"Time\", field events use \"Mark\")\r\n                mark_div = row.find('div', attrs={'data-label': 'Time'})\r\n                if not mark_div:\r\n                    mark_div = row.find('div', attrs={'data-label': 'Mark'})\r\n                mark_link = mark_div.find('a') if mark_div else None\r\n                mark = mark_link.get_text(strip=True) if mark_link else (mark_div.get_text(strip=True) if mark_div else None)\r\n                mark_url = mark_link.get('href') if mark_link else None\r\n                \r\n                # If no mark, check for points (e.g., multi-events)\r\n                if not mark:\r\n                    points_div = row.find('div', attrs={'data-label': 'Points'})\r\n                    if points_div:\r\n                        points_link = points_div.find('a')\r\n                        mark = points_link.get_text(strip=True) if points_link else points_div.get_text(strip=True)\r\n                        if not mark_url:\r\n                            mark_url = points_link.get('href') if points_link else None\r\n                \r\n                # Extract meet name and URL\r\n                meet_div = row.find('div', class_='col-meet')\r\n                meet_link = meet_div.find('a') if meet_div else None\r\n                meet_name = meet_link.get_text(strip=True) if meet_link else None\r\n                meet_url = meet_link.get('href') if meet_link else None\r\n                \r\n                # Extract meet date\r\n                date_div = row.find('div', attrs={'data-label': 'Meet Date'})\r\n                meet_date = date_div.get_text(strip=True) if date_div else None\r\n                \r\n                # Create performance dict\r\n                performance = {\r\n                    'event': event_name,\r\n                    'gender': gender,\r\n                    'place': place,\r\n                    'athlete_name': athlete_name,\r\n                    'athlete_url': athlete_url,\r\n                    'year': year,\r\n                    'team_name': team_name,\r\n                    'team_url': team_url,\r\n                    'mark': mark,\r\n                    'mark_url': mark_url,\r\n                    'meet_name': meet_name,\r\n                    'meet_url': meet_url,\r\n                    'meet_date': meet_date\r\n                }\r\n                \r\n                # Group by team\r\n                if team_name not in teams_data:\r\n                    teams_data[team_name] = []\r\n                teams_data[team_name].append(performance)\r\n        \r\n        return teams_data",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\usecase\\tffrs\\tffs_team_catalog_usecase.py",
    "function_name": "__parse_data_from_conference_perf_page",
    "start_line": 164,
    "end_line": 278,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "def get_logger(module_name):\r\n    logger = logging.getLogger(module_name)\r\n    logger.setLevel(logging.INFO)\r\n    if not logger.hasHandlers():\r\n        handler = logging.StreamHandler()\r\n        formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s', datefmt='%H:%M:%S')\r\n        handler.setFormatter(formatter)\r\n        logger.addHandler(handler)\r\n    return logger",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\util\\logger.py",
    "function_name": "get_logger",
    "start_line": 7,
    "end_line": 15,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "def _format_message(message, module, data=None):\r\n    log_object = {\"message\": message}\r\n    if data is not None:\r\n        log_object[\"data\"] = data\r\n    log_object[\"module\"] = module\r\n    if os.getenv(\"env\") == \"dev\":\r\n        return json.dumps(log_object, default=str, indent=2)\r\n    return json.dumps(log_object, default=str)",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\util\\logger.py",
    "function_name": "_format_message",
    "start_line": 18,
    "end_line": 25,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "def log_info(message, module, data=None):\r\n    logger = get_logger(module)\r\n    logger.info(_format_message(message, module, data))",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\util\\logger.py",
    "function_name": "log_info",
    "start_line": 28,
    "end_line": 30,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "def log_warning(message, module, data=None):\r\n    logger = get_logger(module)\r\n    logger.warning(_format_message(message, module, data))",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\util\\logger.py",
    "function_name": "log_warning",
    "start_line": 33,
    "end_line": 35,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "def log_error(message: str, module, data=None):\r\n    logger = get_logger(module)\r\n    logger.error(_format_message(message, module, data))",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\util\\logger.py",
    "function_name": "log_error",
    "start_line": 38,
    "end_line": 40,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "class SecretsManagerError(Exception):\r\n    \"\"\"Exception raised for Secrets Manager errors.\"\"\"\r\n    pass",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\util\\secrets_manager.py",
    "function_name": "SecretsManagerError",
    "start_line": 12,
    "end_line": 14,
    "language": "python",
    "chunk_type": "class"
  },
  {
    "content": "class SecretsManager:\r\n    \"\"\"Fetch secrets from AWS Secrets Manager.\"\"\"\r\n    \r\n    def __init__(self, region_name: str = 'us-east-1'):\r\n        \"\"\"\r\n        Initialize Secrets Manager client.\r\n        \r\n        Args:\r\n            region_name: AWS region where secrets are stored\r\n        \"\"\"\r\n        self.region_name = region_name\r\n        self._client = None\r\n        self._cache: Dict[str, Any] = {}\r\n    \r\n    @property\r\n    def client(self):\r\n        \"\"\"Lazy-load boto3 client to avoid import errors when not needed.\"\"\"\r\n        if self._client is None:\r\n            try:\r\n                import boto3\r\n                self._client = boto3.client('secretsmanager', region_name=self.region_name)\r\n            except ImportError:\r\n                raise SecretsManagerError(\r\n                    \"boto3 is required for Secrets Manager. Install with: pip install boto3\"\r\n                )\r\n        return self._client\r\n    \r\n    def get_secret(self, secret_id: str) -> Dict[str, Any]:\r\n        \"\"\"\r\n        Fetch a secret from AWS Secrets Manager.\r\n        \r\n        Args:\r\n            secret_id: The ARN or name of the secret to retrieve\r\n            \r\n        Returns:\r\n            Dictionary containing the secret key-value pairs\r\n            \r\n        Raises:\r\n            SecretsManagerError: If the secret cannot be retrieved\r\n        \"\"\"\r\n        # Return from cache if already fetched\r\n        if secret_id in self._cache:\r\n            logger.debug(f\"Returning cached secret: {secret_id}\")\r\n            return self._cache[secret_id]\r\n        \r\n        try:\r\n            logger.info(f\"Fetching secret from AWS Secrets Manager: {secret_id}\")\r\n            response = self.client.get_secret_value(SecretId=secret_id)\r\n            \r\n            # Parse the secret string as JSON\r\n            secret_dict = json.loads(response['SecretString'])\r\n            \r\n            # Cache it\r\n            self._cache[secret_id] = secret_dict\r\n            logger.info(f\"Successfully fetched and cached secret: {secret_id}\")\r\n            \r\n            return secret_dict\r\n            \r\n        except Exception as e:\r\n            # Handle boto3 ClientError\r\n            if hasattr(e, 'response'):\r\n                error_code = e.response.get('Error', {}).get('Code', 'Unknown')\r\n                if error_code == 'ResourceNotFoundException':\r\n                    raise SecretsManagerError(f\"Secret '{secret_id}' not found in AWS Secrets Manager\")\r\n                elif error_code == 'AccessDeniedException':\r\n                    raise SecretsManagerError(\r\n                        f\"Access denied to secret '{secret_id}'. Check Lambda IAM permissions.\"\r\n                    )\r\n                else:\r\n                    raise SecretsManagerError(f\"AWS error fetching secret '{secret_id}': {error_code} - {str(e)}\")\r\n            \r\n            # Handle JSON parsing errors\r\n            if isinstance(e, json.JSONDecodeError):\r\n                raise SecretsManagerError(f\"Secret '{secret_id}' is not valid JSON: {str(e)}\")\r\n            \r\n            # Generic error\r\n            raise SecretsManagerError(f\"Error fetching secret '{secret_id}': {str(e)}\")",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\util\\secrets_manager.py",
    "function_name": "SecretsManager",
    "start_line": 17,
    "end_line": 93,
    "language": "python",
    "chunk_type": "class"
  },
  {
    "content": "def __init__(self, region_name: str = 'us-east-1'):\r\n        \"\"\"\r\n        Initialize Secrets Manager client.\r\n        \r\n        Args:\r\n            region_name: AWS region where secrets are stored\r\n        \"\"\"\r\n        self.region_name = region_name\r\n        self._client = None\r\n        self._cache: Dict[str, Any] = {}",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\util\\secrets_manager.py",
    "function_name": "__init__",
    "start_line": 20,
    "end_line": 29,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "@property\r\n    def client(self):\r\n        \"\"\"Lazy-load boto3 client to avoid import errors when not needed.\"\"\"\r\n        if self._client is None:\r\n            try:\r\n                import boto3\r\n                self._client = boto3.client('secretsmanager', region_name=self.region_name)\r\n            except ImportError:\r\n                raise SecretsManagerError(\r\n                    \"boto3 is required for Secrets Manager. Install with: pip install boto3\"\r\n                )\r\n        return self._client",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\util\\secrets_manager.py",
    "function_name": "client",
    "start_line": 31,
    "end_line": 42,
    "language": "python",
    "chunk_type": "decorated"
  },
  {
    "content": "def client(self):\r\n        \"\"\"Lazy-load boto3 client to avoid import errors when not needed.\"\"\"\r\n        if self._client is None:\r\n            try:\r\n                import boto3\r\n                self._client = boto3.client('secretsmanager', region_name=self.region_name)\r\n            except ImportError:\r\n                raise SecretsManagerError(\r\n                    \"boto3 is required for Secrets Manager. Install with: pip install boto3\"\r\n                )\r\n        return self._client",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\util\\secrets_manager.py",
    "function_name": "client",
    "start_line": 32,
    "end_line": 42,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "def get_secret(self, secret_id: str) -> Dict[str, Any]:\r\n        \"\"\"\r\n        Fetch a secret from AWS Secrets Manager.\r\n        \r\n        Args:\r\n            secret_id: The ARN or name of the secret to retrieve\r\n            \r\n        Returns:\r\n            Dictionary containing the secret key-value pairs\r\n            \r\n        Raises:\r\n            SecretsManagerError: If the secret cannot be retrieved\r\n        \"\"\"\r\n        # Return from cache if already fetched\r\n        if secret_id in self._cache:\r\n            logger.debug(f\"Returning cached secret: {secret_id}\")\r\n            return self._cache[secret_id]\r\n        \r\n        try:\r\n            logger.info(f\"Fetching secret from AWS Secrets Manager: {secret_id}\")\r\n            response = self.client.get_secret_value(SecretId=secret_id)\r\n            \r\n            # Parse the secret string as JSON\r\n            secret_dict = json.loads(response['SecretString'])\r\n            \r\n            # Cache it\r\n            self._cache[secret_id] = secret_dict\r\n            logger.info(f\"Successfully fetched and cached secret: {secret_id}\")\r\n            \r\n            return secret_dict\r\n            \r\n        except Exception as e:\r\n            # Handle boto3 ClientError\r\n            if hasattr(e, 'response'):\r\n                error_code = e.response.get('Error', {}).get('Code', 'Unknown')\r\n                if error_code == 'ResourceNotFoundException':\r\n                    raise SecretsManagerError(f\"Secret '{secret_id}' not found in AWS Secrets Manager\")\r\n                elif error_code == 'AccessDeniedException':\r\n                    raise SecretsManagerError(\r\n                        f\"Access denied to secret '{secret_id}'. Check Lambda IAM permissions.\"\r\n                    )\r\n                else:\r\n                    raise SecretsManagerError(f\"AWS error fetching secret '{secret_id}': {error_code} - {str(e)}\")\r\n            \r\n            # Handle JSON parsing errors\r\n            if isinstance(e, json.JSONDecodeError):\r\n                raise SecretsManagerError(f\"Secret '{secret_id}' is not valid JSON: {str(e)}\")\r\n            \r\n            # Generic error\r\n            raise SecretsManagerError(f\"Error fetching secret '{secret_id}': {str(e)}\")",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\util\\secrets_manager.py",
    "function_name": "get_secret",
    "start_line": 44,
    "end_line": 93,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "def _import_secrets_manager() -> None:\r\n    \"\"\"Lazy import of SecretsManager to avoid boto3 dependency when not needed.\"\"\"\r\n    global _secrets_manager_imported, SecretsManager, SecretsManagerError\r\n    if not _secrets_manager_imported:\r\n        try:\r\n            from src.util.secrets_manager import SecretsManager as SM, SecretsManagerError as SME\r\n            SecretsManager = SM\r\n            SecretsManagerError = SME\r\n            _secrets_manager_imported = True\r\n        except ImportError as e:\r\n            logger.error(f\"Failed to import SecretsManager: {e}\")\r\n            raise ConfigVarError(\"SecretsManager module not found. Check src/util/secrets_manager.py exists.\")",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\util\\config_vars\\config_vars.py",
    "function_name": "_import_secrets_manager",
    "start_line": 14,
    "end_line": 25,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "class ConfigVarError(Exception):\r\n    \"\"\"Exception raised for configuration variable errors.\"\"\"\r\n    pass",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\util\\config_vars\\config_vars.py",
    "function_name": "ConfigVarError",
    "start_line": 28,
    "end_line": 30,
    "language": "python",
    "chunk_type": "class"
  },
  {
    "content": "class ConfigVars:\r\n    \"\"\"\r\n    Configuration class that loads environment variables as strings.\r\n    \r\n    Example usage:\r\n        config = ConfigVars()\r\n        print(config.env)\r\n        print(config.mongodb_host)\r\n    \"\"\"\r\n\r\n    def __init__(self) -> None:\r\n        # Initialize attributes to satisfy type checker\r\n        self._env: str = \"\"\r\n        self._west_bridge_url: str = \"\"\r\n        self._east_bridge_url: str = \"\"\r\n        self._enable_retry: str = \"\"\r\n        self._use_bridge: str = \"\"\r\n        self._mongodb_username: str = \"\"\r\n        self._mongodb_password: str = \"\"\r\n        self._mongodb_host: str = \"\"\r\n        self._mongodb_port: str = \"\"\r\n        self._mongodb_database: str = \"\"\r\n        # Load env vars and set config\r\n        self.__load_env_vars()\r\n\r\n    def __load_env_vars(self) -> None:\r\n        \"\"\"\r\n        Load environment variables from .env file.\r\n        If SECRETS_MANAGER_ARN is provided, MongoDB credentials are fetched from AWS Secrets Manager.\r\n        Raises ConfigVarError if required variables are missing.\r\n        \"\"\"\r\n        # Try to load .env file if it exists\r\n        try:\r\n            from dotenv import load_dotenv\r\n            load_dotenv()\r\n        except ImportError:\r\n            logger.warning(\"python-dotenv not installed. Only system environment variables will be used.\")\r\n        except Exception as e:\r\n            logger.warning(f\"Could not load .env file: {e}\")\r\n        \r\n        # Check if Secrets Manager should be used for MongoDB credentials\r\n        secrets_manager_arn = os.getenv('SECRETS_MANAGER_ARN')\r\n        if secrets_manager_arn:\r\n            logger.info(f\"SECRETS_MANAGER_ARN provided: {secrets_manager_arn}\")\r\n            logger.info(\"Fetching MongoDB credentials from AWS Secrets Manager...\")\r\n            \r\n            try:\r\n                # Import and initialize Secrets Manager\r\n                _import_secrets_manager()\r\n                if SecretsManager is None:\r\n                    raise ConfigVarError(\"SecretsManager failed to import properly\")\r\n                aws_region = os.getenv('AWS_REGION', 'us-east-1')\r\n                sm = SecretsManager(region_name=aws_region)\r\n                \r\n                # Fetch secrets\r\n                secrets = sm.get_secret(secrets_manager_arn)\r\n                \r\n                # Override environment variables with secrets\r\n                if 'username' in secrets:\r\n                    os.environ['MONGODB_USERNAME'] = secrets['username']\r\n                    logger.info(\"Loaded MONGODB_USERNAME from Secrets Manager\")\r\n                \r\n                if 'password' in secrets:\r\n                    os.environ['MONGODB_PASSWORD'] = secrets['password']\r\n                    logger.info(\"Loaded MONGODB_PASSWORD from Secrets Manager\")\r\n                \r\n                if 'host' in secrets:\r\n                    os.environ['MONGODB_HOST'] = secrets['host']\r\n                    logger.info(\"Loaded MONGODB_HOST from Secrets Manager\")\r\n                \r\n                if 'port' in secrets:\r\n                    os.environ['MONGODB_PORT'] = str(secrets['port'])\r\n                    logger.info(\"Loaded MONGODB_PORT from Secrets Manager\")\r\n                \r\n                if 'database' in secrets:\r\n                    os.environ['MONGODB_DATABASE'] = secrets['database']\r\n                    logger.info(\"Loaded MONGODB_DATABASE from Secrets Manager\")\r\n                \r\n                logger.info(\"Successfully loaded MongoDB credentials from Secrets Manager\")\r\n                \r\n            except Exception as e:\r\n                error_msg = f\"Failed to load secrets from Secrets Manager (ARN: {secrets_manager_arn}): {str(e)}\"\r\n                logger.error(error_msg)\r\n                raise ConfigVarError(error_msg)\r\n        else:\r\n            logger.info(\"SECRETS_MANAGER_ARN not provided, using environment variables directly\")\r\n        \r\n        # Define required and optional variables with their defaults\r\n        required_vars = [\r\n            'ENV',\r\n            'WEST_BRIDGE_URL',\r\n            'EAST_BRIDGE_URL',\r\n            'MONGODB_USERNAME',\r\n            'MONGODB_PASSWORD',\r\n            'MONGODB_HOST',\r\n        ]\r\n        \r\n        optional_vars = {\r\n            'ENABLE_RETRY': 'true',\r\n            'USE_BRIDGE': 'false',\r\n            'MONGODB_PORT': '27017',\r\n            'MONGODB_DATABASE': 'stride_sync',\r\n        }\r\n        \r\n        errors = []\r\n        \r\n        # Load required variables\r\n        for var_name in required_vars:\r\n            value = os.getenv(var_name)\r\n            if value is None:\r\n                error_msg = f\"Required environment variable '{var_name}' is not set\"\r\n                errors.append(error_msg)\r\n                logger.error(error_msg)\r\n            else:\r\n                attr_name = var_name.lower()\r\n                setattr(self, f'_{attr_name}', value)\r\n                # Don't log passwords\r\n                if 'password' not in var_name.lower():\r\n                    logger.debug(f\"Loaded config variable '{var_name}': {value}\")\r\n                else:\r\n                    logger.debug(f\"Loaded config variable '{var_name}': ***\")\r\n        \r\n        # Load optional variables\r\n        for var_name, default_value in optional_vars.items():\r\n            value = os.getenv(var_name, default_value)\r\n            attr_name = var_name.lower()\r\n            setattr(self, f'_{attr_name}', value)\r\n            logger.debug(f\"Loaded config variable '{var_name}': {value}\")\r\n        \r\n        # If there were any errors, raise an exception\r\n        if errors:\r\n            error_summary = \"\\n\".join(f\"  - {err}\" for err in errors)\r\n            raise ConfigVarError(\r\n                f\"Failed to load configuration variables:\\n{error_summary}\"\r\n            )\r\n        \r\n        # Print all loaded config vars for debugging (using print to ensure visibility)\r\n        print(\"=\" * 60)\r\n        print(\"LOADED CONFIGURATION VARIABLES:\")\r\n        print(f\"  ENV: {self._env}\")\r\n        print(f\"  WEST_BRIDGE_URL: {self._west_bridge_url}\")\r\n        print(f\"  EAST_BRIDGE_URL: {self._east_bridge_url}\")\r\n        print(f\"  ENABLE_RETRY: {self._enable_retry}\")\r\n        print(f\"  USE_BRIDGE: {self._use_bridge}\")\r\n        print(f\"  MONGODB_USERNAME: {self._mongodb_username}\")\r\n        print(f\"  MONGODB_PASSWORD: {'***' if self._mongodb_password else 'NOT SET'}\")\r\n        print(f\"  MONGODB_HOST: {self._mongodb_host}\")\r\n        print(f\"  MONGODB_PORT: {self._mongodb_port}\")\r\n        print(f\"  MONGODB_DATABASE: {self._mongodb_database}\")\r\n        print(\"=\" * 60)\r\n\r\n    # Properties to access configuration values\r\n    @property\r\n    def env(self) -> str:\r\n        \"\"\"Environment name (e.g., development, staging, production).\"\"\"\r\n        return self._env\r\n    \r\n    @property\r\n    def west_bridge_url(self) -> str:\r\n        \"\"\"West Bridge URL.\"\"\"\r\n        return self._west_bridge_url\r\n\r\n    @property\r\n    def east_bridge_url(self) -> str:\r\n        \"\"\"East Bridge URL.\"\"\"\r\n        return self._east_bridge_url\r\n    \r\n    @property\r\n    def enable_retry(self) -> str:\r\n        \"\"\"Enable retry with backoff on failed API calls (default: 'true').\"\"\"\r\n        return self._enable_retry\r\n    \r\n    @property\r\n    def use_bridge(self) -> str:\r\n        \"\"\"Use bridge proxies (east/west) for scraping requests (default: 'false').\"\"\"\r\n        return self._use_bridge\r\n    \r\n    @property\r\n    def mongodb_username(self) -> str:\r\n        \"\"\"MongoDB username for authentication.\"\"\"\r\n        return self._mongodb_username\r\n    \r\n    @property\r\n    def mongodb_password(self) -> str:\r\n        \"\"\"MongoDB password for authentication.\"\"\"\r\n        return self._mongodb_password\r\n    \r\n    @property\r\n    def mongodb_host(self) -> str:\r\n        \"\"\"MongoDB host address.\"\"\"\r\n        return self._mongodb_host\r\n    \r\n    @property\r\n    def mongodb_port(self) -> str:\r\n        \"\"\"MongoDB port number (default: '27017').\"\"\"\r\n        return self._mongodb_port\r\n    \r\n    @property\r\n    def mongodb_database(self) -> str:\r\n        \"\"\"MongoDB database name (default: 'stride_sync').\"\"\"\r\n        return self._mongodb_database",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\util\\config_vars\\config_vars.py",
    "function_name": "ConfigVars",
    "start_line": 33,
    "end_line": 233,
    "language": "python",
    "chunk_type": "class"
  },
  {
    "content": "def __init__(self) -> None:\r\n        # Initialize attributes to satisfy type checker\r\n        self._env: str = \"\"\r\n        self._west_bridge_url: str = \"\"\r\n        self._east_bridge_url: str = \"\"\r\n        self._enable_retry: str = \"\"\r\n        self._use_bridge: str = \"\"\r\n        self._mongodb_username: str = \"\"\r\n        self._mongodb_password: str = \"\"\r\n        self._mongodb_host: str = \"\"\r\n        self._mongodb_port: str = \"\"\r\n        self._mongodb_database: str = \"\"\r\n        # Load env vars and set config\r\n        self.__load_env_vars()",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\util\\config_vars\\config_vars.py",
    "function_name": "__init__",
    "start_line": 43,
    "end_line": 56,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "def __load_env_vars(self) -> None:\r\n        \"\"\"\r\n        Load environment variables from .env file.\r\n        If SECRETS_MANAGER_ARN is provided, MongoDB credentials are fetched from AWS Secrets Manager.\r\n        Raises ConfigVarError if required variables are missing.\r\n        \"\"\"\r\n        # Try to load .env file if it exists\r\n        try:\r\n            from dotenv import load_dotenv\r\n            load_dotenv()\r\n        except ImportError:\r\n            logger.warning(\"python-dotenv not installed. Only system environment variables will be used.\")\r\n        except Exception as e:\r\n            logger.warning(f\"Could not load .env file: {e}\")\r\n        \r\n        # Check if Secrets Manager should be used for MongoDB credentials\r\n        secrets_manager_arn = os.getenv('SECRETS_MANAGER_ARN')\r\n        if secrets_manager_arn:\r\n            logger.info(f\"SECRETS_MANAGER_ARN provided: {secrets_manager_arn}\")\r\n            logger.info(\"Fetching MongoDB credentials from AWS Secrets Manager...\")\r\n            \r\n            try:\r\n                # Import and initialize Secrets Manager\r\n                _import_secrets_manager()\r\n                if SecretsManager is None:\r\n                    raise ConfigVarError(\"SecretsManager failed to import properly\")\r\n                aws_region = os.getenv('AWS_REGION', 'us-east-1')\r\n                sm = SecretsManager(region_name=aws_region)\r\n                \r\n                # Fetch secrets\r\n                secrets = sm.get_secret(secrets_manager_arn)\r\n                \r\n                # Override environment variables with secrets\r\n                if 'username' in secrets:\r\n                    os.environ['MONGODB_USERNAME'] = secrets['username']\r\n                    logger.info(\"Loaded MONGODB_USERNAME from Secrets Manager\")\r\n                \r\n                if 'password' in secrets:\r\n                    os.environ['MONGODB_PASSWORD'] = secrets['password']\r\n                    logger.info(\"Loaded MONGODB_PASSWORD from Secrets Manager\")\r\n                \r\n                if 'host' in secrets:\r\n                    os.environ['MONGODB_HOST'] = secrets['host']\r\n                    logger.info(\"Loaded MONGODB_HOST from Secrets Manager\")\r\n                \r\n                if 'port' in secrets:\r\n                    os.environ['MONGODB_PORT'] = str(secrets['port'])\r\n                    logger.info(\"Loaded MONGODB_PORT from Secrets Manager\")\r\n                \r\n                if 'database' in secrets:\r\n                    os.environ['MONGODB_DATABASE'] = secrets['database']\r\n                    logger.info(\"Loaded MONGODB_DATABASE from Secrets Manager\")\r\n                \r\n                logger.info(\"Successfully loaded MongoDB credentials from Secrets Manager\")\r\n                \r\n            except Exception as e:\r\n                error_msg = f\"Failed to load secrets from Secrets Manager (ARN: {secrets_manager_arn}): {str(e)}\"\r\n                logger.error(error_msg)\r\n                raise ConfigVarError(error_msg)\r\n        else:\r\n            logger.info(\"SECRETS_MANAGER_ARN not provided, using environment variables directly\")\r\n        \r\n        # Define required and optional variables with their defaults\r\n        required_vars = [\r\n            'ENV',\r\n            'WEST_BRIDGE_URL',\r\n            'EAST_BRIDGE_URL',\r\n            'MONGODB_USERNAME',\r\n            'MONGODB_PASSWORD',\r\n            'MONGODB_HOST',\r\n        ]\r\n        \r\n        optional_vars = {\r\n            'ENABLE_RETRY': 'true',\r\n            'USE_BRIDGE': 'false',\r\n            'MONGODB_PORT': '27017',\r\n            'MONGODB_DATABASE': 'stride_sync',\r\n        }\r\n        \r\n        errors = []\r\n        \r\n        # Load required variables\r\n        for var_name in required_vars:\r\n            value = os.getenv(var_name)\r\n            if value is None:\r\n                error_msg = f\"Required environment variable '{var_name}' is not set\"\r\n                errors.append(error_msg)\r\n                logger.error(error_msg)\r\n            else:\r\n                attr_name = var_name.lower()\r\n                setattr(self, f'_{attr_name}', value)\r\n                # Don't log passwords\r\n                if 'password' not in var_name.lower():\r\n                    logger.debug(f\"Loaded config variable '{var_name}': {value}\")\r\n                else:\r\n                    logger.debug(f\"Loaded config variable '{var_name}': ***\")\r\n        \r\n        # Load optional variables\r\n        for var_name, default_value in optional_vars.items():\r\n            value = os.getenv(var_name, default_value)\r\n            attr_name = var_name.lower()\r\n            setattr(self, f'_{attr_name}', value)\r\n            logger.debug(f\"Loaded config variable '{var_name}': {value}\")\r\n        \r\n        # If there were any errors, raise an exception\r\n        if errors:\r\n            error_summary = \"\\n\".join(f\"  - {err}\" for err in errors)\r\n            raise ConfigVarError(\r\n                f\"Failed to load configuration variables:\\n{error_summary}\"\r\n            )\r\n        \r\n        # Print all loaded config vars for debugging (using print to ensure visibility)\r\n        print(\"=\" * 60)\r\n        print(\"LOADED CONFIGURATION VARIABLES:\")\r\n        print(f\"  ENV: {self._env}\")\r\n        print(f\"  WEST_BRIDGE_URL: {self._west_bridge_url}\")\r\n        print(f\"  EAST_BRIDGE_URL: {self._east_bridge_url}\")\r\n        print(f\"  ENABLE_RETRY: {self._enable_retry}\")\r\n        print(f\"  USE_BRIDGE: {self._use_bridge}\")\r\n        print(f\"  MONGODB_USERNAME: {self._mongodb_username}\")\r\n        print(f\"  MONGODB_PASSWORD: {'***' if self._mongodb_password else 'NOT SET'}\")\r\n        print(f\"  MONGODB_HOST: {self._mongodb_host}\")\r\n        print(f\"  MONGODB_PORT: {self._mongodb_port}\")\r\n        print(f\"  MONGODB_DATABASE: {self._mongodb_database}\")\r\n        print(\"=\" * 60)",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\util\\config_vars\\config_vars.py",
    "function_name": "__load_env_vars",
    "start_line": 58,
    "end_line": 182,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "@property\r\n    def env(self) -> str:\r\n        \"\"\"Environment name (e.g., development, staging, production).\"\"\"\r\n        return self._env",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\util\\config_vars\\config_vars.py",
    "function_name": "env",
    "start_line": 185,
    "end_line": 188,
    "language": "python",
    "chunk_type": "decorated"
  },
  {
    "content": "def env(self) -> str:\r\n        \"\"\"Environment name (e.g., development, staging, production).\"\"\"\r\n        return self._env",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\util\\config_vars\\config_vars.py",
    "function_name": "env",
    "start_line": 186,
    "end_line": 188,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "@property\r\n    def west_bridge_url(self) -> str:\r\n        \"\"\"West Bridge URL.\"\"\"\r\n        return self._west_bridge_url",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\util\\config_vars\\config_vars.py",
    "function_name": "west_bridge_url",
    "start_line": 190,
    "end_line": 193,
    "language": "python",
    "chunk_type": "decorated"
  },
  {
    "content": "def west_bridge_url(self) -> str:\r\n        \"\"\"West Bridge URL.\"\"\"\r\n        return self._west_bridge_url",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\util\\config_vars\\config_vars.py",
    "function_name": "west_bridge_url",
    "start_line": 191,
    "end_line": 193,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "@property\r\n    def east_bridge_url(self) -> str:\r\n        \"\"\"East Bridge URL.\"\"\"\r\n        return self._east_bridge_url",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\util\\config_vars\\config_vars.py",
    "function_name": "east_bridge_url",
    "start_line": 195,
    "end_line": 198,
    "language": "python",
    "chunk_type": "decorated"
  },
  {
    "content": "def east_bridge_url(self) -> str:\r\n        \"\"\"East Bridge URL.\"\"\"\r\n        return self._east_bridge_url",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\util\\config_vars\\config_vars.py",
    "function_name": "east_bridge_url",
    "start_line": 196,
    "end_line": 198,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "@property\r\n    def enable_retry(self) -> str:\r\n        \"\"\"Enable retry with backoff on failed API calls (default: 'true').\"\"\"\r\n        return self._enable_retry",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\util\\config_vars\\config_vars.py",
    "function_name": "enable_retry",
    "start_line": 200,
    "end_line": 203,
    "language": "python",
    "chunk_type": "decorated"
  },
  {
    "content": "def enable_retry(self) -> str:\r\n        \"\"\"Enable retry with backoff on failed API calls (default: 'true').\"\"\"\r\n        return self._enable_retry",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\util\\config_vars\\config_vars.py",
    "function_name": "enable_retry",
    "start_line": 201,
    "end_line": 203,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "@property\r\n    def use_bridge(self) -> str:\r\n        \"\"\"Use bridge proxies (east/west) for scraping requests (default: 'false').\"\"\"\r\n        return self._use_bridge",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\util\\config_vars\\config_vars.py",
    "function_name": "use_bridge",
    "start_line": 205,
    "end_line": 208,
    "language": "python",
    "chunk_type": "decorated"
  },
  {
    "content": "def use_bridge(self) -> str:\r\n        \"\"\"Use bridge proxies (east/west) for scraping requests (default: 'false').\"\"\"\r\n        return self._use_bridge",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\util\\config_vars\\config_vars.py",
    "function_name": "use_bridge",
    "start_line": 206,
    "end_line": 208,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "@property\r\n    def mongodb_username(self) -> str:\r\n        \"\"\"MongoDB username for authentication.\"\"\"\r\n        return self._mongodb_username",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\util\\config_vars\\config_vars.py",
    "function_name": "mongodb_username",
    "start_line": 210,
    "end_line": 213,
    "language": "python",
    "chunk_type": "decorated"
  },
  {
    "content": "def mongodb_username(self) -> str:\r\n        \"\"\"MongoDB username for authentication.\"\"\"\r\n        return self._mongodb_username",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\util\\config_vars\\config_vars.py",
    "function_name": "mongodb_username",
    "start_line": 211,
    "end_line": 213,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "@property\r\n    def mongodb_password(self) -> str:\r\n        \"\"\"MongoDB password for authentication.\"\"\"\r\n        return self._mongodb_password",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\util\\config_vars\\config_vars.py",
    "function_name": "mongodb_password",
    "start_line": 215,
    "end_line": 218,
    "language": "python",
    "chunk_type": "decorated"
  },
  {
    "content": "def mongodb_password(self) -> str:\r\n        \"\"\"MongoDB password for authentication.\"\"\"\r\n        return self._mongodb_password",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\util\\config_vars\\config_vars.py",
    "function_name": "mongodb_password",
    "start_line": 216,
    "end_line": 218,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "@property\r\n    def mongodb_host(self) -> str:\r\n        \"\"\"MongoDB host address.\"\"\"\r\n        return self._mongodb_host",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\util\\config_vars\\config_vars.py",
    "function_name": "mongodb_host",
    "start_line": 220,
    "end_line": 223,
    "language": "python",
    "chunk_type": "decorated"
  },
  {
    "content": "def mongodb_host(self) -> str:\r\n        \"\"\"MongoDB host address.\"\"\"\r\n        return self._mongodb_host",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\util\\config_vars\\config_vars.py",
    "function_name": "mongodb_host",
    "start_line": 221,
    "end_line": 223,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "@property\r\n    def mongodb_port(self) -> str:\r\n        \"\"\"MongoDB port number (default: '27017').\"\"\"\r\n        return self._mongodb_port",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\util\\config_vars\\config_vars.py",
    "function_name": "mongodb_port",
    "start_line": 225,
    "end_line": 228,
    "language": "python",
    "chunk_type": "decorated"
  },
  {
    "content": "def mongodb_port(self) -> str:\r\n        \"\"\"MongoDB port number (default: '27017').\"\"\"\r\n        return self._mongodb_port",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\util\\config_vars\\config_vars.py",
    "function_name": "mongodb_port",
    "start_line": 226,
    "end_line": 228,
    "language": "python",
    "chunk_type": "function"
  },
  {
    "content": "@property\r\n    def mongodb_database(self) -> str:\r\n        \"\"\"MongoDB database name (default: 'stride_sync').\"\"\"\r\n        return self._mongodb_database",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\util\\config_vars\\config_vars.py",
    "function_name": "mongodb_database",
    "start_line": 230,
    "end_line": 233,
    "language": "python",
    "chunk_type": "decorated"
  },
  {
    "content": "def mongodb_database(self) -> str:\r\n        \"\"\"MongoDB database name (default: 'stride_sync').\"\"\"\r\n        return self._mongodb_database",
    "file_path": "sample_repo\\StrideSync\\StrideSyncReaper\\src\\util\\config_vars\\config_vars.py",
    "function_name": "mongodb_database",
    "start_line": 231,
    "end_line": 233,
    "language": "python",
    "chunk_type": "function"
  }
]